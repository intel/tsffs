/* automatically generated by rust-bindgen 0.69.1 */

#![allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clippy::useless_transmute,
    clippy::unnecessary_cast,
    clippy::too_many_arguments,
    clippy::upper_case_acronyms,
    unused
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 131072;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const CHAR_MIN: u32 = 0;
pub const PAGE_1GB_SHIFT: u32 = 30;
pub const PAGE_2MB_SHIFT: u32 = 21;
pub const PAGE_4KB_SHIFT: u32 = 12;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_int;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_MEMORY_ADDRESS {
    pub Bits: _VIRTUAL_MEMORY_ADDRESS__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _VIRTUAL_MEMORY_ADDRESS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _VIRTUAL_MEMORY_ADDRESS__bindgen_ty_1 {
    #[inline]
    pub fn PageIndex(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_PageIndex(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn PtIndex(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_PtIndex(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn PdIndex(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_PdIndex(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn PdptIndex(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_PdptIndex(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Pml4Index(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_Pml4Index(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageIndex: u64,
        PtIndex: u64,
        PdIndex: u64,
        PdptIndex: u64,
        Pml4Index: u64,
        Unused: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageIndex: u64 = unsafe { ::std::mem::transmute(PageIndex) };
            PageIndex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 9u8, {
            let PtIndex: u64 = unsafe { ::std::mem::transmute(PtIndex) };
            PtIndex as u64
        });
        __bindgen_bitfield_unit.set(21usize, 9u8, {
            let PdIndex: u64 = unsafe { ::std::mem::transmute(PdIndex) };
            PdIndex as u64
        });
        __bindgen_bitfield_unit.set(30usize, 9u8, {
            let PdptIndex: u64 = unsafe { ::std::mem::transmute(PdptIndex) };
            PdptIndex as u64
        });
        __bindgen_bitfield_unit.set(39usize, 9u8, {
            let Pml4Index: u64 = unsafe { ::std::mem::transmute(Pml4Index) };
            Pml4Index as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VIRTUAL_MEMORY_ADDRESS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _VIRTUAL_MEMORY_ADDRESS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_VIRTUAL_MEMORY_ADDRESS {{ union }}")
    }
}
pub type VIRTUAL_ADDRESS = _VIRTUAL_MEMORY_ADDRESS;
pub type PVIRTUAL_ADDRESS = *mut _VIRTUAL_MEMORY_ADDRESS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DIRECTORY_TABLE_BASE {
    pub Bits: _DIRECTORY_TABLE_BASE__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _DIRECTORY_TABLE_BASE__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DIRECTORY_TABLE_BASE__bindgen_ty_1 {
    #[inline]
    pub fn Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 36u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 36u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Ignored0: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        _Ignored1: u64,
        PhysicalAddress: u64,
        _Reserved0: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Ignored0: u64 = unsafe { ::std::mem::transmute(Ignored0) };
            Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 36u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let _Reserved0: u64 = unsafe { ::std::mem::transmute(_Reserved0) };
            _Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _DIRECTORY_TABLE_BASE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _DIRECTORY_TABLE_BASE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_DIRECTORY_TABLE_BASE {{ union }}")
    }
}
pub type CR3 = _DIRECTORY_TABLE_BASE;
pub type DIR_TABLE_BASE = _DIRECTORY_TABLE_BASE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PML4_ENTRY {
    pub Bits: _PML4_ENTRY__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PML4_ENTRY__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PML4_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn Present(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserSupervisor(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UserSupervisor(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored2(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored2(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Present: u64,
        ReadWrite: u64,
        UserSupervisor: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        Accessed: u64,
        _Ignored0: u64,
        _Reserved0: u64,
        _Ignored1: u64,
        PhysicalAddress: u64,
        _Ignored2: u64,
        ExecuteDisable: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u64 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u64 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UserSupervisor: u64 = unsafe { ::std::mem::transmute(UserSupervisor) };
            UserSupervisor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let _Ignored0: u64 = unsafe { ::std::mem::transmute(_Ignored0) };
            _Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let _Reserved0: u64 = unsafe { ::std::mem::transmute(_Reserved0) };
            _Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 40u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let _Ignored2: u64 = unsafe { ::std::mem::transmute(_Ignored2) };
            _Ignored2 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ExecuteDisable: u64 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PML4_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _PML4_ENTRY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_PML4_ENTRY {{ union }}")
    }
}
pub type PML4E = _PML4_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PDPT_ENTRY_LARGE {
    pub Bits: _PDPT_ENTRY_LARGE__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PDPT_ENTRY_LARGE__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PDPT_ENTRY_LARGE__bindgen_ty_1 {
    #[inline]
    pub fn Present(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserSupervisor(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UserSupervisor(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageSize(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageSize(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PageAttributeTable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageAttributeTable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 17u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 22u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectionKey(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_ProtectionKey(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Present: u64,
        ReadWrite: u64,
        UserSupervisor: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        Accessed: u64,
        Dirty: u64,
        PageSize: u64,
        Global: u64,
        _Ignored0: u64,
        PageAttributeTable: u64,
        _Reserved0: u64,
        PhysicalAddress: u64,
        _Ignored1: u64,
        ProtectionKey: u64,
        ExecuteDisable: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u64 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u64 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UserSupervisor: u64 = unsafe { ::std::mem::transmute(UserSupervisor) };
            UserSupervisor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PageSize: u64 = unsafe { ::std::mem::transmute(PageSize) };
            PageSize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let _Ignored0: u64 = unsafe { ::std::mem::transmute(_Ignored0) };
            _Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PageAttributeTable: u64 = unsafe { ::std::mem::transmute(PageAttributeTable) };
            PageAttributeTable as u64
        });
        __bindgen_bitfield_unit.set(13usize, 17u8, {
            let _Reserved0: u64 = unsafe { ::std::mem::transmute(_Reserved0) };
            _Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 22u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(52usize, 7u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(59usize, 4u8, {
            let ProtectionKey: u64 = unsafe { ::std::mem::transmute(ProtectionKey) };
            ProtectionKey as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ExecuteDisable: u64 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PDPT_ENTRY_LARGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _PDPT_ENTRY_LARGE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_PDPT_ENTRY_LARGE {{ union }}")
    }
}
pub type PDPTE_LARGE = _PDPT_ENTRY_LARGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PDPT_ENTRY {
    pub Bits: _PDPT_ENTRY__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PDPT_ENTRY__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PDPT_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn Present(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserSupervisor(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UserSupervisor(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageSize(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageSize(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored2(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored2(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Present: u64,
        ReadWrite: u64,
        UserSupervisor: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        Accessed: u64,
        _Ignored0: u64,
        PageSize: u64,
        _Ignored1: u64,
        PhysicalAddress: u64,
        _Ignored2: u64,
        ExecuteDisable: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u64 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u64 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UserSupervisor: u64 = unsafe { ::std::mem::transmute(UserSupervisor) };
            UserSupervisor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let _Ignored0: u64 = unsafe { ::std::mem::transmute(_Ignored0) };
            _Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PageSize: u64 = unsafe { ::std::mem::transmute(PageSize) };
            PageSize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 40u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let _Ignored2: u64 = unsafe { ::std::mem::transmute(_Ignored2) };
            _Ignored2 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ExecuteDisable: u64 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PDPT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _PDPT_ENTRY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_PDPT_ENTRY {{ union }}")
    }
}
pub type PDPTE = _PDPT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PD_ENTRY_LARGE {
    pub Bits: _PD_ENTRY_LARGE__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PD_ENTRY_LARGE__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PD_ENTRY_LARGE__bindgen_ty_1 {
    #[inline]
    pub fn Present(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserSupervisor(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UserSupervisor(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageSize(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageSize(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PageAttributeTalbe(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageAttributeTalbe(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 29u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectionKey(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_ProtectionKey(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Present: u64,
        ReadWrite: u64,
        UserSupervisor: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        Accessed: u64,
        Dirty: u64,
        PageSize: u64,
        Global: u64,
        _Ignored0: u64,
        PageAttributeTalbe: u64,
        _Reserved0: u64,
        PhysicalAddress: u64,
        _Reserved1: u64,
        _Ignored1: u64,
        ProtectionKey: u64,
        ExecuteDisable: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u64 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u64 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UserSupervisor: u64 = unsafe { ::std::mem::transmute(UserSupervisor) };
            UserSupervisor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PageSize: u64 = unsafe { ::std::mem::transmute(PageSize) };
            PageSize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let _Ignored0: u64 = unsafe { ::std::mem::transmute(_Ignored0) };
            _Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PageAttributeTalbe: u64 = unsafe { ::std::mem::transmute(PageAttributeTalbe) };
            PageAttributeTalbe as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let _Reserved0: u64 = unsafe { ::std::mem::transmute(_Reserved0) };
            _Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 29u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(50usize, 2u8, {
            let _Reserved1: u64 = unsafe { ::std::mem::transmute(_Reserved1) };
            _Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 7u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(59usize, 4u8, {
            let ProtectionKey: u64 = unsafe { ::std::mem::transmute(ProtectionKey) };
            ProtectionKey as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ExecuteDisable: u64 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PD_ENTRY_LARGE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _PD_ENTRY_LARGE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_PD_ENTRY_LARGE {{ union }}")
    }
}
pub type PDE_LARGE = _PD_ENTRY_LARGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PD_ENTRY {
    pub Bits: _PD_ENTRY__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PD_ENTRY__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PD_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn Present(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserSupervisor(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UserSupervisor(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageSize(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageSize(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 38u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 38u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored2(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored2(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Present: u64,
        ReadWrite: u64,
        UserSupervisor: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        Accessed: u64,
        _Ignored0: u64,
        PageSize: u64,
        _Ignored1: u64,
        PhysicalAddress: u64,
        _Reserved0: u64,
        _Ignored2: u64,
        ExecuteDisable: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u64 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u64 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UserSupervisor: u64 = unsafe { ::std::mem::transmute(UserSupervisor) };
            UserSupervisor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let _Ignored0: u64 = unsafe { ::std::mem::transmute(_Ignored0) };
            _Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PageSize: u64 = unsafe { ::std::mem::transmute(PageSize) };
            PageSize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 38u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(50usize, 2u8, {
            let _Reserved0: u64 = unsafe { ::std::mem::transmute(_Reserved0) };
            _Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let _Ignored2: u64 = unsafe { ::std::mem::transmute(_Ignored2) };
            _Ignored2 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ExecuteDisable: u64 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PD_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _PD_ENTRY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_PD_ENTRY {{ union }}")
    }
}
pub type PDE = _PD_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PT_ENTRY {
    pub Bits: _PT_ENTRY__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PT_ENTRY__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PT_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn Present(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserSupervisor(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UserSupervisor(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageWriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageWriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageCacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageCacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageAttributeTable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PageAttributeTable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 38u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 38u8, val as u64)
        }
    }
    #[inline]
    pub fn _Reserved0(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set__Reserved0(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn _Ignored1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set__Ignored1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ProtectionKey(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_ProtectionKey(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ExecuteDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExecuteDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Present: u64,
        ReadWrite: u64,
        UserSupervisor: u64,
        PageWriteThrough: u64,
        PageCacheDisable: u64,
        Accessed: u64,
        Dirty: u64,
        PageAttributeTable: u64,
        Global: u64,
        _Ignored0: u64,
        PhysicalAddress: u64,
        _Reserved0: u64,
        _Ignored1: u64,
        ProtectionKey: u64,
        ExecuteDisable: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Present: u64 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadWrite: u64 = unsafe { ::std::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UserSupervisor: u64 = unsafe { ::std::mem::transmute(UserSupervisor) };
            UserSupervisor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PageWriteThrough: u64 = unsafe { ::std::mem::transmute(PageWriteThrough) };
            PageWriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PageCacheDisable: u64 = unsafe { ::std::mem::transmute(PageCacheDisable) };
            PageCacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PageAttributeTable: u64 = unsafe { ::std::mem::transmute(PageAttributeTable) };
            PageAttributeTable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let _Ignored0: u64 = unsafe { ::std::mem::transmute(_Ignored0) };
            _Ignored0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 38u8, {
            let PhysicalAddress: u64 = unsafe { ::std::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(50usize, 2u8, {
            let _Reserved0: u64 = unsafe { ::std::mem::transmute(_Reserved0) };
            _Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 7u8, {
            let _Ignored1: u64 = unsafe { ::std::mem::transmute(_Ignored1) };
            _Ignored1 as u64
        });
        __bindgen_bitfield_unit.set(59usize, 4u8, {
            let ProtectionKey: u64 = unsafe { ::std::mem::transmute(ProtectionKey) };
            ProtectionKey as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ExecuteDisable: u64 = unsafe { ::std::mem::transmute(ExecuteDisable) };
            ExecuteDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _PT_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _PT_ENTRY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_PT_ENTRY {{ union }}")
    }
}
pub type PTE = _PT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPTE_HARDWARE {
    pub Bits: _MMPTE_HARDWARE__bindgen_ty_1,
    pub All: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MMPTE_HARDWARE__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MMPTE_HARDWARE__bindgen_ty_1 {
    #[inline]
    pub fn Valid(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty1(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CopyOnWrite(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CopyOnWrite(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 36u8) as u64) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 36u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedForHardware(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_ReservedForHardware(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedForSoftware(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_ReservedForSoftware(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WsleAge(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_WsleAge(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WsleProtection(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_WsleProtection(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NoExecute(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NoExecute(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: u64,
        Dirty1: u64,
        Owner: u64,
        WriteThrough: u64,
        CacheDisable: u64,
        Accessed: u64,
        Dirty: u64,
        LargePage: u64,
        Global: u64,
        CopyOnWrite: u64,
        Unused: u64,
        Write: u64,
        PageFrameNumber: u64,
        ReservedForHardware: u64,
        ReservedForSoftware: u64,
        WsleAge: u64,
        WsleProtection: u64,
        NoExecute: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u64 = unsafe { ::std::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Dirty1: u64 = unsafe { ::std::mem::transmute(Dirty1) };
            Dirty1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u64 = unsafe { ::std::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u64 = unsafe { ::std::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u64 = unsafe { ::std::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u64 = unsafe { ::std::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u64 = unsafe { ::std::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u64 = unsafe { ::std::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u64 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CopyOnWrite: u64 = unsafe { ::std::mem::transmute(CopyOnWrite) };
            CopyOnWrite as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Unused: u64 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Write: u64 = unsafe { ::std::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(12usize, 36u8, {
            let PageFrameNumber: u64 = unsafe { ::std::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let ReservedForHardware: u64 = unsafe { ::std::mem::transmute(ReservedForHardware) };
            ReservedForHardware as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let ReservedForSoftware: u64 = unsafe { ::std::mem::transmute(ReservedForSoftware) };
            ReservedForSoftware as u64
        });
        __bindgen_bitfield_unit.set(56usize, 4u8, {
            let WsleAge: u64 = unsafe { ::std::mem::transmute(WsleAge) };
            WsleAge as u64
        });
        __bindgen_bitfield_unit.set(60usize, 3u8, {
            let WsleProtection: u64 = unsafe { ::std::mem::transmute(WsleProtection) };
            WsleProtection as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let NoExecute: u64 = unsafe { ::std::mem::transmute(NoExecute) };
            NoExecute as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _MMPTE_HARDWARE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _MMPTE_HARDWARE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_MMPTE_HARDWARE {{ union }}")
    }
}
pub type MMPTE_HARDWARE = _MMPTE_HARDWARE;
