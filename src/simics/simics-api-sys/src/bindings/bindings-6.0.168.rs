// Copyright (C) 2023 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const PY_RELEASE_LEVEL_ALPHA: u32 = 10;
pub const PY_RELEASE_LEVEL_BETA: u32 = 11;
pub const PY_RELEASE_LEVEL_GAMMA: u32 = 12;
pub const PY_RELEASE_LEVEL_FINAL: u32 = 15;
pub const PY_MAJOR_VERSION: u32 = 3;
pub const PY_MINOR_VERSION: u32 = 9;
pub const PY_MICRO_VERSION: u32 = 16;
pub const PY_RELEASE_LEVEL: u32 = 15;
pub const PY_RELEASE_SERIAL: u32 = 0;
pub const PY_VERSION: &[u8; 7] = b"3.9.16\0";
pub const PY_VERSION_HEX: u32 = 50925808;
pub const DOUBLE_IS_LITTLE_ENDIAN_IEEE754: u32 = 1;
pub const ENABLE_IPV6: u32 = 1;
pub const HAVE_ACCEPT4: u32 = 1;
pub const HAVE_ACOSH: u32 = 1;
pub const HAVE_ADDRINFO: u32 = 1;
pub const HAVE_ALARM: u32 = 1;
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_ASINH: u32 = 1;
pub const HAVE_ASM_TYPES_H: u32 = 1;
pub const HAVE_ATANH: u32 = 1;
pub const HAVE_BIND_TEXTDOMAIN_CODESET: u32 = 1;
pub const HAVE_BUILTIN_ATOMIC: u32 = 1;
pub const HAVE_CHOWN: u32 = 1;
pub const HAVE_CHROOT: u32 = 1;
pub const HAVE_CLOCK: u32 = 1;
pub const HAVE_CLOCK_GETRES: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_CLOCK_SETTIME: u32 = 1;
pub const HAVE_COMPUTED_GOTOS: u32 = 1;
pub const HAVE_CONFSTR: u32 = 1;
pub const HAVE_COPYSIGN: u32 = 1;
pub const HAVE_CRYPT_H: u32 = 1;
pub const HAVE_CRYPT_R: u32 = 1;
pub const HAVE_CTERMID: u32 = 1;
pub const HAVE_CURSES_FILTER: u32 = 1;
pub const HAVE_CURSES_H: u32 = 1;
pub const HAVE_CURSES_HAS_KEY: u32 = 1;
pub const HAVE_CURSES_IMMEDOK: u32 = 1;
pub const HAVE_CURSES_IS_PAD: u32 = 1;
pub const HAVE_CURSES_IS_TERM_RESIZED: u32 = 1;
pub const HAVE_CURSES_RESIZETERM: u32 = 1;
pub const HAVE_CURSES_RESIZE_TERM: u32 = 1;
pub const HAVE_CURSES_SYNCOK: u32 = 1;
pub const HAVE_CURSES_TYPEAHEAD: u32 = 1;
pub const HAVE_CURSES_USE_ENV: u32 = 1;
pub const HAVE_CURSES_WCHGAT: u32 = 1;
pub const HAVE_DECL_ISFINITE: u32 = 1;
pub const HAVE_DECL_ISINF: u32 = 1;
pub const HAVE_DECL_ISNAN: u32 = 1;
pub const HAVE_DECL_RTLD_DEEPBIND: u32 = 1;
pub const HAVE_DECL_RTLD_GLOBAL: u32 = 1;
pub const HAVE_DECL_RTLD_LAZY: u32 = 1;
pub const HAVE_DECL_RTLD_LOCAL: u32 = 1;
pub const HAVE_DECL_RTLD_MEMBER: u32 = 0;
pub const HAVE_DECL_RTLD_NODELETE: u32 = 1;
pub const HAVE_DECL_RTLD_NOLOAD: u32 = 1;
pub const HAVE_DECL_RTLD_NOW: u32 = 1;
pub const HAVE_DEVICE_MACROS: u32 = 1;
pub const HAVE_DEV_PTMX: u32 = 1;
pub const HAVE_DIRENT_D_TYPE: u32 = 1;
pub const HAVE_DIRENT_H: u32 = 1;
pub const HAVE_DIRFD: u32 = 1;
pub const HAVE_DLFCN_H: u32 = 1;
pub const HAVE_DLOPEN: u32 = 1;
pub const HAVE_DUP2: u32 = 1;
pub const HAVE_DUP3: u32 = 1;
pub const HAVE_DYNAMIC_LOADING: u32 = 1;
pub const HAVE_ENDIAN_H: u32 = 1;
pub const HAVE_EPOLL: u32 = 1;
pub const HAVE_EPOLL_CREATE1: u32 = 1;
pub const HAVE_ERF: u32 = 1;
pub const HAVE_ERFC: u32 = 1;
pub const HAVE_ERRNO_H: u32 = 1;
pub const HAVE_EXECV: u32 = 1;
pub const HAVE_EXPM1: u32 = 1;
pub const HAVE_FACCESSAT: u32 = 1;
pub const HAVE_FCHDIR: u32 = 1;
pub const HAVE_FCHMOD: u32 = 1;
pub const HAVE_FCHMODAT: u32 = 1;
pub const HAVE_FCHOWN: u32 = 1;
pub const HAVE_FCHOWNAT: u32 = 1;
pub const HAVE_FCNTL_H: u32 = 1;
pub const HAVE_FDATASYNC: u32 = 1;
pub const HAVE_FDOPENDIR: u32 = 1;
pub const HAVE_FEXECVE: u32 = 1;
pub const HAVE_FINITE: u32 = 1;
pub const HAVE_FLOCK: u32 = 1;
pub const HAVE_FORK: u32 = 1;
pub const HAVE_FORKPTY: u32 = 1;
pub const HAVE_FPATHCONF: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FSTATAT: u32 = 1;
pub const HAVE_FSTATVFS: u32 = 1;
pub const HAVE_FSYNC: u32 = 1;
pub const HAVE_FTELLO: u32 = 1;
pub const HAVE_FTIME: u32 = 1;
pub const HAVE_FTRUNCATE: u32 = 1;
pub const HAVE_FUTIMENS: u32 = 1;
pub const HAVE_FUTIMES: u32 = 1;
pub const HAVE_FUTIMESAT: u32 = 1;
pub const HAVE_GAI_STRERROR: u32 = 1;
pub const HAVE_GAMMA: u32 = 1;
pub const HAVE_GCC_ASM_FOR_X64: u32 = 1;
pub const HAVE_GCC_ASM_FOR_X87: u32 = 1;
pub const HAVE_GCC_UINT128_T: u32 = 1;
pub const HAVE_GETADDRINFO: u32 = 1;
pub const HAVE_GETC_UNLOCKED: u32 = 1;
pub const HAVE_GETGRGID_R: u32 = 1;
pub const HAVE_GETGRNAM_R: u32 = 1;
pub const HAVE_GETGROUPLIST: u32 = 1;
pub const HAVE_GETGROUPS: u32 = 1;
pub const HAVE_GETHOSTBYNAME_R: u32 = 1;
pub const HAVE_GETHOSTBYNAME_R_6_ARG: u32 = 1;
pub const HAVE_GETITIMER: u32 = 1;
pub const HAVE_GETLOADAVG: u32 = 1;
pub const HAVE_GETLOGIN: u32 = 1;
pub const HAVE_GETNAMEINFO: u32 = 1;
pub const HAVE_GETPAGESIZE: u32 = 1;
pub const HAVE_GETPEERNAME: u32 = 1;
pub const HAVE_GETPGID: u32 = 1;
pub const HAVE_GETPGRP: u32 = 1;
pub const HAVE_GETPID: u32 = 1;
pub const HAVE_GETPRIORITY: u32 = 1;
pub const HAVE_GETPWENT: u32 = 1;
pub const HAVE_GETPWNAM_R: u32 = 1;
pub const HAVE_GETPWUID_R: u32 = 1;
pub const HAVE_GETRESGID: u32 = 1;
pub const HAVE_GETRESUID: u32 = 1;
pub const HAVE_GETSID: u32 = 1;
pub const HAVE_GETSPENT: u32 = 1;
pub const HAVE_GETSPNAM: u32 = 1;
pub const HAVE_GETWD: u32 = 1;
pub const HAVE_GRP_H: u32 = 1;
pub const HAVE_HSTRERROR: u32 = 1;
pub const HAVE_HTOLE64: u32 = 1;
pub const HAVE_HYPOT: u32 = 1;
pub const HAVE_IF_NAMEINDEX: u32 = 1;
pub const HAVE_INET_ATON: u32 = 1;
pub const HAVE_INET_PTON: u32 = 1;
pub const HAVE_INITGROUPS: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_KILL: u32 = 1;
pub const HAVE_KILLPG: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LCHOWN: u32 = 1;
pub const HAVE_LGAMMA: u32 = 1;
pub const HAVE_LIBDL: u32 = 1;
pub const HAVE_LIBINTL_H: u32 = 1;
pub const HAVE_LIBREADLINE: u32 = 1;
pub const HAVE_LIBUUID: u32 = 1;
pub const HAVE_LINK: u32 = 1;
pub const HAVE_LINKAT: u32 = 1;
pub const HAVE_LINUX_AUXVEC_H: u32 = 1;
pub const HAVE_LINUX_CAN_H: u32 = 1;
pub const HAVE_LINUX_CAN_RAW_H: u32 = 1;
pub const HAVE_LINUX_NETLINK_H: u32 = 1;
pub const HAVE_LINUX_RANDOM_H: u32 = 1;
pub const HAVE_LINUX_TIPC_H: u32 = 1;
pub const HAVE_LINUX_WAIT_H: u32 = 1;
pub const HAVE_LOCKF: u32 = 1;
pub const HAVE_LOG1P: u32 = 1;
pub const HAVE_LOG2: u32 = 1;
pub const HAVE_LONG_DOUBLE: u32 = 1;
pub const HAVE_LSTAT: u32 = 1;
pub const HAVE_LUTIMES: u32 = 1;
pub const HAVE_MADVISE: u32 = 1;
pub const HAVE_MAKEDEV: u32 = 1;
pub const HAVE_MBRTOWC: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_MEMRCHR: u32 = 1;
pub const HAVE_MKDIRAT: u32 = 1;
pub const HAVE_MKFIFO: u32 = 1;
pub const HAVE_MKFIFOAT: u32 = 1;
pub const HAVE_MKNOD: u32 = 1;
pub const HAVE_MKNODAT: u32 = 1;
pub const HAVE_MKTIME: u32 = 1;
pub const HAVE_MMAP: u32 = 1;
pub const HAVE_MREMAP: u32 = 1;
pub const HAVE_NCURSES_H: u32 = 1;
pub const HAVE_NETPACKET_PACKET_H: u32 = 1;
pub const HAVE_NET_IF_H: u32 = 1;
pub const HAVE_NICE: u32 = 1;
pub const HAVE_OPENAT: u32 = 1;
pub const HAVE_OPENPTY: u32 = 1;
pub const HAVE_PATHCONF: u32 = 1;
pub const HAVE_PAUSE: u32 = 1;
pub const HAVE_PIPE2: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_POSIX_FADVISE: u32 = 1;
pub const HAVE_POSIX_FALLOCATE: u32 = 1;
pub const HAVE_POSIX_SPAWN: u32 = 1;
pub const HAVE_POSIX_SPAWNP: u32 = 1;
pub const HAVE_PREAD: u32 = 1;
pub const HAVE_PREADV: u32 = 1;
pub const HAVE_PROTOTYPES: u32 = 1;
pub const HAVE_PTHREAD_CONDATTR_SETCLOCK: u32 = 1;
pub const HAVE_PTHREAD_GETCPUCLOCKID: u32 = 1;
pub const HAVE_PTHREAD_H: u32 = 1;
pub const HAVE_PTHREAD_KILL: u32 = 1;
pub const HAVE_PTHREAD_SIGMASK: u32 = 1;
pub const HAVE_PTY_H: u32 = 1;
pub const HAVE_PWRITE: u32 = 1;
pub const HAVE_PWRITEV: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_READLINKAT: u32 = 1;
pub const HAVE_READV: u32 = 1;
pub const HAVE_REALPATH: u32 = 1;
pub const HAVE_RENAMEAT: u32 = 1;
pub const HAVE_RL_APPEND_HISTORY: u32 = 1;
pub const HAVE_RL_CATCH_SIGNAL: u32 = 1;
pub const HAVE_RL_COMPLETION_APPEND_CHARACTER: u32 = 1;
pub const HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK: u32 = 1;
pub const HAVE_RL_COMPLETION_MATCHES: u32 = 1;
pub const HAVE_RL_COMPLETION_SUPPRESS_APPEND: u32 = 1;
pub const HAVE_RL_PRE_INPUT_HOOK: u32 = 1;
pub const HAVE_RL_RESIZE_TERMINAL: u32 = 1;
pub const HAVE_ROUND: u32 = 1;
pub const HAVE_SCHED_GET_PRIORITY_MAX: u32 = 1;
pub const HAVE_SCHED_H: u32 = 1;
pub const HAVE_SCHED_RR_GET_INTERVAL: u32 = 1;
pub const HAVE_SCHED_SETAFFINITY: u32 = 1;
pub const HAVE_SCHED_SETPARAM: u32 = 1;
pub const HAVE_SCHED_SETSCHEDULER: u32 = 1;
pub const HAVE_SEM_GETVALUE: u32 = 1;
pub const HAVE_SEM_OPEN: u32 = 1;
pub const HAVE_SEM_TIMEDWAIT: u32 = 1;
pub const HAVE_SEM_UNLINK: u32 = 1;
pub const HAVE_SENDFILE: u32 = 1;
pub const HAVE_SETEGID: u32 = 1;
pub const HAVE_SETEUID: u32 = 1;
pub const HAVE_SETGID: u32 = 1;
pub const HAVE_SETGROUPS: u32 = 1;
pub const HAVE_SETHOSTNAME: u32 = 1;
pub const HAVE_SETITIMER: u32 = 1;
pub const HAVE_SETLOCALE: u32 = 1;
pub const HAVE_SETPGID: u32 = 1;
pub const HAVE_SETPGRP: u32 = 1;
pub const HAVE_SETPRIORITY: u32 = 1;
pub const HAVE_SETREGID: u32 = 1;
pub const HAVE_SETRESGID: u32 = 1;
pub const HAVE_SETRESUID: u32 = 1;
pub const HAVE_SETREUID: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SETUID: u32 = 1;
pub const HAVE_SETVBUF: u32 = 1;
pub const HAVE_SHADOW_H: u32 = 1;
pub const HAVE_SHM_OPEN: u32 = 1;
pub const HAVE_SHM_UNLINK: u32 = 1;
pub const HAVE_SIGACTION: u32 = 1;
pub const HAVE_SIGALTSTACK: u32 = 1;
pub const HAVE_SIGFILLSET: u32 = 1;
pub const HAVE_SIGINFO_T_SI_BAND: u32 = 1;
pub const HAVE_SIGINTERRUPT: u32 = 1;
pub const HAVE_SIGNAL_H: u32 = 1;
pub const HAVE_SIGPENDING: u32 = 1;
pub const HAVE_SIGRELSE: u32 = 1;
pub const HAVE_SIGTIMEDWAIT: u32 = 1;
pub const HAVE_SIGWAIT: u32 = 1;
pub const HAVE_SIGWAITINFO: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_SOCKADDR_STORAGE: u32 = 1;
pub const HAVE_SOCKETPAIR: u32 = 1;
pub const HAVE_SPAWN_H: u32 = 1;
pub const HAVE_SSIZE_T: u32 = 1;
pub const HAVE_STATVFS: u32 = 1;
pub const HAVE_STAT_TV_NSEC: u32 = 1;
pub const HAVE_STDARG_PROTOTYPES: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STD_ATOMIC: u32 = 1;
pub const HAVE_STRDUP: u32 = 1;
pub const HAVE_STRFTIME: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRSIGNAL: u32 = 1;
pub const HAVE_STRUCT_PASSWD_PW_GECOS: u32 = 1;
pub const HAVE_STRUCT_PASSWD_PW_PASSWD: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_BLKSIZE: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_BLOCKS: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_RDEV: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const HAVE_SYMLINKAT: u32 = 1;
pub const HAVE_SYNC: u32 = 1;
pub const HAVE_SYSCONF: u32 = 1;
pub const HAVE_SYSEXITS_H: u32 = 1;
pub const HAVE_SYS_EPOLL_H: u32 = 1;
pub const HAVE_SYS_FILE_H: u32 = 1;
pub const HAVE_SYS_IOCTL_H: u32 = 1;
pub const HAVE_SYS_MMAN_H: u32 = 1;
pub const HAVE_SYS_PARAM_H: u32 = 1;
pub const HAVE_SYS_POLL_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SENDFILE_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_STATVFS_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_SYSCALL_H: u32 = 1;
pub const HAVE_SYS_SYSMACROS_H: u32 = 1;
pub const HAVE_SYS_TIMES_H: u32 = 1;
pub const HAVE_SYS_TIME_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UIO_H: u32 = 1;
pub const HAVE_SYS_UN_H: u32 = 1;
pub const HAVE_SYS_UTSNAME_H: u32 = 1;
pub const HAVE_SYS_WAIT_H: u32 = 1;
pub const HAVE_SYS_XATTR_H: u32 = 1;
pub const HAVE_TCGETPGRP: u32 = 1;
pub const HAVE_TCSETPGRP: u32 = 1;
pub const HAVE_TEMPNAM: u32 = 1;
pub const HAVE_TERMIOS_H: u32 = 1;
pub const HAVE_TERM_H: u32 = 1;
pub const HAVE_TGAMMA: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_TIMES: u32 = 1;
pub const HAVE_TMPFILE: u32 = 1;
pub const HAVE_TMPNAM: u32 = 1;
pub const HAVE_TMPNAM_R: u32 = 1;
pub const HAVE_TM_ZONE: u32 = 1;
pub const HAVE_TRUNCATE: u32 = 1;
pub const HAVE_UNAME: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_UNLINKAT: u32 = 1;
pub const HAVE_UTIMENSAT: u32 = 1;
pub const HAVE_UTIMES: u32 = 1;
pub const HAVE_UTIME_H: u32 = 1;
pub const HAVE_UUID_GENERATE_TIME_SAFE: u32 = 1;
pub const HAVE_UUID_H: u32 = 1;
pub const HAVE_UUID_UUID_H: u32 = 1;
pub const HAVE_WAIT3: u32 = 1;
pub const HAVE_WAIT4: u32 = 1;
pub const HAVE_WAITID: u32 = 1;
pub const HAVE_WAITPID: u32 = 1;
pub const HAVE_WCHAR_H: u32 = 1;
pub const HAVE_WCSCOLL: u32 = 1;
pub const HAVE_WCSFTIME: u32 = 1;
pub const HAVE_WCSXFRM: u32 = 1;
pub const HAVE_WMEMCMP: u32 = 1;
pub const HAVE_WORKING_TZSET: u32 = 1;
pub const HAVE_WRITEV: u32 = 1;
pub const HAVE_X509_VERIFY_PARAM_SET1_HOST: u32 = 1;
pub const HAVE_ZLIB_COPY: u32 = 1;
pub const MVWDELCH_IS_EXPRESSION: u32 = 1;
pub const PTHREAD_KEY_T_IS_COMPATIBLE_WITH_INT: u32 = 1;
pub const PTHREAD_SYSTEM_SCHED_SUPPORTED: u32 = 1;
pub const PY_BUILTIN_HASHLIB_HASHES: &[u8; 35] = b"md5,sha1,sha256,sha512,sha3,blake2\0";
pub const PY_COERCE_C_LOCALE: u32 = 1;
pub const PY_FORMAT_SIZE_T: &[u8; 2] = b"z\0";
pub const PY_SSL_DEFAULT_CIPHERS: u32 = 1;
pub const SIZEOF_DOUBLE: u32 = 8;
pub const SIZEOF_FLOAT: u32 = 4;
pub const SIZEOF_FPOS_T: u32 = 16;
pub const SIZEOF_INT: u32 = 4;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_LONG_DOUBLE: u32 = 16;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_PID_T: u32 = 4;
pub const SIZEOF_PTHREAD_KEY_T: u32 = 4;
pub const SIZEOF_PTHREAD_T: u32 = 8;
pub const SIZEOF_SHORT: u32 = 2;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_TIME_T: u32 = 8;
pub const SIZEOF_UINTPTR_T: u32 = 8;
pub const SIZEOF_VOID_P: u32 = 8;
pub const SIZEOF_WCHAR_T: u32 = 4;
pub const SIZEOF__BOOL: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const SYS_SELECT_WITH_SYS_TIME: u32 = 1;
pub const TIME_WITH_SYS_TIME: u32 = 1;
pub const USE_COMPUTED_GOTOS: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const WINDOW_HAS_FLAGS: u32 = 1;
pub const WITH_DECIMAL_CONTEXTVAR: u32 = 1;
pub const WITH_DOC_STRINGS: u32 = 1;
pub const WITH_PYMALLOC: u32 = 1;
pub const _DARWIN_C_SOURCE: u32 = 1;
pub const _FILE_OFFSET_BITS: u32 = 64;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const _NETBSD_SOURCE: u32 = 1;
pub const _PYTHONFRAMEWORK: &[u8; 1] = b"\0";
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _ASSERT_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const HAVE_LONG_LONG: u32 = 1;
pub const PYLONG_BITS_IN_DIGIT: u32 = 30;
pub const SIZEOF_PY_HASH_T: u32 = 8;
pub const SIZEOF_PY_UHASH_T: u32 = 8;
pub const PY_SIZE_MAX: i32 = -1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _SYS_TIME_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const HAVE_PY_SET_53BIT_PRECISION: u32 = 1;
pub const LONG_BIT: u32 = 64;
pub const PY_BIG_ENDIAN: u32 = 0;
pub const PY_LITTLE_ENDIAN: u32 = 1;
pub const PY_DWORD_MAX: u32 = 4294967295;
pub const Py_PRINT_RAW: u32 = 1;
pub const Py_TPFLAGS_HEAPTYPE: u32 = 512;
pub const Py_TPFLAGS_BASETYPE: u32 = 1024;
pub const Py_TPFLAGS_HAVE_VECTORCALL: u32 = 2048;
pub const _Py_TPFLAGS_HAVE_VECTORCALL: u32 = 2048;
pub const Py_TPFLAGS_READY: u32 = 4096;
pub const Py_TPFLAGS_READYING: u32 = 8192;
pub const Py_TPFLAGS_HAVE_GC: u32 = 16384;
pub const Py_TPFLAGS_HAVE_STACKLESS_EXTENSION: u32 = 0;
pub const Py_TPFLAGS_METHOD_DESCRIPTOR: u32 = 131072;
pub const Py_TPFLAGS_HAVE_VERSION_TAG: u32 = 262144;
pub const Py_TPFLAGS_VALID_VERSION_TAG: u32 = 524288;
pub const Py_TPFLAGS_IS_ABSTRACT: u32 = 1048576;
pub const Py_TPFLAGS_LONG_SUBCLASS: u32 = 16777216;
pub const Py_TPFLAGS_LIST_SUBCLASS: u32 = 33554432;
pub const Py_TPFLAGS_TUPLE_SUBCLASS: u32 = 67108864;
pub const Py_TPFLAGS_BYTES_SUBCLASS: u32 = 134217728;
pub const Py_TPFLAGS_UNICODE_SUBCLASS: u32 = 268435456;
pub const Py_TPFLAGS_DICT_SUBCLASS: u32 = 536870912;
pub const Py_TPFLAGS_BASE_EXC_SUBCLASS: u32 = 1073741824;
pub const Py_TPFLAGS_TYPE_SUBCLASS: u32 = 2147483648;
pub const Py_TPFLAGS_DEFAULT: u32 = 262144;
pub const Py_TPFLAGS_HAVE_FINALIZE: u32 = 1;
pub const Py_LT: u32 = 0;
pub const Py_LE: u32 = 1;
pub const Py_EQ: u32 = 2;
pub const Py_NE: u32 = 3;
pub const Py_GT: u32 = 4;
pub const Py_GE: u32 = 5;
pub const PyBUF_MAX_NDIM: u32 = 64;
pub const PyBUF_SIMPLE: u32 = 0;
pub const PyBUF_WRITABLE: u32 = 1;
pub const PyBUF_WRITEABLE: u32 = 1;
pub const PyBUF_FORMAT: u32 = 4;
pub const PyBUF_ND: u32 = 8;
pub const PyBUF_STRIDES: u32 = 24;
pub const PyBUF_C_CONTIGUOUS: u32 = 56;
pub const PyBUF_F_CONTIGUOUS: u32 = 88;
pub const PyBUF_ANY_CONTIGUOUS: u32 = 152;
pub const PyBUF_INDIRECT: u32 = 280;
pub const PyBUF_CONTIG: u32 = 9;
pub const PyBUF_CONTIG_RO: u32 = 8;
pub const PyBUF_STRIDED: u32 = 25;
pub const PyBUF_STRIDED_RO: u32 = 24;
pub const PyBUF_RECORDS: u32 = 29;
pub const PyBUF_RECORDS_RO: u32 = 28;
pub const PyBUF_FULL: u32 = 285;
pub const PyBUF_FULL_RO: u32 = 284;
pub const PyBUF_READ: u32 = 256;
pub const PyBUF_WRITE: u32 = 512;
pub const PyTrash_UNWIND_LEVEL: u32 = 50;
pub const Py_bf_getbuffer: u32 = 1;
pub const Py_bf_releasebuffer: u32 = 2;
pub const Py_mp_ass_subscript: u32 = 3;
pub const Py_mp_length: u32 = 4;
pub const Py_mp_subscript: u32 = 5;
pub const Py_nb_absolute: u32 = 6;
pub const Py_nb_add: u32 = 7;
pub const Py_nb_and: u32 = 8;
pub const Py_nb_bool: u32 = 9;
pub const Py_nb_divmod: u32 = 10;
pub const Py_nb_float: u32 = 11;
pub const Py_nb_floor_divide: u32 = 12;
pub const Py_nb_index: u32 = 13;
pub const Py_nb_inplace_add: u32 = 14;
pub const Py_nb_inplace_and: u32 = 15;
pub const Py_nb_inplace_floor_divide: u32 = 16;
pub const Py_nb_inplace_lshift: u32 = 17;
pub const Py_nb_inplace_multiply: u32 = 18;
pub const Py_nb_inplace_or: u32 = 19;
pub const Py_nb_inplace_power: u32 = 20;
pub const Py_nb_inplace_remainder: u32 = 21;
pub const Py_nb_inplace_rshift: u32 = 22;
pub const Py_nb_inplace_subtract: u32 = 23;
pub const Py_nb_inplace_true_divide: u32 = 24;
pub const Py_nb_inplace_xor: u32 = 25;
pub const Py_nb_int: u32 = 26;
pub const Py_nb_invert: u32 = 27;
pub const Py_nb_lshift: u32 = 28;
pub const Py_nb_multiply: u32 = 29;
pub const Py_nb_negative: u32 = 30;
pub const Py_nb_or: u32 = 31;
pub const Py_nb_positive: u32 = 32;
pub const Py_nb_power: u32 = 33;
pub const Py_nb_remainder: u32 = 34;
pub const Py_nb_rshift: u32 = 35;
pub const Py_nb_subtract: u32 = 36;
pub const Py_nb_true_divide: u32 = 37;
pub const Py_nb_xor: u32 = 38;
pub const Py_sq_ass_item: u32 = 39;
pub const Py_sq_concat: u32 = 40;
pub const Py_sq_contains: u32 = 41;
pub const Py_sq_inplace_concat: u32 = 42;
pub const Py_sq_inplace_repeat: u32 = 43;
pub const Py_sq_item: u32 = 44;
pub const Py_sq_length: u32 = 45;
pub const Py_sq_repeat: u32 = 46;
pub const Py_tp_alloc: u32 = 47;
pub const Py_tp_base: u32 = 48;
pub const Py_tp_bases: u32 = 49;
pub const Py_tp_call: u32 = 50;
pub const Py_tp_clear: u32 = 51;
pub const Py_tp_dealloc: u32 = 52;
pub const Py_tp_del: u32 = 53;
pub const Py_tp_descr_get: u32 = 54;
pub const Py_tp_descr_set: u32 = 55;
pub const Py_tp_doc: u32 = 56;
pub const Py_tp_getattr: u32 = 57;
pub const Py_tp_getattro: u32 = 58;
pub const Py_tp_hash: u32 = 59;
pub const Py_tp_init: u32 = 60;
pub const Py_tp_is_gc: u32 = 61;
pub const Py_tp_iter: u32 = 62;
pub const Py_tp_iternext: u32 = 63;
pub const Py_tp_methods: u32 = 64;
pub const Py_tp_new: u32 = 65;
pub const Py_tp_repr: u32 = 66;
pub const Py_tp_richcompare: u32 = 67;
pub const Py_tp_setattr: u32 = 68;
pub const Py_tp_setattro: u32 = 69;
pub const Py_tp_str: u32 = 70;
pub const Py_tp_traverse: u32 = 71;
pub const Py_tp_members: u32 = 72;
pub const Py_tp_getset: u32 = 73;
pub const Py_tp_free: u32 = 74;
pub const Py_nb_matrix_multiply: u32 = 75;
pub const Py_nb_inplace_matrix_multiply: u32 = 76;
pub const Py_am_await: u32 = 77;
pub const Py_am_aiter: u32 = 78;
pub const Py_am_anext: u32 = 79;
pub const Py_tp_finalize: u32 = 80;
pub const _PyHASH_MULTIPLIER: u32 = 1000003;
pub const _PyHASH_BITS: u32 = 61;
pub const _PyHASH_INF: u32 = 314159;
pub const _PyHASH_NAN: u32 = 0;
pub const _PyHASH_IMAG: u32 = 1000003;
pub const Py_HASH_CUTOFF: u32 = 0;
pub const Py_HASH_EXTERNAL: u32 = 0;
pub const Py_HASH_SIPHASH24: u32 = 1;
pub const Py_HASH_FNV: u32 = 2;
pub const Py_HASH_ALGORITHM: u32 = 1;
pub const F_LJUST: u32 = 1;
pub const F_SIGN: u32 = 2;
pub const F_BLANK: u32 = 4;
pub const F_ALT: u32 = 8;
pub const F_ZERO: u32 = 16;
pub const _CTYPE_H: u32 = 1;
pub const Py_UNICODE_SIZE: u32 = 4;
pub const _WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const SSTATE_NOT_INTERNED: u32 = 0;
pub const SSTATE_INTERNED_MORTAL: u32 = 1;
pub const SSTATE_INTERNED_IMMORTAL: u32 = 2;
pub const _Py_PARSE_PID: &[u8; 2] = b"i\0";
pub const _Py_PARSE_INTPTR: &[u8; 2] = b"l\0";
pub const _Py_PARSE_UINTPTR: &[u8; 2] = b"k\0";
pub const PyLong_SHIFT: u32 = 30;
pub const _PyLong_DECIMAL_SHIFT: u32 = 9;
pub const _Py_MANAGED_BUFFER_RELEASED: u32 = 1;
pub const _Py_MANAGED_BUFFER_FREE_FORMAT: u32 = 2;
pub const _Py_MEMORYVIEW_RELEASED: u32 = 1;
pub const _Py_MEMORYVIEW_C: u32 = 2;
pub const _Py_MEMORYVIEW_FORTRAN: u32 = 4;
pub const _Py_MEMORYVIEW_SCALAR: u32 = 8;
pub const _Py_MEMORYVIEW_PIL: u32 = 16;
pub const PySet_MINSIZE: u32 = 8;
pub const METH_VARARGS: u32 = 1;
pub const METH_KEYWORDS: u32 = 2;
pub const METH_NOARGS: u32 = 4;
pub const METH_O: u32 = 8;
pub const METH_CLASS: u32 = 16;
pub const METH_STATIC: u32 = 32;
pub const METH_COEXIST: u32 = 64;
pub const METH_FASTCALL: u32 = 128;
pub const METH_STACKLESS: u32 = 0;
pub const METH_METHOD: u32 = 512;
pub const Py_mod_create: u32 = 1;
pub const Py_mod_exec: u32 = 2;
pub const _Py_mod_LAST_SLOT: u32 = 2;
pub const PY_STDIOTEXTMODE: &[u8; 2] = b"b\0";
pub const CO_OPTIMIZED: u32 = 1;
pub const CO_NEWLOCALS: u32 = 2;
pub const CO_VARARGS: u32 = 4;
pub const CO_VARKEYWORDS: u32 = 8;
pub const CO_NESTED: u32 = 16;
pub const CO_GENERATOR: u32 = 32;
pub const CO_NOFREE: u32 = 64;
pub const CO_COROUTINE: u32 = 128;
pub const CO_ITERABLE_COROUTINE: u32 = 256;
pub const CO_ASYNC_GENERATOR: u32 = 512;
pub const CO_FUTURE_DIVISION: u32 = 131072;
pub const CO_FUTURE_ABSOLUTE_IMPORT: u32 = 262144;
pub const CO_FUTURE_WITH_STATEMENT: u32 = 524288;
pub const CO_FUTURE_PRINT_FUNCTION: u32 = 1048576;
pub const CO_FUTURE_UNICODE_LITERALS: u32 = 2097152;
pub const CO_FUTURE_BARRY_AS_BDFL: u32 = 4194304;
pub const CO_FUTURE_GENERATOR_STOP: u32 = 8388608;
pub const CO_FUTURE_ANNOTATIONS: u32 = 16777216;
pub const CO_CELL_NOT_AN_ARG: i32 = -1;
pub const CO_MAXBLOCKS: u32 = 20;
pub const MAX_CO_EXTRA_USERS: u32 = 255;
pub const PyTrace_CALL: u32 = 0;
pub const PyTrace_EXCEPTION: u32 = 1;
pub const PyTrace_LINE: u32 = 2;
pub const PyTrace_RETURN: u32 = 3;
pub const PyTrace_C_CALL: u32 = 4;
pub const PyTrace_C_EXCEPTION: u32 = 5;
pub const PyTrace_C_RETURN: u32 = 6;
pub const PyTrace_OPCODE: u32 = 7;
pub const PyWrapperFlag_KEYWORDS: u32 = 1;
pub const WAIT_LOCK: u32 = 1;
pub const NOWAIT_LOCK: u32 = 0;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const Py_CLEANUP_SUPPORTED: u32 = 131072;
pub const PYTHON_API_VERSION: u32 = 1013;
pub const PYTHON_API_STRING: &[u8; 5] = b"1013\0";
pub const PYTHON_ABI_VERSION: u32 = 3;
pub const PYTHON_ABI_STRING: &[u8; 2] = b"3\0";
pub const PyCF_MASK: u32 = 33423360;
pub const PyCF_MASK_OBSOLETE: u32 = 16;
pub const PyCF_SOURCE_IS_UTF8: u32 = 256;
pub const PyCF_DONT_IMPLY_DEDENT: u32 = 512;
pub const PyCF_ONLY_AST: u32 = 1024;
pub const PyCF_IGNORE_COOKIE: u32 = 2048;
pub const PyCF_TYPE_COMMENTS: u32 = 4096;
pub const PyCF_ALLOW_TOP_LEVEL_AWAIT: u32 = 8192;
pub const PyCF_COMPILE_MASK: u32 = 13824;
pub const FUTURE_NESTED_SCOPES: &[u8; 14] = b"nested_scopes\0";
pub const FUTURE_GENERATORS: &[u8; 11] = b"generators\0";
pub const FUTURE_DIVISION: &[u8; 9] = b"division\0";
pub const FUTURE_ABSOLUTE_IMPORT: &[u8; 16] = b"absolute_import\0";
pub const FUTURE_WITH_STATEMENT: &[u8; 15] = b"with_statement\0";
pub const FUTURE_PRINT_FUNCTION: &[u8; 15] = b"print_function\0";
pub const FUTURE_UNICODE_LITERALS: &[u8; 17] = b"unicode_literals\0";
pub const FUTURE_BARRY_AS_BDFL: &[u8; 15] = b"barry_as_FLUFL\0";
pub const FUTURE_GENERATOR_STOP: &[u8; 15] = b"generator_stop\0";
pub const FUTURE_ANNOTATIONS: &[u8; 12] = b"annotations\0";
pub const Py_single_input: u32 = 256;
pub const Py_file_input: u32 = 257;
pub const Py_eval_input: u32 = 258;
pub const Py_func_type_input: u32 = 345;
pub const Py_fstring_input: u32 = 800;
pub const PYOS_STACK_MARGIN: u32 = 2048;
pub const FVC_MASK: u32 = 3;
pub const FVC_NONE: u32 = 0;
pub const FVC_STR: u32 = 1;
pub const FVC_REPR: u32 = 2;
pub const FVC_ASCII: u32 = 3;
pub const FVS_MASK: u32 = 4;
pub const FVS_HAVE_SPEC: u32 = 4;
pub const _PY_FASTCALL_SMALL_STACK: u32 = 5;
pub const PY_ITERSEARCH_COUNT: u32 = 1;
pub const PY_ITERSEARCH_INDEX: u32 = 2;
pub const PY_ITERSEARCH_CONTAINS: u32 = 3;
pub const PY_CTF_LOWER: u32 = 1;
pub const PY_CTF_UPPER: u32 = 2;
pub const PY_CTF_ALPHA: u32 = 3;
pub const PY_CTF_DIGIT: u32 = 4;
pub const PY_CTF_ALNUM: u32 = 7;
pub const PY_CTF_SPACE: u32 = 8;
pub const PY_CTF_XDIGIT: u32 = 16;
pub const Py_DTSF_SIGN: u32 = 1;
pub const Py_DTSF_ADD_DOT_0: u32 = 2;
pub const Py_DTSF_ALT: u32 = 4;
pub const Py_DTST_FINITE: u32 = 0;
pub const Py_DTST_INFINITE: u32 = 1;
pub const Py_DTST_NAN: u32 = 2;
pub const Py_TPFLAGS_HAVE_ITER: u32 = 0;
pub const Py_TPFLAGS_HAVE_RICHCOMPARE: u32 = 0;
pub const Py_TPFLAGS_HAVE_CLASS: u32 = 0;
pub const HAVE_VARARG_MACROS: u32 = 1;
pub const HAVE_INTPTR_T: u32 = 1;
pub const HAVE_UINTPTR_T: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const HAVE_AF_UNIX: u32 = 1;
pub const HAVE_SYSV_IPC_SUPPORT: u32 = 1;
pub const HAVE_FCNTL: u32 = 1;
pub const HAVE_GETRUSAGE: u32 = 1;
pub const HAVE_GETTIMEOFDAY: u32 = 1;
pub const HAVE_INET_NTOA: u32 = 1;
pub const HAVE_INET_NTOP: u32 = 1;
pub const HAVE_STRTOK_R: u32 = 1;
pub const HAVE_USLEEP: u32 = 1;
pub const HAVE_ARPA_INET_H: u32 = 1;
pub const HAVE_ELF_H: u32 = 1;
pub const HAVE_NETDB_H: u32 = 1;
pub const HAVE_NETINET_IF_ETHER_H: u32 = 1;
pub const HAVE_NETINET_IN_H: u32 = 1;
pub const HAVE_NETINET_IN_SYSTM_H: u32 = 1;
pub const HAVE_NETINET_IP_H: u32 = 1;
pub const HAVE_NETINET_IP_ICMP_H: u32 = 1;
pub const HAVE_NETINET_TCP_H: u32 = 1;
pub const HAVE_NETINET_UDP_H: u32 = 1;
pub const HAVE_PWD_H: u32 = 1;
pub const HAVE_SEMAPHORE_H: u32 = 1;
pub const HAVE_SYS_FCNTL_H: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_SEM_H: u32 = 1;
pub const HAVE_SYS_SHM_H: u32 = 1;
pub const HAVE_SYSLOG_H: u32 = 1;
pub const HAVE_UCONTEXT_H: u32 = 1;
pub const HAVE_ISINF: u32 = 1;
pub const HAVE_LIBXPM: u32 = 1;
pub const HAVE_NET_ETHERNET_H: u32 = 1;
pub const HAVE_NETINET_ETHER_H: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const SO_SFX: &[u8; 3] = b"so\0";
pub const USE_BINFMT_ELF: u32 = 1;
pub const HAVE_SYS_VFS_H: u32 = 1;
pub const HAVE_THREAD_LOCAL_STORAGE: u32 = 1;
pub const SIMICS_HOST_TYPE: &[u8; 8] = b"linux64\0";
pub const HOST_CACHE_LINE_SIZE: u32 = 64;
pub const DIR_SEP: &[u8; 2] = b"/\0";
pub const DIR_SEP_CHAR: u8 = 47u8;
pub const PATH_SEP: &[u8; 2] = b":\0";
pub const PATH_SEP_CHAR: u8 = 58u8;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const HAVE_INT8: u32 = 1;
pub const HAVE_UINT8: u32 = 1;
pub const HAVE_INT16: u32 = 1;
pub const HAVE_UINT16: u32 = 1;
pub const HAVE_INT32: u32 = 1;
pub const HAVE_UINT32: u32 = 1;
pub const HAVE_UINT64: u32 = 1;
pub const HAVE_INT64: u32 = 1;
pub const VECT_COVERITY: u32 = 0;
pub const VECT_INITIAL_SIZE: u32 = 64;
pub const VECT_DEBUG: u32 = 0;
pub const FRONTEND_SERVER_INTERFACE: &[u8; 16] = b"frontend_server\0";
pub const TCF_CHANNEL_INTERFACE: &[u8; 12] = b"tcf_channel\0";
pub const BRANCH_RECORDER_HANDLER_INTERFACE: &[u8; 24] = b"branch_recorder_handler\0";
pub const BREAKPOINT_HANDLE_INVALID: u32 = 0;
pub const CMD_LINE_FRONTEND_INTERFACE: &[u8; 18] = b"cmd_line_frontend\0";
pub const CMD_LINE_SELECTION_INTERFACE: &[u8; 19] = b"cmd_line_selection\0";
pub const TERMINAL_SERVER_INTERFACE: &[u8; 16] = b"terminal_server\0";
pub const TERMINAL_CLIENT_INTERFACE: &[u8; 16] = b"terminal_client\0";
pub const TELEMETRY_MANAGER_INTERFACE: &[u8; 18] = b"telemetry_manager\0";
pub const SIM_VERSION: u32 = 6231;
pub const SIM_VERSION_COMPAT: u32 = 5000;
pub const BUILD_ID_SIM_7: u32 = 7000;
pub const BUILD_ID_SIM_6: u32 = 6000;
pub const BUILD_ID_SIM_5: u32 = 5000;
pub const BUILD_ID_SIM_4_8: u32 = 4500;
pub const SIM_VERSION_7: u32 = 7000;
pub const SIM_VERSION_6: u32 = 6000;
pub const SIM_VERSION_5: u32 = 5000;
pub const SIM_VERSION_4_8: u32 = 4500;
pub const SIM_MAJOR_VERSION_DIFF: u32 = 1000;
pub const HOST_ALLOWS_UNALIGNED_ACCESSES: u32 = 1;
pub const MAX_FRAGS_FRAGS: u32 = 8;
pub const DURATION_SCALE: u64 = 1000000000000;
pub const HAVE_NATIVE_INT128: u32 = 1;
pub const INT128_STR_MAX_SIZE: u32 = 35;
pub const BIGTIME_ATTRTYPE: &[u8; 7] = b"[ii]|n\0";
pub const BIGTIME_STR_MAX_SIZE: u32 = 72;
pub const LOCAL_TIME_ATTRTYPE: &[u8; 10] = b"[o[ii]|n]\0";
pub const LOCAL_TIME_STR_MAX_SIZE: u32 = 72;
pub const CYCLE_INTERFACE: &[u8; 6] = b"cycle\0";
pub const MIN_LOG_LEVEL: u32 = 1;
pub const MAX_LOG_LEVEL: u32 = 4;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _NET_IF_H: u32 = 1;
pub const IF_NAMESIZE: u32 = 16;
pub const IFHWADDRLEN: u32 = 6;
pub const IFNAMSIZ: u32 = 16;
pub const __NETINET_IF_ETHER_H: u32 = 1;
pub const ETH_ALEN: u32 = 6;
pub const ETH_TLEN: u32 = 2;
pub const ETH_HLEN: u32 = 14;
pub const ETH_ZLEN: u32 = 60;
pub const ETH_DATA_LEN: u32 = 1500;
pub const ETH_FRAME_LEN: u32 = 1514;
pub const ETH_FCS_LEN: u32 = 4;
pub const ETH_MIN_MTU: u32 = 68;
pub const ETH_MAX_MTU: u32 = 65535;
pub const ETH_P_LOOP: u32 = 96;
pub const ETH_P_PUP: u32 = 512;
pub const ETH_P_PUPAT: u32 = 513;
pub const ETH_P_TSN: u32 = 8944;
pub const ETH_P_ERSPAN2: u32 = 8939;
pub const ETH_P_IP: u32 = 2048;
pub const ETH_P_X25: u32 = 2053;
pub const ETH_P_ARP: u32 = 2054;
pub const ETH_P_BPQ: u32 = 2303;
pub const ETH_P_IEEEPUP: u32 = 2560;
pub const ETH_P_IEEEPUPAT: u32 = 2561;
pub const ETH_P_BATMAN: u32 = 17157;
pub const ETH_P_DEC: u32 = 24576;
pub const ETH_P_DNA_DL: u32 = 24577;
pub const ETH_P_DNA_RC: u32 = 24578;
pub const ETH_P_DNA_RT: u32 = 24579;
pub const ETH_P_LAT: u32 = 24580;
pub const ETH_P_DIAG: u32 = 24581;
pub const ETH_P_CUST: u32 = 24582;
pub const ETH_P_SCA: u32 = 24583;
pub const ETH_P_TEB: u32 = 25944;
pub const ETH_P_RARP: u32 = 32821;
pub const ETH_P_ATALK: u32 = 32923;
pub const ETH_P_AARP: u32 = 33011;
pub const ETH_P_8021Q: u32 = 33024;
pub const ETH_P_ERSPAN: u32 = 35006;
pub const ETH_P_IPX: u32 = 33079;
pub const ETH_P_IPV6: u32 = 34525;
pub const ETH_P_PAUSE: u32 = 34824;
pub const ETH_P_SLOW: u32 = 34825;
pub const ETH_P_WCCP: u32 = 34878;
pub const ETH_P_MPLS_UC: u32 = 34887;
pub const ETH_P_MPLS_MC: u32 = 34888;
pub const ETH_P_ATMMPOA: u32 = 34892;
pub const ETH_P_PPP_DISC: u32 = 34915;
pub const ETH_P_PPP_SES: u32 = 34916;
pub const ETH_P_LINK_CTL: u32 = 34924;
pub const ETH_P_ATMFATE: u32 = 34948;
pub const ETH_P_PAE: u32 = 34958;
pub const ETH_P_AOE: u32 = 34978;
pub const ETH_P_8021AD: u32 = 34984;
pub const ETH_P_802_EX1: u32 = 34997;
pub const ETH_P_PREAUTH: u32 = 35015;
pub const ETH_P_TIPC: u32 = 35018;
pub const ETH_P_LLDP: u32 = 35020;
pub const ETH_P_MRP: u32 = 35043;
pub const ETH_P_MACSEC: u32 = 35045;
pub const ETH_P_8021AH: u32 = 35047;
pub const ETH_P_MVRP: u32 = 35061;
pub const ETH_P_1588: u32 = 35063;
pub const ETH_P_NCSI: u32 = 35064;
pub const ETH_P_PRP: u32 = 35067;
pub const ETH_P_CFM: u32 = 35074;
pub const ETH_P_FCOE: u32 = 35078;
pub const ETH_P_IBOE: u32 = 35093;
pub const ETH_P_TDLS: u32 = 35085;
pub const ETH_P_FIP: u32 = 35092;
pub const ETH_P_80221: u32 = 35095;
pub const ETH_P_HSR: u32 = 35119;
pub const ETH_P_NSH: u32 = 35151;
pub const ETH_P_LOOPBACK: u32 = 36864;
pub const ETH_P_QINQ1: u32 = 37120;
pub const ETH_P_QINQ2: u32 = 37376;
pub const ETH_P_QINQ3: u32 = 37632;
pub const ETH_P_EDSA: u32 = 56026;
pub const ETH_P_DSA_8021Q: u32 = 56027;
pub const ETH_P_IFE: u32 = 60734;
pub const ETH_P_AF_IUCV: u32 = 64507;
pub const ETH_P_802_3_MIN: u32 = 1536;
pub const ETH_P_802_3: u32 = 1;
pub const ETH_P_AX25: u32 = 2;
pub const ETH_P_ALL: u32 = 3;
pub const ETH_P_802_2: u32 = 4;
pub const ETH_P_SNAP: u32 = 5;
pub const ETH_P_DDCMP: u32 = 6;
pub const ETH_P_WAN_PPP: u32 = 7;
pub const ETH_P_PPP_MP: u32 = 8;
pub const ETH_P_LOCALTALK: u32 = 9;
pub const ETH_P_CAN: u32 = 12;
pub const ETH_P_CANFD: u32 = 13;
pub const ETH_P_PPPTALK: u32 = 16;
pub const ETH_P_TR_802_2: u32 = 17;
pub const ETH_P_MOBITEX: u32 = 21;
pub const ETH_P_CONTROL: u32 = 22;
pub const ETH_P_IRDA: u32 = 23;
pub const ETH_P_ECONET: u32 = 24;
pub const ETH_P_HDLC: u32 = 25;
pub const ETH_P_ARCNET: u32 = 26;
pub const ETH_P_DSA: u32 = 27;
pub const ETH_P_TRAILER: u32 = 28;
pub const ETH_P_PHONET: u32 = 245;
pub const ETH_P_IEEE802154: u32 = 246;
pub const ETH_P_CAIF: u32 = 247;
pub const ETH_P_XDSA: u32 = 248;
pub const ETH_P_MAP: u32 = 249;
pub const ETH_P_MCTP: u32 = 250;
pub const __UAPI_DEF_ETHHDR: u32 = 1;
pub const __NET_ETHERNET_H: u32 = 1;
pub const ETHERTYPE_PUP: u32 = 512;
pub const ETHERTYPE_SPRITE: u32 = 1280;
pub const ETHERTYPE_IP: u32 = 2048;
pub const ETHERTYPE_ARP: u32 = 2054;
pub const ETHERTYPE_REVARP: u32 = 32821;
pub const ETHERTYPE_AT: u32 = 32923;
pub const ETHERTYPE_AARP: u32 = 33011;
pub const ETHERTYPE_VLAN: u32 = 33024;
pub const ETHERTYPE_IPX: u32 = 33079;
pub const ETHERTYPE_IPV6: u32 = 34525;
pub const ETHERTYPE_LOOPBACK: u32 = 36864;
pub const ETHER_ADDR_LEN: u32 = 6;
pub const ETHER_TYPE_LEN: u32 = 2;
pub const ETHER_CRC_LEN: u32 = 4;
pub const ETHER_HDR_LEN: u32 = 14;
pub const ETHER_MIN_LEN: u32 = 64;
pub const ETHER_MAX_LEN: u32 = 1518;
pub const ETHERTYPE_TRAIL: u32 = 4096;
pub const ETHERTYPE_NTRAILER: u32 = 16;
pub const ETHERMTU: u32 = 1500;
pub const ETHERMIN: u32 = 46;
pub const _NET_IF_ARP_H: u32 = 1;
pub const MAX_ADDR_LEN: u32 = 7;
pub const ARPOP_REQUEST: u32 = 1;
pub const ARPOP_REPLY: u32 = 2;
pub const ARPOP_RREQUEST: u32 = 3;
pub const ARPOP_RREPLY: u32 = 4;
pub const ARPOP_InREQUEST: u32 = 8;
pub const ARPOP_InREPLY: u32 = 9;
pub const ARPOP_NAK: u32 = 10;
pub const ARPHRD_NETROM: u32 = 0;
pub const ARPHRD_ETHER: u32 = 1;
pub const ARPHRD_EETHER: u32 = 2;
pub const ARPHRD_AX25: u32 = 3;
pub const ARPHRD_PRONET: u32 = 4;
pub const ARPHRD_CHAOS: u32 = 5;
pub const ARPHRD_IEEE802: u32 = 6;
pub const ARPHRD_ARCNET: u32 = 7;
pub const ARPHRD_APPLETLK: u32 = 8;
pub const ARPHRD_DLCI: u32 = 15;
pub const ARPHRD_ATM: u32 = 19;
pub const ARPHRD_METRICOM: u32 = 23;
pub const ARPHRD_IEEE1394: u32 = 24;
pub const ARPHRD_EUI64: u32 = 27;
pub const ARPHRD_INFINIBAND: u32 = 32;
pub const ARPHRD_SLIP: u32 = 256;
pub const ARPHRD_CSLIP: u32 = 257;
pub const ARPHRD_SLIP6: u32 = 258;
pub const ARPHRD_CSLIP6: u32 = 259;
pub const ARPHRD_RSRVD: u32 = 260;
pub const ARPHRD_ADAPT: u32 = 264;
pub const ARPHRD_ROSE: u32 = 270;
pub const ARPHRD_X25: u32 = 271;
pub const ARPHRD_HWX25: u32 = 272;
pub const ARPHRD_CAN: u32 = 280;
pub const ARPHRD_MCTP: u32 = 290;
pub const ARPHRD_PPP: u32 = 512;
pub const ARPHRD_CISCO: u32 = 513;
pub const ARPHRD_HDLC: u32 = 513;
pub const ARPHRD_LAPB: u32 = 516;
pub const ARPHRD_DDCMP: u32 = 517;
pub const ARPHRD_RAWHDLC: u32 = 518;
pub const ARPHRD_RAWIP: u32 = 519;
pub const ARPHRD_TUNNEL: u32 = 768;
pub const ARPHRD_TUNNEL6: u32 = 769;
pub const ARPHRD_FRAD: u32 = 770;
pub const ARPHRD_SKIP: u32 = 771;
pub const ARPHRD_LOOPBACK: u32 = 772;
pub const ARPHRD_LOCALTLK: u32 = 773;
pub const ARPHRD_FDDI: u32 = 774;
pub const ARPHRD_BIF: u32 = 775;
pub const ARPHRD_SIT: u32 = 776;
pub const ARPHRD_IPDDP: u32 = 777;
pub const ARPHRD_IPGRE: u32 = 778;
pub const ARPHRD_PIMREG: u32 = 779;
pub const ARPHRD_HIPPI: u32 = 780;
pub const ARPHRD_ASH: u32 = 781;
pub const ARPHRD_ECONET: u32 = 782;
pub const ARPHRD_IRDA: u32 = 783;
pub const ARPHRD_FCPP: u32 = 784;
pub const ARPHRD_FCAL: u32 = 785;
pub const ARPHRD_FCPL: u32 = 786;
pub const ARPHRD_FCFABRIC: u32 = 787;
pub const ARPHRD_IEEE802_TR: u32 = 800;
pub const ARPHRD_IEEE80211: u32 = 801;
pub const ARPHRD_IEEE80211_PRISM: u32 = 802;
pub const ARPHRD_IEEE80211_RADIOTAP: u32 = 803;
pub const ARPHRD_IEEE802154: u32 = 804;
pub const ARPHRD_IEEE802154_PHY: u32 = 805;
pub const ARPHRD_VOID: u32 = 65535;
pub const ARPHRD_NONE: u32 = 65534;
pub const ATF_COM: u32 = 2;
pub const ATF_PERM: u32 = 4;
pub const ATF_PUBL: u32 = 8;
pub const ATF_USETRAILERS: u32 = 16;
pub const ATF_NETMASK: u32 = 32;
pub const ATF_DONTPUB: u32 = 64;
pub const ATF_MAGIC: u32 = 128;
pub const ARPD_UPDATE: u32 = 1;
pub const ARPD_LOOKUP: u32 = 2;
pub const ARPD_FLUSH: u32 = 3;
pub const _DLFCN_H: u32 = 1;
pub const RTLD_LAZY: u32 = 1;
pub const RTLD_NOW: u32 = 2;
pub const RTLD_BINDING_MASK: u32 = 3;
pub const RTLD_NOLOAD: u32 = 4;
pub const RTLD_DEEPBIND: u32 = 8;
pub const RTLD_GLOBAL: u32 = 256;
pub const RTLD_LOCAL: u32 = 0;
pub const RTLD_NODELETE: u32 = 4096;
pub const MAX_ETHER_ADDR_STRLEN: u32 = 18;
pub const MAX_IPV4_ADDR_STRLEN: u32 = 16;
pub const ILLEGAL_IP_ADDRESS: u32 = 4294967295;
pub const OS_DLOPEN_GLOBAL: u32 = 256;
pub const OS_DLOPEN_LOCAL: u32 = 0;
pub const OS_DLOPEN_NOW: u32 = 2;
pub const OS_DLOPEN_LOCAL_SEARCHPATH: u32 = 0;
pub const O_BINARY: u32 = 0;
pub const OS_INVALID_SOCKET: i32 = -1;
pub const VGA_UPDATE_INTERFACE: &[u8; 11] = b"vga_update\0";
pub const GFX_CON_INTERFACE: &[u8; 8] = b"gfx_con\0";
pub const CPU_INSTRUCTION_QUERY_INTERFACE: &[u8; 22] = b"cpu_instruction_query\0";
pub const CPU_MEMORY_QUERY_INTERFACE: &[u8; 17] = b"cpu_memory_query\0";
pub const CPU_EXCEPTION_QUERY_INTERFACE: &[u8; 20] = b"cpu_exception_query\0";
pub const CPU_CACHED_INSTRUCTION_INTERFACE: &[u8; 23] = b"cpu_cached_instruction\0";
pub const CPU_CACHED_INSTRUCTION_ONCE_INTERFACE: &[u8; 28] = b"cpu_cached_instruction_once\0";
pub const CPU_INSTRUCTION_DECODER_INTERFACE: &[u8; 24] = b"cpu_instruction_decoder\0";
pub const CPU_INSTRUMENTATION_SUBSCRIBE_INTERFACE: &[u8; 30] = b"cpu_instrumentation_subscribe\0";
pub const CPU_STREAM_TAG_WIDTH: u32 = 6;
pub const CPU_STREAM_TAG_MASK: u32 = 63;
pub const CPU_CACHED_STREAM_INTERFACE: &[u8; 18] = b"cpu_cached_stream\0";
pub const CPU_INSTRUMENTATION_STREAM_INTERFACE: &[u8; 37] =
    b"cpu_instrumentation_stream_interface\0";
pub const PRE_DECODER_INTERFACE: &[u8; 12] = b"pre_decoder\0";
pub const STEP_EVENT_INSTRUMENTATION_INTERFACE: &[u8; 27] = b"step_event_instrumentation\0";
pub const CYCLE_EVENT_INSTRUMENTATION_INTERFACE: &[u8; 28] = b"cycle_event_instrumentation\0";
pub const IMAGE_INTERFACE: &[u8; 6] = b"image\0";
pub const LINEAR_IMAGE_INTERFACE: &[u8; 13] = b"linear_image\0";
pub const IMAGE_SNOOP_INTERFACE: &[u8; 12] = b"image_snoop\0";
pub const POOL_PROTECT_INTERFACE: &[u8; 13] = b"pool_protect\0";
pub const MOUSE_LEFT_DOWN: u32 = 1;
pub const MOUSE_RIGHT_DOWN: u32 = 2;
pub const MOUSE_MIDDLE_DOWN: u32 = 4;
pub const MOUSE_4_DOWN: u32 = 8;
pub const MOUSE_5_DOWN: u32 = 16;
pub const KBD_CAPSLOCK_ON: u32 = 0;
pub const KBD_CAPSLOCK_OFF: u32 = 1;
pub const KBD_NUMLOCK_ON: u32 = 2;
pub const KBD_NUMLOCK_OFF: u32 = 3;
pub const KBD_SCROLLLOCK_ON: u32 = 4;
pub const KBD_SCROLLLOCK_OFF: u32 = 5;
pub const COMPONENT_INTERFACE: &[u8; 10] = b"component\0";
pub const CONNECTOR_INTERFACE: &[u8; 10] = b"connector\0";
pub const COMPONENT_CONNECTOR_INTERFACE: &[u8; 20] = b"component_connector\0";
pub const DISK_COMPONENT_INTERFACE: &[u8; 15] = b"disk_component\0";
pub const EXEC_TRACE_INTERFACE: &[u8; 11] = b"exec_trace\0";
pub const CONCURRENCY_MODE_INTERFACE: &[u8; 17] = b"concurrency_mode\0";
pub const CONCURRENCY_GROUP_INTERFACE: &[u8; 18] = b"concurrency_group\0";
pub const INSTRUCTION_FETCH_INTERFACE: &[u8; 18] = b"instruction_fetch\0";
pub const STEP_INTERFACE: &[u8; 5] = b"step\0";
pub const STEP_CYCLE_RATIO_INTERFACE: &[u8; 17] = b"step_cycle_ratio\0";
pub const STALL_INTERFACE: &[u8; 6] = b"stall\0";
pub const STEP_INFO_INTERFACE: &[u8; 10] = b"step_info\0";
pub const MMC_INTERFACE: &[u8; 4] = b"mmc\0";
pub const CPU_GROUP_INTERFACE: &[u8; 10] = b"cpu_group\0";
pub const JIT_CONTROL_INTERFACE: &[u8; 12] = b"jit_control\0";
pub const REGISTER_VIEW_INTERFACE: &[u8; 14] = b"register_view\0";
pub const FREERUN_INTERFACE: &[u8; 8] = b"freerun\0";
pub const PROCESSOR_INFO_INTERFACE: &[u8; 15] = b"processor_info\0";
pub const PROCESSOR_INFO_V2_INTERFACE: &[u8; 18] = b"processor_info_v2\0";
pub const PROCESSOR_ENDIAN_INTERFACE: &[u8; 17] = b"processor_endian\0";
pub const PROCESSOR_CLI_INTERFACE: &[u8; 14] = b"processor_cli\0";
pub const OPCODE_INFO_INTERFACE: &[u8; 12] = b"opcode_info\0";
pub const PROCESSOR_GUI_INTERFACE: &[u8; 14] = b"processor_gui\0";
pub const EXCEPTION_INTERFACE: &[u8; 10] = b"exception\0";
pub const INSTRUMENTATION_ORDER_INTERFACE: &[u8; 22] = b"instrumentation_order\0";
pub const CALLBACK_INFO_INTERFACE: &[u8; 14] = b"callback_info\0";
pub const VGA_TEXT_INTERFACE: &[u8; 9] = b"vga_text\0";
pub const VGA_TEXT_INFO_INTERFACE: &[u8; 14] = b"vga_text_info\0";
pub const VGA_TEXT_UPDATE_INTERFACE: &[u8; 16] = b"vga_text_update\0";
pub const DATA_PROFILER_INTERFACE: &[u8; 14] = b"data_profiler\0";
pub const REGISTER_VIEW_READ_ONLY_INTERFACE: &[u8; 24] = b"register_view_read_only\0";
pub const DECODER_INTERFACE: &[u8; 8] = b"decoder\0";
pub const UD_IT_SEQUENTIAL: u32 = 1;
pub const UD_IT_CONTROL_FLOW: u32 = 2;
pub const ATTRIBUTE_MONITOR_INTERFACE: &[u8; 18] = b"attribute_monitor\0";
pub const CONTEXT_HANDLER_INTERFACE: &[u8; 16] = b"context_handler\0";
pub const TAG_GRANULARITY: u32 = 4;
pub const TAG_BYTE_PACKING: u32 = 3;
pub const BREAKPOINT_INTERFACE: &[u8; 11] = b"breakpoint\0";
pub const BREAKPOINT_CHANGE_INTERFACE: &[u8; 18] = b"breakpoint_change\0";
pub const BREAKPOINT_QUERY_INTERFACE: &[u8; 17] = b"breakpoint_query\0";
pub const BREAKPOINT_QUERY_V2_INTERFACE: &[u8; 20] = b"breakpoint_query_v2\0";
pub const BREAKPOINT_TRIGGER_INTERFACE: &[u8; 19] = b"breakpoint_trigger\0";
pub const VIRTUAL_DATA_BREAKPOINT_INTERFACE: &[u8; 24] = b"virtual_data_breakpoint\0";
pub const VIRTUAL_INSTRUCTION_BREAKPOINT_INTERFACE: &[u8; 31] = b"virtual_instruction_breakpoint\0";
pub const DESCRIBE_REGISTERS_INTERFACE: &[u8; 19] = b"describe_registers\0";
pub const TRANSACTION_INTERFACE: &[u8; 12] = b"transaction\0";
pub const CDROM_MEDIA_INTERFACE: &[u8; 12] = b"cdrom_media\0";
pub const MEMORY_PROFILER_INTERFACE: &[u8; 16] = b"memory_profiler\0";
pub const CO_EXECUTE_INTERFACE: &[u8; 11] = b"co_execute\0";
pub const SYNCHRONOUS_MODE_INTERFACE: &[u8; 17] = b"synchronous_mode\0";
pub const BANK_BEFORE_READ_INTERFACE: &[u8; 17] = b"bank_before_read\0";
pub const BANK_AFTER_READ_INTERFACE: &[u8; 16] = b"bank_after_read\0";
pub const BANK_BEFORE_WRITE_INTERFACE: &[u8; 18] = b"bank_before_write\0";
pub const BANK_AFTER_WRITE_INTERFACE: &[u8; 17] = b"bank_after_write\0";
pub const BANK_INSTRUMENTATION_SUBSCRIBE_INTERFACE: &[u8; 31] = b"bank_instrumentation_subscribe\0";
pub const CYCLE_EVENT_INTERFACE: &[u8; 12] = b"cycle_event\0";
pub const CYCLE_CONTROL_INTERFACE: &[u8; 14] = b"cycle_control\0";
pub const TEMPORAL_STATE_INTERFACE: &[u8; 15] = b"temporal_state\0";
pub const EVENT_DELTA_INTERFACE: &[u8; 12] = b"event_delta\0";
pub const EVENT_HANDLER_INTERFACE: &[u8; 14] = b"event_handler\0";
pub const GBP_MAGIC: u32 = 3772834016;
pub const GBP_FMT_VGA_4: u32 = 1;
pub const GBP_FMT_V3_8: u32 = 8;
pub const GBP_FMT_V3_16: u32 = 16;
pub const GBP_FMT_V3_24: u32 = 24;
pub const GBP_FMT_V3_32: u32 = 32;
pub const GBP_COMMENT_OFFS: u32 = 0;
pub const GBP_MAGIC_OFFS: u32 = 32;
pub const GBP_FORMAT_OFFS: u32 = 36;
pub const GBP_BYTES_OFFS: u32 = 40;
pub const GBP_MINX_OFFS: u32 = 44;
pub const GBP_MINY_OFFS: u32 = 48;
pub const GBP_MAXX_OFFS: u32 = 52;
pub const GBP_MAXY_OFFS: u32 = 56;
pub const GBP_HEADER_SIZE: u32 = 60;
pub const VIDEO_INTERFACE: &[u8; 6] = b"video\0";
pub const DIRECT_MEMORY_INTERFACE: &[u8; 14] = b"direct_memory\0";
pub const DIRECT_MEMORY_LOOKUP_INTERFACE: &[u8; 21] = b"direct_memory_lookup\0";
pub const DIRECT_MEMORY_LOOKUP_V2_INTERFACE: &[u8; 24] = b"direct_memory_lookup_v2\0";
pub const DIRECT_MEMORY_UPDATE_INTERFACE: &[u8; 21] = b"direct_memory_update\0";
pub const DIRECT_MEMORY_FLUSH_INTERFACE: &[u8; 20] = b"direct_memory_flush\0";
pub const DIRECT_MEMORY_TAGS_INTERFACE: &[u8; 19] = b"direct_memory_tags\0";
pub const DUMMY_MEMORY_PAGE_INTERFACE: &[u8; 18] = b"dummy_memory_page\0";
pub const SAVE_STATE_INTERFACE: &[u8; 11] = b"save_state\0";
pub const SIMULATOR_CACHE_INTERFACE: &[u8; 16] = b"simulator_cache\0";
pub const PACKET_INTERFACE: &[u8; 7] = b"packet\0";
pub const DEVICE_IDENTIFICATION_INTERFACE: &[u8; 22] = b"device_identification\0";
pub const EXECUTE_INTERFACE: &[u8; 8] = b"execute\0";
pub const CELL_INSPECTION_INTERFACE: &[u8; 16] = b"cell_inspection\0";
pub const EXECUTE_CONTROL_INTERFACE: &[u8; 16] = b"execute_control\0";
pub const HAP_LISTEN_INTERFACE: &[u8; 11] = b"hap_listen\0";
pub const CACHE_CONTROL_INTERFACE: &[u8; 14] = b"cache_control\0";
pub const TIMING_MODEL_INTERFACE: &[u8; 13] = b"timing_model\0";
pub const SNOOP_MEMORY_INTERFACE: &[u8; 13] = b"snoop_memory\0";
pub const UINT64_STATE_INTERFACE: &[u8; 13] = b"uint64_state\0";
pub const ABS_POINTER_INTERFACE: &[u8; 12] = b"abs_pointer\0";
pub const ABS_POINTER_ACTIVATE_INTERFACE: &[u8; 21] = b"abs_pointer_activate\0";
pub const INT_REGISTER_INTERFACE: &[u8; 13] = b"int_register\0";
pub const EXTERNAL_CONNECTION_CTL_INTERFACE: &[u8; 24] = b"external_connection_ctl\0";
pub const EXTERNAL_CONNECTION_EVENTS_INTERFACE: &[u8; 27] = b"external_connection_events\0";
pub const TCP_CONNECTION_INFO_INTERFACE: &[u8; 20] = b"tcp_connection_info\0";
pub const RAM_INTERFACE: &[u8; 4] = b"ram\0";
pub const ROM_INTERFACE: &[u8; 4] = b"rom\0";
pub const RAM_ACCESS_SUBSCRIBE_INTERFACE: &[u8; 21] = b"ram_access_subscribe\0";
pub const KEYBOARD_INTERFACE: &[u8; 9] = b"keyboard\0";
pub const KEYBOARD_CONSOLE_INTERFACE: &[u8; 17] = b"keyboard_console\0";
pub const MOUSE_INTERFACE: &[u8; 6] = b"mouse\0";
pub const FREQUENCY_INTERFACE: &[u8; 10] = b"frequency\0";
pub const FREQUENCY_LISTENER_INTERFACE: &[u8; 19] = b"frequency_listener\0";
pub const SCALE_FACTOR_LISTENER_INTERFACE: &[u8; 22] = b"scale_factor_listener\0";
pub const SIMPLE_DISPATCHER_INTERFACE: &[u8; 18] = b"simple_dispatcher\0";
pub const INTERRUPT_ACK_INTERFACE: &[u8; 14] = b"interrupt_ack\0";
pub const INTERRUPT_CPU_INTERFACE: &[u8; 14] = b"interrupt_cpu\0";
pub const IO_MEMORY_INTERFACE: &[u8; 10] = b"io_memory\0";
pub const MAP_DEMAP_INTERFACE: &[u8; 10] = b"map_demap\0";
pub const MEMORY_SPACE_INTERFACE: &[u8; 13] = b"memory_space\0";
pub const PORT_SPACE_INTERFACE: &[u8; 11] = b"port_space\0";
pub const TRANSLATE_INTERFACE: &[u8; 10] = b"translate\0";
pub const BRIDGE_INTERFACE: &[u8; 7] = b"bridge\0";
pub const SIGNAL_INTERFACE: &[u8; 7] = b"signal\0";
pub const MULTI_LEVEL_SIGNAL_INTERFACE: &[u8; 19] = b"multi_level_signal\0";
pub const PULSE_INTERFACE: &[u8; 6] = b"pulse\0";
pub const MIPS_INTERFACE: &[u8; 5] = b"mips\0";
pub const MIPS_COPROCESSOR_INTERFACE: &[u8; 17] = b"mips_coprocessor\0";
pub const FMN_STATION_CONTROL_INTERFACE: &[u8; 20] = b"fmn_station_control\0";
pub const FMN_STATION_CONTROL_V2_INTERFACE: &[u8; 23] = b"fmn_station_control_v2\0";
pub const MIPS_CACHE_INSTRUCTION_INTERFACE: &[u8; 23] = b"mips_cache_instruction\0";
pub const MIPS_ITE_INTERFACE: &[u8; 9] = b"mips_ite\0";
pub const MIPS_EIC_INTERFACE: &[u8; 9] = b"mips_eic\0";
pub const MIPS_EXCEPTION_QUERY_INTERFACE: &[u8; 21] = b"mips_exception_query\0";
pub const SH_INTERRUPT_INTERFACE: &[u8; 13] = b"sh_interrupt\0";
pub const X86_ACCESS_TYPE_INTERFACE: &[u8; 16] = b"x86_access_type\0";
pub const SIM_DI_PREFIX_F0_BIT: u32 = 1;
pub const SIM_DI_PREFIX_F2_BIT: u32 = 2;
pub const SIM_DI_PREFIX_F3_BIT: u32 = 4;
pub const SIM_DI_PREFIX_CS_BIT: u32 = 8;
pub const SIM_DI_PREFIX_SS_BIT: u32 = 16;
pub const SIM_DI_PREFIX_DS_BIT: u32 = 32;
pub const SIM_DI_PREFIX_ES_BIT: u32 = 64;
pub const SIM_DI_PREFIX_FS_BIT: u32 = 128;
pub const SIM_DI_PREFIX_GS_BIT: u32 = 256;
pub const SIM_DI_PREFIX_OPERAND_SIZE_BIT: u32 = 512;
pub const SIM_DI_PREFIX_66_BIT: u32 = 512;
pub const SIM_DI_PREFIX_ADDRESS_SIZE_BIT: u32 = 1024;
pub const SIM_DI_PREFIX_SSE_BIT: u32 = 2048;
pub const SIM_DI_PREFIX_REX_BIT: u32 = 4096;
pub const SIM_DI_PREFIX_REX_POS: u32 = 16;
pub const SIM_DI_PREFIX_REX_POS_B: u32 = 16;
pub const SIM_DI_PREFIX_REX_POS_X: u32 = 17;
pub const SIM_DI_PREFIX_REX_POS_R: u32 = 18;
pub const SIM_DI_PREFIX_REX_POS_W: u32 = 19;
pub const X86_TLB_INTERFACE: &[u8; 8] = b"x86_tlb\0";
pub const X86_TLB_PTE_WRITE: u32 = 2;
pub const X86_TLB_PTE_USER: u32 = 4;
pub const X86_TLB_PTE_DIRTY: u32 = 64;
pub const X86_TLB_PTE_GLOBAL: u32 = 256;
pub const X86_TLB_PTE_PAGE_MASK: u32 = 326;
pub const X86_TLB_PTE_USER_SHIFT: u32 = 9;
pub const X86_TLB_PTE_USER_READ: u32 = 512;
pub const X86_TLB_PTE_USER_WRITE: u32 = 1024;
pub const X86_TLB_PTE_USER_EXECUTE: u32 = 2048;
pub const X86_TLB_PTE_USER_MASK: u32 = 3584;
pub const X86_TLB_PTE_SVISOR_SHIFT: u32 = 60;
pub const X86_TLB_PTE_SVISOR_READ: u64 = 1152921504606846976;
pub const X86_TLB_PTE_SVISOR_WRITE: u64 = 2305843009213693952;
pub const X86_TLB_PTE_SVISOR_EXECUTE: u64 = 4611686018427387904;
pub const X86_TLB_PTE_SVISOR_MASK: u64 = 8070450532247928832;
pub const X86_TLB_PTE_MASK: u64 = 8070450532247932416;
pub const X86_TLB_V3_INTERFACE: &[u8; 11] = b"x86_tlb_v3\0";
pub const X86_TLB_V2_INTERFACE: &[u8; 11] = b"x86_tlb_v2\0";
pub const X86_INTERFACE: &[u8; 4] = b"x86\0";
pub const X86_CPUID_INTERFACE: &[u8; 10] = b"x86_cpuid\0";
pub const X86_CPUID_QUERY_INTERFACE: &[u8; 16] = b"x86_cpuid_query\0";
pub const APIC_CPU_INTERFACE: &[u8; 9] = b"apic_cpu\0";
pub const A20_INTERFACE: &[u8; 4] = b"a20\0";
pub const X86_MSR_INTERFACE: &[u8; 8] = b"x86_msr\0";
pub const X86_CACHE_FLUSH_INTERFACE: &[u8; 16] = b"x86_cache_flush\0";
pub const X86_SMM_STATE_INTERFACE: &[u8; 14] = b"x86_smm_state\0";
pub const X86_SMM_INTERFACE: &[u8; 8] = b"x86_smm\0";
pub const X86_REG_ACCESS_INTERFACE: &[u8; 15] = b"x86_reg_access\0";
pub const X86_EXCEPTION_INTERFACE: &[u8; 14] = b"x86_exception\0";
pub const X86_MEMORY_ACCESS_INTERFACE: &[u8; 18] = b"x86_memory_access\0";
pub const X86_MEMORY_OPERATION_INTERFACE: &[u8; 21] = b"x86_memory_operation\0";
pub const X86_VMP_CONTROL_INTERFACE: &[u8; 16] = b"x86_vmp_control\0";
pub const VMP_INTERFACE: &[u8; 4] = b"vmp\0";
pub const XED_ACCESS_INTERFACE: &[u8; 11] = b"xed_access\0";
pub const X86_EPT_INTERFACE: &[u8; 8] = b"x86_ept\0";
pub const PPC_INTERFACE: &[u8; 4] = b"ppc\0";
pub const SPR_INTERFACE: &[u8; 4] = b"spr\0";
pub const PMR_INTERFACE: &[u8; 4] = b"pmr\0";
pub const RISCV_COPROCESSOR_INTERFACE: &[u8; 18] = b"riscv_coprocessor\0";
pub const RISCV_CLIC_INTERRUPT_INTERFACE: &[u8; 21] = b"riscv_clic_interrupt\0";
pub const RISCV_CLIC_INTERFACE: &[u8; 11] = b"riscv_clic\0";
pub const X86_INSTRUCTION_QUERY_INTERFACE: &[u8; 22] = b"x86_instruction_query\0";
pub const X86_MEMORY_QUERY_INTERFACE: &[u8; 17] = b"x86_memory_query\0";
pub const X86_EXCEPTION_QUERY_INTERFACE: &[u8; 20] = b"x86_exception_query\0";
pub const X86_ADDRESS_QUERY_INTERFACE: &[u8; 18] = b"x86_address_query\0";
pub const X86_INSTRUMENTATION_SUBSCRIBE_INTERFACE: &[u8; 30] = b"x86_instrumentation_subscribe\0";
pub const X86_INSTRUMENTATION_SUBSCRIBE_V2_INTERFACE: &[u8; 33] =
    b"x86_instrumentation_subscribe_v2\0";
pub const VMX_INSTRUMENTATION_SUBSCRIBE_INTERFACE: &[u8; 30] = b"vmx_instrumentation_subscribe\0";
pub const SMM_INSTRUMENTATION_SUBSCRIBE_INTERFACE: &[u8; 30] = b"smm_instrumentation_subscribe\0";
pub const ARM_INTERFACE: &[u8; 4] = b"arm\0";
pub const ARM_INT_IRQ: u32 = 0;
pub const ARM_INT_FIQ: u32 = 1;
pub const ARM_INT_VIRQ: u32 = 2;
pub const ARM_INT_VFIQ: u32 = 3;
pub const ARM_INT_SEI: u32 = 4;
pub const ARM_INT_REI: u32 = 5;
pub const ARM_INT_VSEI: u32 = 6;
pub const ARM_INT_NMI: u32 = 512;
pub const ARM_INT_SYSTICK: u32 = 513;
pub const ARM_COPROCESSOR_INTERFACE: &[u8; 16] = b"arm_coprocessor\0";
pub const ARM_AVIC_INTERFACE: &[u8; 9] = b"arm_avic\0";
pub const ARM_TRUSTZONE_INTERFACE: &[u8; 14] = b"arm_trustzone\0";
pub const ARM_EXTERNAL_DEBUG_INTERFACE: &[u8; 19] = b"arm_external_debug\0";
pub const ARM_GIC_INTERFACE: &[u8; 8] = b"arm_gic\0";
pub const ARM_GIC_CPU_STATE_INTERFACE: &[u8; 18] = b"arm_gic_cpu_state\0";
pub const ARM_CPU_GROUP_EXCLUSIVE_INTERFACE: &[u8; 24] = b"arm_cpu_group_exclusive\0";
pub const ARM_CPU_GROUP_EVENT_INTERFACE: &[u8; 20] = b"arm_cpu_group_event\0";
pub const ARM_CPU_GROUP_TLB_INTERFACE: &[u8; 18] = b"arm_cpu_group_tlb\0";
pub const XTENSA_TIE_LOOKUP_INTERFACE: &[u8; 18] = b"xtensa_tie_lookup\0";
pub const XTENSA_TIE_EXPORT_STATE_INTERFACE: &[u8; 24] = b"xtensa_tie_export_state\0";
pub const XTENSA_TIE_OUTPUT_QUEUE_INTERFACE: &[u8; 24] = b"xtensa_tie_output_queue\0";
pub const XTENSA_TIE_INPUT_QUEUE_INTERFACE: &[u8; 23] = b"xtensa_tie_input_queue\0";
pub const XTENSA_TIE_IMPORT_WIRE_INTERFACE: &[u8; 23] = b"xtensa_tie_import_wire\0";
pub const XTENSA_LOOKUP_INTERFACE: &[u8; 14] = b"xtensa_lookup\0";
pub const XTENSA_EXPORT_STATE_INTERFACE: &[u8; 20] = b"xtensa_export_state\0";
pub const XTENSA_OUTPUT_QUEUE_INTERFACE: &[u8; 20] = b"xtensa_output_queue\0";
pub const XTENSA_INPUT_QUEUE_INTERFACE: &[u8; 19] = b"xtensa_input_queue\0";
pub const XTENSA_IMPORT_WIRE_INTERFACE: &[u8; 19] = b"xtensa_import_wire\0";
pub const NIOS_INTERFACE: &[u8; 5] = b"nios\0";
pub const NIOS_EIC_INTERFACE: &[u8; 9] = b"nios_eic\0";
pub const NIOS_CACHE_INTERFACE: &[u8; 11] = b"nios_cache\0";
pub const NIOS_CUSTOM_INTERFACE: &[u8; 12] = b"nios_custom\0";
pub const SPARC_V8_INTERFACE: &[u8; 9] = b"sparc_v8\0";
pub const SPARC_V8_ECC_FAULT_INJECTION_INTERFACE: &[u8; 29] = b"sparc_v8_ecc_fault_injection\0";
pub const I8051_INTERRUPT_INTERFACE: &[u8; 16] = b"i8051_interrupt\0";
pub const I8051_TIMER_INTERFACE: &[u8; 12] = b"i8051_timer\0";
pub const SERIAL_PERIPHERAL_INTERFACE_MASTER_INTERFACE: &[u8; 35] =
    b"serial_peripheral_interface_master\0";
pub const SERIAL_PERIPHERAL_INTERFACE_SLAVE_INTERFACE: &[u8; 34] =
    b"serial_peripheral_interface_slave\0";
pub const DATAGRAM_LINK_INTERFACE: &[u8; 14] = b"datagram_link\0";
pub const X86_CSTATE_INTERFACE: &[u8; 11] = b"x86_cstate\0";
pub const X86_PKG_CSTATE_INTERFACE: &[u8; 15] = b"x86_pkg_cstate\0";
pub const X86_CSTATE_NOTIFICATION_INTERFACE: &[u8; 24] = b"x86_cstate_notification\0";
pub const X86_CSTATE_CHANGE_NOTIFIER: &[u8; 18] = b"x86-cstate-change\0";
pub const TTY_ABORT: u32 = 256;
pub const SERIAL_DEVICE_INTERFACE: &[u8; 14] = b"serial_device\0";
pub const EXTENDED_SERIAL_INTERFACE: &[u8; 16] = b"extended_serial\0";
pub const RS232_DEVICE_INTERFACE: &[u8; 13] = b"rs232_device\0";
pub const RS232_CONSOLE_INTERFACE: &[u8; 14] = b"rs232_console\0";
pub const TTY_NO_CHAR: u32 = 257;
pub const PCI_DEVICE_INTERFACE: &[u8; 11] = b"pci_device\0";
pub const PCI_BUS_INTERFACE: &[u8; 8] = b"pci_bus\0";
pub const PCI_UPSTREAM_INTERFACE: &[u8; 13] = b"pci_upstream\0";
pub const PCI_UPSTREAM_OPERATION_INTERFACE: &[u8; 23] = b"pci_upstream_operation\0";
pub const PCI_DOWNSTREAM_INTERFACE: &[u8; 15] = b"pci_downstream\0";
pub const PCI_BRIDGE_INTERFACE: &[u8; 11] = b"pci_bridge\0";
pub const PCI_INTERRUPT_INTERFACE: &[u8; 14] = b"pci_interrupt\0";
pub const DEVICE_CONF_FUNC: u32 = 255;
pub const DEVICE_PCIE_CONF_FUNC: u32 = 254;
pub const PCI_EXPRESS_INTERFACE: &[u8; 12] = b"pci_express\0";
pub const PCI_EXPRESS_HOTPLUG_INTERFACE: &[u8; 20] = b"pci_express_hotplug\0";
pub const PCI_MULTI_FUNCTION_DEVICE_INTERFACE: &[u8; 26] = b"pci_multi_function_device\0";
pub const PCIE_DEVICE_INTERFACE: &[u8; 12] = b"pcie_device\0";
pub const PCIE_MAP_INTERFACE: &[u8; 9] = b"pcie_map\0";
pub const PCIE_PORT_CONTROL_INTERFACE: &[u8; 18] = b"pcie_port_control\0";
pub const MII_MANAGEMENT_INTERFACE: &[u8; 15] = b"mii_management\0";
pub const MII_INTERFACE: &[u8; 4] = b"mii\0";
pub const MDIO45_BUS_INTERFACE: &[u8; 11] = b"mdio45_bus\0";
pub const MDIO45_PHY_INTERFACE: &[u8; 11] = b"mdio45_phy\0";
pub const SIMPLE_INTERRUPT_INTERFACE: &[u8; 17] = b"simple_interrupt\0";
pub const INTERRUPT_QUERY_INTERFACE: &[u8; 16] = b"interrupt_query\0";
pub const TELEMETRY_INTERFACE: &[u8; 10] = b"telemetry\0";
pub const APIC_BUS_INTERFACE: &[u8; 9] = b"apic_bus\0";
pub const NAND_FLASH_INTERFACE: &[u8; 11] = b"nand_flash\0";
pub const I3C_MASTER_INTERFACE: &[u8; 11] = b"i3c_master\0";
pub const I3C_SLAVE_INTERFACE: &[u8; 10] = b"i3c_slave\0";
pub const I3C_DAA_SNOOP_INTERFACE: &[u8; 14] = b"i3c_daa_snoop\0";
pub const FIREWIRE_BUS_INTERFACE: &[u8; 13] = b"firewire_bus\0";
pub const FIREWIRE_DEVICE_INTERFACE: &[u8; 16] = b"firewire_device\0";
pub const COREINT_INTERFACE: &[u8; 8] = b"coreint\0";
pub const TRANSLATOR_INTERFACE: &[u8; 11] = b"translator\0";
pub const TRANSACTION_TRANSLATOR_INTERFACE: &[u8; 23] = b"transaction_translator\0";
pub const TRANSLATION_FLUSH_INTERFACE: &[u8; 18] = b"translation_flush\0";
pub const MS1553_LINK_INTERFACE: &[u8; 12] = b"ms1553_link\0";
pub const MS1553_TERMINAL_INTERFACE: &[u8; 16] = b"ms1553_terminal\0";
pub const ARINC429_BUS_INTERFACE: &[u8; 13] = b"arinc429_bus\0";
pub const ARINC429_RECEIVER_INTERFACE: &[u8; 18] = b"arinc429_receiver\0";
pub const INTERRUPT_SUBSCRIBER_INTERFACE: &[u8; 21] = b"interrupt_subscriber\0";
pub const USB_DEVICE_INTERFACE: &[u8; 11] = b"usb_device\0";
pub const USB_INTERFACE: &[u8; 4] = b"usb\0";
pub const RAPIDIO_V3_INTERFACE: &[u8; 11] = b"rapidio_v3\0";
pub const RAPIDIO_V4_INTERFACE: &[u8; 11] = b"rapidio_v4\0";
pub const RAPIDIO_V5_INTERFACE: &[u8; 11] = b"rapidio_v5\0";
pub const ETHERNET_COMMON_INTERFACE: &[u8; 16] = b"ethernet_common\0";
pub const ETHERNET_CABLE_INTERFACE: &[u8; 15] = b"ethernet_cable\0";
pub const ETHERNET_SNOOP_INTERFACE: &[u8; 15] = b"ethernet_snoop\0";
pub const ETHERNET_VLAN_SNOOP_INTERFACE: &[u8; 20] = b"ethernet_vlan_snoop\0";
pub const MICROWIRE_INTERFACE: &[u8; 10] = b"microwire\0";
pub const SATA_INTERFACE: &[u8; 5] = b"sata\0";
pub const ETHERNET_PROBE_INTERFACE: &[u8; 15] = b"ethernet_probe\0";
pub const GBIC_TRANSCEIVER_INTERFACE: &[u8; 17] = b"gbic_transceiver\0";
pub const IEEE_802_3_PHY_INTERFACE: &[u8; 15] = b"ieee_802_3_phy\0";
pub const IEEE_802_3_PHY_V2_INTERFACE: &[u8; 18] = b"ieee_802_3_phy_v2\0";
pub const IEEE_802_3_PHY_V3_INTERFACE: &[u8; 18] = b"ieee_802_3_phy_v3\0";
pub const IEEE_802_3_MAC_INTERFACE: &[u8; 15] = b"ieee_802_3_mac\0";
pub const IEEE_802_3_MAC_V3_INTERFACE: &[u8; 18] = b"ieee_802_3_mac_v3\0";
pub const VECTORED_INTERRUPT_INTERFACE: &[u8; 19] = b"vectored_interrupt\0";
pub const VECTORED_INTERRUPT_SOURCE_INTERFACE: &[u8; 26] = b"vectored_interrupt_source\0";
pub const I2C_BUS_INTERFACE: &[u8; 8] = b"i2c_bus\0";
pub const I2C_DEVICE_INTERFACE: &[u8; 11] = b"i2c_device\0";
pub const I2C_LINK_INTERFACE: &[u8; 9] = b"i2c_link\0";
pub const I2C_SLAVE_INTERFACE: &[u8; 10] = b"i2c_slave\0";
pub const I2C_MASTER_INTERFACE: &[u8; 11] = b"i2c_master\0";
pub const I2C_BRIDGE_INTERFACE: &[u8; 11] = b"i2c_bridge\0";
pub const I2C_SLAVE_V2_INTERFACE: &[u8; 13] = b"i2c_slave_v2\0";
pub const I2C_MASTER_V2_INTERFACE: &[u8; 14] = b"i2c_master_v2\0";
pub const HPI_INTERFACE: &[u8; 4] = b"hpi\0";
pub const OSA_MACHINE_NOTIFICATION_INTERFACE: &[u8; 25] = b"osa_machine_notification\0";
pub const OSA_MACHINE_QUERY_INTERFACE: &[u8; 18] = b"osa_machine_query\0";
pub const OSA_MAPPER_ADMIN_INTERFACE: &[u8; 17] = b"osa_mapper_admin\0";
pub const OSA_MAPPER_CONTROL_INTERFACE: &[u8; 19] = b"osa_mapper_control\0";
pub const OSA_MAPPER_QUERY_INTERFACE: &[u8; 17] = b"osa_mapper_query\0";
pub const OSA_NODE_TREE_ADMIN_INTERFACE: &[u8; 20] = b"osa_node_tree_admin\0";
pub const OSA_PARAMETERS_INTERFACE: &[u8; 15] = b"osa_parameters\0";
pub const OSA_TRACKER_COMPONENT_INTERFACE: &[u8; 22] = b"osa_tracker_component\0";
pub const OSA_TRACKER_STATE_ADMIN_INTERFACE: &[u8; 24] = b"osa_tracker_state_admin\0";
pub const OSA_TRACKER_STATE_NOTIFICATION_INTERFACE: &[u8; 31] = b"osa_tracker_state_notification\0";
pub const OSA_TRACKER_STATE_QUERY_INTERFACE: &[u8; 24] = b"osa_tracker_state_query\0";
pub const OSA_TRACKER_CONTROL_INTERFACE: &[u8; 20] = b"osa_tracker_control\0";
pub const OSA_MICRO_CHECKPOINT_INTERFACE: &[u8; 21] = b"osa_micro_checkpoint\0";
pub const INSTRUMENTATION_FILTER_SLAVE_INTERFACE: &[u8; 29] = b"instrumentation_filter_slave\0";
pub const INSTRUMENTATION_FILTER_STATUS_INTERFACE: &[u8; 30] = b"instrumentation_filter_status\0";
pub const INSTRUMENTATION_FILTER_MASTER_INTERFACE: &[u8; 30] = b"instrumentation_filter_master\0";
pub const OSA_CONTROL_V2_INTERFACE: &[u8; 15] = b"osa_control_v2\0";
pub const DISASSEMBLE_INTERFACE: &[u8; 12] = b"disassemble\0";
pub const SCALAR_TIME_INTERFACE: &[u8; 12] = b"scalar_time\0";
pub const OSA_COMPONENT_INTERFACE: &[u8; 14] = b"osa_component\0";
pub const PREFERENCE_INTERFACE: &[u8; 11] = b"preference\0";
pub const OSA_NODE_TREE_QUERY_INTERFACE: &[u8; 20] = b"osa_node_tree_query\0";
pub const OSA_NODE_TREE_NOTIFICATION_INTERFACE: &[u8; 27] = b"osa_node_tree_notification\0";
pub const INSTRUMENTATION_TOOL_INTERFACE: &[u8; 21] = b"instrumentation_tool\0";
pub const INSTRUMENTATION_CONNECTION_INTERFACE: &[u8; 27] = b"instrumentation_connection\0";
pub const OSA_NODE_PATH_INTERFACE: &[u8; 14] = b"osa_node_path\0";
pub const ADDRESS_PROFILER_INTERFACE: &[u8; 17] = b"address_profiler\0";
pub const BRANCH_ARC_INTERFACE: &[u8; 11] = b"branch_arc\0";
pub const RECORDER_INTERFACE: &[u8; 9] = b"recorder\0";
pub const RECORDER_V2_INTERFACE: &[u8; 12] = b"recorder_v2\0";
pub const RECORDED_INTERFACE: &[u8; 9] = b"recorded\0";
pub const REGISTER_BREAKPOINT_INTERFACE: &[u8; 20] = b"register_breakpoint\0";
pub const DEBUG_NOTIFICATION_INTERFACE: &[u8; 19] = b"debug_notification\0";
pub const DEBUG_SETUP_INTERFACE: &[u8; 12] = b"debug_setup\0";
pub const DEBUG_QUERY_INTERFACE: &[u8; 12] = b"debug_query\0";
pub const DEBUG_STEP_INTERFACE: &[u8; 11] = b"debug_step\0";
pub const DEBUG_SYMBOL_INTERFACE: &[u8; 13] = b"debug_symbol\0";
pub const DEBUG_SYMBOL_FILE_INTERFACE: &[u8; 18] = b"debug_symbol_file\0";
pub const OSA_CONTROL_INTERFACE: &[u8; 12] = b"osa_control\0";
pub const TABLE_INTERFACE: &[u8; 6] = b"table\0";
pub const BREAKPOINT_PROP_ENABLED: &[u8; 8] = b"enabled\0";
pub const BREAKPOINT_PROP_TEMPORARY: &[u8; 10] = b"temporary\0";
pub const BREAKPOINT_PROP_IGNORE_COUNT: &[u8; 13] = b"ignore count\0";
pub const BREAKPOINT_PROP_HIT_COUNT: &[u8; 10] = b"hit count\0";
pub const BREAKPOINT_PROP_DESCRIPTION: &[u8; 12] = b"description\0";
pub const BREAKPOINT_REGISTRATION_INTERFACE: &[u8; 24] = b"breakpoint_registration\0";
pub const BREAKPOINT_TYPE_INTERFACE: &[u8; 16] = b"breakpoint_type\0";
pub const BREAKPOINT_TYPE_PROVIDER_INTERFACE: &[u8; 25] = b"breakpoint_type_provider\0";
pub const BREAKPOINT_MANAGER_INTERFACE: &[u8; 19] = b"breakpoint_manager\0";
pub const PROBE_INTERFACE: &[u8; 6] = b"probe\0";
pub const PROBE_INDEX_INTERFACE: &[u8; 12] = b"probe_index\0";
pub const PROBE_SUBSCRIBE_INTERFACE: &[u8; 16] = b"probe_subscribe\0";
pub const PROBE_CACHE_INTERFACE: &[u8; 12] = b"probe_cache\0";
pub const PROBE_SAMPLER_CACHE_INTERFACE: &[u8; 20] = b"probe_sampler_cache\0";
pub const PROBE_NOTIFICATION_CONTEXT_INTERFACE: &[u8; 27] = b"probe_notification_context\0";
pub const SERIAL_CONSOLE_FRONTEND_INTERFACE: &[u8; 24] = b"serial_console_frontend\0";
pub const CON_INPUT_INTERFACE: &[u8; 10] = b"con_input\0";
pub const CON_INPUT_CODE_INTERFACE: &[u8; 15] = b"con_input_code\0";
pub const BREAK_STRINGS_INTERFACE: &[u8; 14] = b"break_strings\0";
pub const BREAK_STRINGS_V2_INTERFACE: &[u8; 17] = b"break_strings_v2\0";
pub const GFX_BREAK_INTERFACE: &[u8; 10] = b"gfx_break\0";
pub const TELNET_CONNECTION_INTERFACE: &[u8; 18] = b"telnet_connection\0";
pub const TELNET_CONNECTION_V2_INTERFACE: &[u8; 21] = b"telnet_connection_v2\0";
pub const VNC_SERVER_INTERFACE: &[u8; 11] = b"vnc_server\0";
pub const VNC_SERVER_V2_INTERFACE: &[u8; 14] = b"vnc_server_v2\0";
pub const HOST_SERIAL_INTERFACE: &[u8; 12] = b"host_serial\0";
pub const SCREENSHOT_INTERFACE: &[u8; 11] = b"screenshot\0";
pub const TEXT_CONSOLE_FRONTEND_INTERFACE: &[u8; 22] = b"text_console_frontend\0";
pub const TEXT_CONSOLE_BACKEND_INTERFACE: &[u8; 21] = b"text_console_backend\0";
pub const GFX_CONSOLE_FRONTEND_INTERFACE: &[u8; 21] = b"gfx_console_frontend\0";
pub const GFX_CONSOLE_BACKEND_INTERFACE: &[u8; 20] = b"gfx_console_backend\0";
pub const WINSOME_CONSOLE_INTERFACE: &[u8; 16] = b"winsome_console\0";
pub const GUI_CONSOLE_BACKEND_INTERFACE: &[u8; 20] = b"gui_console_backend\0";
pub const CHECKPOINT_INTERFACE: &[u8; 11] = b"checkpoint\0";
pub type __gnuc_va_list = __builtin_va_list;
#[doc = " Convenience types."]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
#[doc = " These few don't really vary by system, they always correspond\nto one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,\neven in the presence of asynchronous interrupts.\nIt is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[doc = " Conversion state information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    #[doc = " Value so far."]
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic\nC++ mangled names for functions taking fpos_t arguments.\nThat name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic\nC++ mangled names for functions taking fpos_t arguments.\nThat name should not be used in new code."]
pub type __fpos_t = _G_fpos_t;
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic\nC++ mangled names for functions taking fpos_t and/or fpos64_t\narguments.  That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic\nC++ mangled names for functions taking fpos_t and/or fpos64_t\narguments.  That name should not be used in new code."]
pub type __fpos64_t = _G_fpos64_t;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic\nC++ mangled names for functions taking FILE* arguments.\nThat name should not be used in new code."]
pub type __FILE = _IO_FILE;
#[doc = " The opaque type of streams.  This is the definition used elsewhere."]
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic\nC++ mangled names for functions taking FILE* arguments.\nThat name should not be used in new code."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    #[doc = " High-order word is _IO_MAGIC; rest is flags."]
    pub _flags: ::std::os::raw::c_int,
    #[doc = " Current read pointer"]
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    #[doc = " End of get area."]
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    #[doc = " Start of putback+get area."]
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    #[doc = " Start of put area."]
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    #[doc = " Current put pointer."]
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    #[doc = " End of put area."]
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    #[doc = " Start of reserve area."]
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    #[doc = " End of reserve area."]
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to start of non-current get area."]
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to first valid character of backup area"]
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to end of non-current get area."]
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    #[doc = " This used to be _offset but it's too small."]
    pub _old_offset: __off_t,
    #[doc = " 1+column number of pbase(); 0 is unknown."]
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    #[doc = " Wide character stream stuff."]
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    #[doc = " Make sure we don't get into trouble again."]
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic\nC++ mangled names for functions taking fpos_t arguments.\nThat name should not be used in new code."]
pub type fpos_t = __fpos_t;
extern "C" {
    #[doc = " Standard input stream."]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[doc = " Standard output stream."]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[doc = " Standard error output stream."]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    #[doc = " Remove file FILENAME."]
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rename file OLD to NEW."]
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rename file OLD relative to OLDFD to NEW relative to NEWFD."]
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[doc = " Generate a temporary filename."]
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This is the reentrant variant of `tmpnam'.  The only difference is\nthat it does not allow S to be NULL."]
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Generate a unique temporary filename using up to five characters of PFX\nif it is not NULL.  The directory to put this file in is searched for\nas follows: First the environment variable \"TMPDIR\" is checked.\nIf it contains the name of a writable directory, that directory is used.\nIf not and if DIR is not NULL, that value is checked.  If that fails,\nP_tmpdir is tried and finally \"/tmp\".  The storage for the filename\nis allocated by `malloc'."]
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Flush STREAM, or all streams if STREAM is NULL.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster versions when locking is not required.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a file and create a new stream for it.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Open a file, replacing an existing stream with it.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Create a new stream that refers to an existing system file descriptor."]
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    #[doc = " Create a new stream that refers to a memory buffer."]
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Open a stream that writes into a malloc'd buffer that is expanded as\nnecessary.  *BUFLOC and *SIZELOC are updated with the buffer's location\nand the number of characters written on fflush or fclose."]
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " If BUF is NULL, make STREAM unbuffered.\nElse make it use buffer BUF, of size BUFSIZ."]
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Make STREAM use buffering mode MODE.\nIf BUF is not NULL, use N bytes of it for buffering;\nelse allocate an internal buffer N bytes long."]
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If BUF is NULL, make STREAM unbuffered.\nElse make it use SIZE bytes of BUF for buffering."]
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    #[doc = " Make STREAM line-buffered."]
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Write formatted output to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S."]
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG."]
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Maximum chars of output to write in MAXLEN."]
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to a file descriptor."]
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a character from STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a character from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " These are defined in POSIX.1:1996.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster version when locking is not necessary.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a character to STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW.\n\nThese functions is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a character to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster version when locking is not necessary.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " These are defined in POSIX.1:1996.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a word (int) from STREAM."]
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a word (int) to STREAM."]
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a newline-terminated string of finite length from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read up to (and including) a DELIMITER from STREAM into *LINEPTR\n(and null-terminate it). *LINEPTR is a pointer returned from malloc (or\nNULL), pointing to *N characters of space.  It is realloc'd as\nnecessary.  Returns the number of characters read (not including the\nnull terminator), or -1 on error or EOF.\n\nThese functions are not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation they are cancellation points and\ntherefore not marked with __THROW."]
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    #[doc = " Like `getdelim', but reads up to a newline.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    #[doc = " Write a string to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a string, followed by a newline, to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Push a character back onto the input buffer of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read chunks of generic data from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Write chunks of generic data to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Faster versions when locking is not necessary.\n\nThese functions are not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation they are cancellation points and\ntherefore not marked with __THROW."]
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[doc = " Seek to a certain position on STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current position of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Rewind to the beginning of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Seek to a certain position on STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current position of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    #[doc = " Get STREAM's position.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set STREAM's position.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear the error and EOF indicators for STREAM."]
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Return the EOF indicator for STREAM."]
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the error indicator for STREAM."]
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster versions when locking is not required."]
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print a message describing the meaning of the value of errno.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Return the system file descriptor for STREAM."]
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster version when locking is not required."]
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a stream opened by popen and return the status of its child.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new stream connected to a pipe running the given command.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Return the name of the controlling terminal."]
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Acquire ownership of STREAM."]
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Try to acquire ownership of STREAM but do not block if it is not\npossible."]
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Relinquish the ownership granted for STREAM."]
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Slow-path routines used by the optimized inline functions in\nbits/stdio.h."]
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[doc = " Define 'max_align_t' to match the GCC definition."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " Copy N bytes of SRC to DEST."]
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Copy N bytes of SRC to DEST, guaranteeing\ncorrect behavior for overlapping strings."]
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set N bytes of S to C."]
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Compare N bytes of S1 and S2."]
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.\nReturn some non-zero value otherwise.\n\nEssentially __memcmpeq has the exact same semantics as memcmp\nexcept the return value is less constrained.  memcmp is always a\ncorrect implementation of __memcmpeq.  As well !!memcmp, -memcmp,\nor bcmp are correct implementations.\n\n__memcmpeq is meant to be used by compilers when memcmp return is\nonly used for its bolean value.\n\n__memcmpeq is declared only for use by compilers.  Programs should\ncontinue to use memcmp."]
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Copy SRC to DEST."]
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy no more than N characters of SRC to DEST."]
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append SRC onto DEST."]
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append no more than N characters from SRC onto DEST."]
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Compare S1 and S2."]
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare N characters of S1 and S2."]
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the collated forms of S1 and S2."]
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put a transformation of SRC into no more than N bytes of DEST."]
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[doc = " POSIX.1-2008: the locale_t type, representing a locale context\n(implementation-namespace version).  This type should be treated\nas opaque by applications; some details are exposed for the sake of\nefficiency in e.g. ctype functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __locale_struct {
    #[doc = " 13 = __LC_LAST."]
    pub __locales: [*mut __locale_data; 13usize],
    #[doc = " To increase the speed of this solution we add some special members."]
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    #[doc = " Note: LC_ALL is not a valid index into this array."]
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    #[doc = " Compare the collated forms of S1 and S2, using sorting rules from L."]
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put a transformation of SRC into no more than N bytes of DEST,\nusing sorting rules from L."]
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Duplicate S, returning an identical malloc'd string."]
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the length of the initial segment of S which\nconsists entirely of characters not in REJECT."]
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Return the length of the initial segment of S which\nconsists entirely of characters in ACCEPT."]
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Divide S into tokens separated by characters in DELIM."]
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Divide S into tokens separated by characters in DELIM.  Information\npassed between calls are stored in SAVE_PTR."]
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the length of S."]
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Find the length of STRING, but scan at most MAXLEN characters.\nIf no '\\0' terminator is found in that many characters, return MAXLEN."]
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    #[doc = " Return a string describing the meaning of the `errno' code in ERRNUM."]
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Translate error number to string according to the locale L."]
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Compare N bytes of S1 and S2 (same as memcmp)."]
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy N bytes of SRC to DEST (like memmove, but args reversed)."]
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    #[doc = " Set N bytes of S to 0."]
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the position of the first bit set in I, or 0 if none are set.\nThe least-significant bit is position 1, the most-significant 32."]
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare S1 and S2, ignoring case."]
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare no more than N chars of S1 and S2, ignoring case."]
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare S1 and S2, ignoring case, using collation rules from LOC."]
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare no more than N chars of S1 and S2, ignoring case, using\ncollation rules from LOC."]
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set N bytes of S to 0.  The compiler will not delete a call to this\nfunction, even if S is dead after the call."]
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    #[doc = " Return the next DELIM-delimited token from *STRINGP,\nterminating it with a '\\0', and update *STRINGP to point past it."]
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a string describing the meaning of the signal number in SIG."]
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy SRC to DEST, returning the address of the terminating '\\0' in DEST."]
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy no more than N characters of SRC to DEST, returning the address of\nthe last character written into DEST."]
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The error code set by various library functions."]
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[doc = " Returned by `div'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_int,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_long,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[doc = " Returned by `lldiv'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_longlong,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[doc = " Convert a string to an integer."]
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Convert a string to a long long integer."]
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " Likewise for `float' and `long double' sizes of floating-point numbers."]
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Convert a string to an unsigned long integer."]
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Convert a string to a quadword integer."]
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to an unsigned quadword integer."]
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Convert a string to a quadword integer."]
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to an unsigned quadword integer."]
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Convert N to base 64 using the digits \"./0-9A-Za-z\", least-significant\ndigit first.  Returns a pointer to static storage overwritten by the\nnext call."]
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a number from a string S in base 64 as above."]
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
#[doc = " Old compatibility names for C types."]
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
#[doc = " These were defined by ISO C without the first `_'."]
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[doc = " A set of signals to be blocked, unblocked, or waited for."]
pub type sigset_t = __sigset_t;
#[doc = " A time value that is accurate to the nearest\nmicrosecond but also has a range of years."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Microseconds."]
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but\nhas nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[doc = " The fd_set member is required to be an array of longs."]
pub type __fd_mask = ::std::os::raw::c_long;
#[doc = " fd_set for select and pselect."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
#[doc = " Sometimes the fd_set member is assumed to have this type."]
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[doc = " Counter that is monotonically increasing (by less than 2**31 per\nincrement), with a single writer, and an arbitrary number of\nreaders."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Common definition of pthread_mutex_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Common definition of pthread_mutex_t."]
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    #[doc = " KIND must stay at this position in the structure to maintain\nbinary compatibility with static initializers."]
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    #[doc = " FLAGS must stay at this position in the structure to maintain\nbinary compatibility."]
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[doc = " Common definition of pthread_cond_t."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
#[doc = " Thread identifiers.  The structure of the attribute type is not\nexposed on purpose."]
pub type pthread_t = ::std::os::raw::c_ulong;
#[doc = " Data structures for mutex handling.  The structure of the attribute\ntype is not exposed on purpose."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data structure for condition variable handling.  The structure of\nthe attribute type is not exposed on purpose."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Keys for thread-specific data"]
pub type pthread_key_t = ::std::os::raw::c_uint;
#[doc = " Once-only execution"]
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data structure for reader-writer lock variable handling.  The\nstructure of the attribute type is deliberately not exposed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " POSIX spinlock data type."]
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[doc = " POSIX barriers data type.  The structure of the type is\ndeliberately not exposed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " These are the functions that actually do things.  The `random', `srandom',\n`initstate' and `setstate' functions are those from BSD Unices.\nThe `rand' and `srand' functions are required by the ANSI standard.\nWe provide both interfaces to the same random number generator.  */\n/* Return a random long integer between 0 and 2^31-1 inclusive."]
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Seed the random number generator with the given number."]
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Initialize the random number generator to use state buffer STATEBUF,\nof length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,\n32, 64, 128 and 256, the bigger the better; values less than 8 will\ncause an error and values greater than 256 will be rounded down."]
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Switch the random number generator to state buffer STATEBUF,\nwhich should have been previously initialized by `initstate'."]
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[doc = " Reentrant versions of the `random' family of functions.\nThese functions all use the following data structure to contain\nstate, rather than global state variables."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct random_data {
    #[doc = " Front pointer."]
    pub fptr: *mut i32,
    #[doc = " Rear pointer."]
    pub rptr: *mut i32,
    #[doc = " Array of state values."]
    pub state: *mut i32,
    #[doc = " Type of random number generator."]
    pub rand_type: ::std::os::raw::c_int,
    #[doc = " Degree of random number generator."]
    pub rand_deg: ::std::os::raw::c_int,
    #[doc = " Distance between front and rear."]
    pub rand_sep: ::std::os::raw::c_int,
    #[doc = " Pointer behind state table."]
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a random integer between 0 and RAND_MAX inclusive."]
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seed the random number generator with the given number."]
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Reentrant interface according to POSIX.1."]
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return non-negative, double-precision floating-point value in [0.0,1.0)."]
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[doc = " Return non-negative, long integer in [0,2^31)."]
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Return signed, long integers in [-2^31,2^31)."]
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Seed random number generator."]
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[doc = " Data structure for communication with thread safe versions.  This\ntype is to be regarded as opaque.  It's only exported because users\nhave to allocate objects of this type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drand48_data {
    #[doc = " Current state."]
    pub __x: [::std::os::raw::c_ushort; 3usize],
    #[doc = " Old state."]
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    #[doc = " Additive const. in congruential formula."]
    pub __c: ::std::os::raw::c_ushort,
    #[doc = " Flag for initializing."]
    pub __init: ::std::os::raw::c_ushort,
    #[doc = " Factor in congruential\nformula."]
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    #[doc = " Return non-negative, double-precision floating-point value in [0.0,1.0)."]
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return non-negative, long integer in [0,2^31)."]
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return signed, long integers in [-2^31,2^31)."]
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seed random number generator."]
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate SIZE bytes of memory."]
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate NMEMB elements of SIZE bytes each, all initialized to 0."]
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Re-allocate the previously allocated block\nin PTR, making the new block SIZE bytes long.  */\n/* __attribute_malloc__ is not used, because if realloc returns\nthe same pointer that was passed to it, aliasing needs to be allowed\nbetween objects pointed by the old and new pointers."]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free a block allocated by `malloc', `realloc' or `calloc'."]
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Re-allocate the previously allocated block in PTR, making the new\nblock large enough for NMEMB elements of SIZE bytes each.  */\n/* __attribute_malloc__ is not used, because if reallocarray returns\nthe same pointer that was passed to it, aliasing needs to be allowed\nbetween objects pointed by the old and new pointers."]
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a block that will be freed when the calling function exits."]
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate SIZE bytes on a page boundary.  The storage cannot be freed."]
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate memory of SIZE bytes with an alignment of ALIGNMENT."]
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ISO C variant of aligned allocation."]
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Abort execution and generate a core-dump."]
    pub fn abort() -> !;
}
extern "C" {
    #[doc = " Register a function to be called when `exit' is called."]
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a function to be called with the status\ngiven to `exit' and the given argument."]
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call all functions registered with `atexit' and `on_exit',\nin the reverse of the order in which they were registered,\nperform stdio cleanup, and terminate program execution with STATUS."]
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Call all functions registered with `at_quick_exit' in the reverse\nof the order in which they were registered and terminate program\nexecution with STATUS."]
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Terminate the program with STATUS without calling any of the\nfunctions registered with `atexit' or `on_exit'."]
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Return the value of envariable NAME, or NULL if it doesn't exist."]
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The SVID says this is in <stdio.h>, but this seems a better place.\t*/\n/* Put STRING, which is of the form \"NAME=VALUE\", in the environment.\nIf there is no `=', remove NAME from the environment."]
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set NAME to VALUE in the environment.\nIf REPLACE is nonzero, overwrite an existing value."]
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the variable NAME from the environment."]
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The `clearenv' was planned to be added to POSIX.1 but probably\nnever made it.  Nevertheless the POSIX.9 standard (POSIX bindings\nfor Fortran 77) requires this function."]
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a unique temporary file name from TEMPLATE.\nThe last six characters of TEMPLATE must be \"XXXXXX\";\nthey are replaced with a string that makes the file name unique.\nAlways returns TEMPLATE, it's either a temporary file name or a null\nstring if it cannot get a unique file name."]
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a unique temporary directory from TEMPLATE.\nThe last six characters of TEMPLATE must be \"XXXXXX\";\nthey are replaced with a string that makes the directory name unique.\nReturns TEMPLATE, or a null pointer if it cannot get a unique name.\nThe directory is created mode 700."]
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Execute the given line as a shell command.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the canonical absolute name of file NAME.  If RESOLVED is\nnull, the result is malloc'd; otherwise, if the canonical name is\nPATH_MAX chars or more, returns null with `errno' set to\nENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,\nreturns the name in RESOLVED."]
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Do a binary search for KEY in BASE, which consists of NMEMB elements\nof SIZE bytes each, using COMPAR to perform the comparisons."]
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sort NMEMB elements of BASE, of SIZE bytes each,\nusing COMPAR to perform the comparisons."]
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    #[doc = " Return the absolute value of X."]
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Return the `div_t', `ldiv_t' or `lldiv_t' representation\nof the value of NUMER over DENOM. */\n/* GCC may have built-ins for these someday."]
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    #[doc = " Convert VALUE to a string with NDIGIT digits and return a pointer to\nthis.  Set *DECPT with the position of the decimal character and *SIGN\nwith the sign of the number."]
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT\nwith the position of the decimal character and *SIGN with the sign of\nthe number."]
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " If possible convert VALUE to a string with NDIGIT significant digits.\nOtherwise use exponential representation.  The resulting string will\nbe written to BUF."]
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Reentrant version of the functions above which provide their own\nbuffers."]
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the length of the multibyte character\nin S, which is no longer than N."]
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the length of the given multibyte character,\nputting its `wchar_t' representation in *PWC."]
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the multibyte character represented\nby WCHAR in S, returning its length."]
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a multibyte string to a wide char string."]
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    #[doc = " Convert a wide char string to multibyte string."]
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    #[doc = " Determine whether the string value of RESPONSE matches the affirmation\nor negative response expression as specified by the LC_MESSAGES category\nin the program's current locale.  Returns 1 if affirmative, 0 if\nnegative, and -1 if not matching."]
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse comma separated suboption from *OPTIONP and match against\nstrings in TOKENS.  If found return index and set *VALUEP to\noptional value introduced by an equal sign.  If the suboption is\nnot part of TOKENS return in *VALUEP beginning of unknown\nsuboption.  On exit *OPTIONP is set to the beginning of the next\ntoken or at the terminating NUL character."]
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the 1 minute, 5 minute and 15 minute load averages into the first\nNELEM elements of LOADAVG.  Return the number written (never more than\nthree, but may be less than NELEM), or -1 if an error occurred."]
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    #[doc = " Test for access to NAME using the real UID and real GID."]
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test for access to FILE relative to the directory FD is open on.\nIf AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',\notherwise use real IDs like `access'."]
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    #[doc = " Close the file descriptor FD.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close all open file descriptors greater than or equal to LOWFD.\nNegative LOWFD is clamped to 0."]
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Read NBYTES into BUF from FD.  Return the\nnumber read, -1 for errors or 0 for EOF.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Write N bytes of BUF to FD.  Return the number written, or -1.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Read NBYTES into BUF from FD at the given position OFFSET without\nchanging the file pointer.  Return the number read, -1 for errors\nor 0 for EOF.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Write N bytes of BUF to FD at the given position OFFSET without\nchanging the file pointer.  Return the number written, or -1.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Create a one-way communication channel (pipe).\nIf successful, two file descriptors are stored in PIPEDES;\nbytes written on PIPEDES[1] can be read from PIPEDES[0].\nReturns 0 if successful, -1 if not."]
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.\nIf SECONDS is zero, any currently scheduled alarm will be cancelled.\nThe function returns the number of seconds remaining until the last\nalarm scheduled would have signaled, or zero if there wasn't one.\nThere is no return value to indicate an error, but you can set `errno'\nto 0 and check its value after calling `alarm', and this might tell you.\nThe signal may come late due to processor scheduling."]
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Make the process sleep for SECONDS seconds, or until a signal arrives\nand is not ignored.  The function returns the number of seconds less\nthan SECONDS which it actually slept (thus zero if it slept the full time).\nIf a signal handler does a `longjmp' or modifies the handling of the\nSIGALRM signal while inside `sleep' call, the handling of the SIGALRM\nsignal afterwards is undefined.  There is no return value to indicate\nerror, but if `sleep' returns SECONDS, it probably didn't work.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Set an alarm to go off (generating a SIGALRM signal) in VALUE\nmicroseconds.  If INTERVAL is nonzero, when the alarm goes off, the\ntimer is reset to go off every INTERVAL microseconds thereafter.\nReturns the number of microseconds remaining before the alarm."]
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    #[doc = " Sleep USECONDS microseconds, or until a signal arrives that is not blocked\nor ignored.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Suspend the process until a signal arrives.\nThis always returns -1 and sets `errno' to EINTR.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the owner and group of FILE."]
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the owner and group of the file that FD is open on."]
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change owner and group of FILE, if it is a symbolic\nlink the ownership of the symbolic link is changed."]
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the owner and group of FILE relative to the directory FD is open\non."]
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the process's working directory to PATH."]
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the process's working directory to the one FD is open on."]
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the pathname of the current working directory,\nand put it in SIZE bytes of BUF.  Returns NULL if the\ndirectory couldn't be determined or SIZE was too small.\nIf successful, returns BUF.  In GNU, if BUF is NULL,\nan array is allocated with `malloc'; the array is SIZE\nbytes long, unless SIZE == 0, in which case it is as\nbig as necessary."]
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Put the absolute pathname of the current working directory in BUF.\nIf successful, return BUF.  If not, put an error message in\nBUF and return NULL.  BUF should be at least PATH_MAX bytes long."]
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate FD, returning a new file descriptor on the same file."]
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Duplicate FD to FD2, closing FD2 and making it open on the same file."]
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " NULL-terminated array of \"NAME=VALUE\" environment variables."]
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Replace the current process, executing PATH with arguments ARGV and\nenvironment ENVP.  ARGV and ENVP are terminated by NULL pointers."]
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Execute the file FD refers to, overlaying the running program image.\nARGV and ENVP are passed to the new program, as for `execve'."]
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Execute PATH with arguments ARGV and environment from `environ'."]
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Execute PATH with all arguments after PATH until a NULL pointer,\nand the argument after that for environment."]
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Execute PATH with all arguments after PATH until\na NULL pointer and environment from `environ'."]
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Execute FILE, searching in the `PATH' environment variable if it contains\nno slashes, with arguments ARGV and environment from `environ'."]
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Execute FILE, searching in the `PATH' environment variable if\nit contains no slashes, with all arguments after FILE until a\nNULL pointer and environment from `environ'."]
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add INC to priority of the current process."]
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Terminate program execution with the low-order 8 bits of STATUS."]
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
#[doc = " Values for the NAME argument to `pathconf' and `fpathconf'."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
#[doc = " Values for the argument to `sysconf'\ncorresponding to _POSIX2_* symbols."]
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
#[doc = " Values according to POSIX 1003.1c (POSIX threads)."]
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
#[doc = " Leave room here, maybe we need a few more cache levels some day."]
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
#[doc = " Values for the argument to `sysconf'."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " The default search path."]
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
#[doc = " Values for the NAME argument to `confstr'."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get file-specific configuration information about PATH."]
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Get file-specific configuration about descriptor FD."]
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Get the value of the system variable NAME."]
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Get the value of the string-valued system variable NAME."]
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the process ID of the calling process."]
    pub fn getpid() -> __pid_t;
}
extern "C" {
    #[doc = " Get the process ID of the calling process's parent."]
    pub fn getppid() -> __pid_t;
}
extern "C" {
    #[doc = " Get the process group ID of the calling process."]
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    #[doc = " Get the process group ID of process PID."]
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    #[doc = " Set the process group ID of the process matching PID to PGID.\nIf PID is zero, the current process's process group ID is set.\nIf PGID is zero, the process ID of the process is used."]
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process group ID of the calling process to its own PID.\nThis is exactly the same as `setpgid (0, 0)'."]
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new session with the calling process as its leader.\nThe process group IDs of the session and the calling process\nare set to the process ID of the calling process, which is returned."]
    pub fn setsid() -> __pid_t;
}
extern "C" {
    #[doc = " Return the session ID of the given process."]
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    #[doc = " Get the real user ID of the calling process."]
    pub fn getuid() -> __uid_t;
}
extern "C" {
    #[doc = " Get the effective user ID of the calling process."]
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    #[doc = " Get the real group ID of the calling process."]
    pub fn getgid() -> __gid_t;
}
extern "C" {
    #[doc = " Get the effective group ID of the calling process."]
    pub fn getegid() -> __gid_t;
}
extern "C" {
    #[doc = " If SIZE is zero, return the number of supplementary groups\nthe calling process is in.  Otherwise, fill in the group IDs\nof its supplementary groups in LIST and return the number written."]
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the user ID of the calling process to UID.\nIf the calling process is the super-user, set the real\nand effective user IDs, and the saved set-user-ID to UID;\nif not, the effective user ID is set to UID."]
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the real user ID of the calling process to RUID,\nand the effective user ID of the calling process to EUID."]
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the effective user ID of the calling process to UID."]
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the group ID of the calling process to GID.\nIf the calling process is the super-user, set the real\nand effective group IDs, and the saved set-group-ID to GID;\nif not, the effective group ID is set to GID."]
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the real group ID of the calling process to RGID,\nand the effective group ID of the calling process to EGID."]
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the effective group ID of the calling process to GID."]
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clone the calling process, creating an exact copy.\nReturn -1 for errors, 0 to the new process,\nand the process ID of the new process to the old process."]
    pub fn fork() -> __pid_t;
}
extern "C" {
    #[doc = " Clone the calling process, but without copying the whole address space.\nThe calling process is suspended until the new process exits or is\nreplaced by a call to `execve'.  Return -1 for errors, 0 to the new process,\nand the process ID of the new process to the old process."]
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the pathname of the terminal FD is open on, or NULL on errors.\nThe returned storage is good only until the next call to this function."]
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Store at most BUFLEN characters of the pathname of the terminal FD is\nopen on in BUF.  Return 0 on success, otherwise an error number."]
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return 1 if FD is a valid descriptor associated\nwith a terminal, zero if not."]
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the index into the active-logins file (utmp) for\nthe controlling terminal."]
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make a link to FROM named TO."]
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like link but relative paths in TO and FROM are interpreted relative\nto FROMFD and TOFD respectively."]
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make a symbolic link to FROM named TO."]
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the contents of the symbolic link PATH into no more than\nLEN bytes of BUF.  The contents are not null-terminated.\nReturns the number of characters read, or -1 for errors."]
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Like symlink but a relative path in TO is interpreted relative to TOFD."]
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like readlink but a relative PATH is interpreted relative to FD."]
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Remove the link NAME."]
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the link NAME relative to FD."]
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the directory PATH."]
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the foreground process group ID of FD."]
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    #[doc = " Set the foreground process group ID of FD set PGRP_ID."]
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the login name of the user.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return at most NAME_LEN characters of the login name of the user in NAME.\nIf it cannot be determined or some other error occurred, return the error\ncode.  Otherwise return 0.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the login name returned by `getlogin'."]
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For communication from 'getopt' to the caller.\nWhen 'getopt' finds an option that takes an argument,\nthe argument value is returned here.\nAlso, when 'ordering' is RETURN_IN_ORDER,\neach non-option ARGV-element is returned here."]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Index in ARGV of the next element to be scanned.\nThis is used for communication to and from the caller\nand for communication between successive calls to 'getopt'.\n\nOn entry to 'getopt', zero means this is the first call; initialize.\n\nWhen 'getopt' returns -1, this is the index of the first of the\nnon-option elements that the caller should itself scan.\n\nOtherwise, 'optind' communicates from one call to the next\nhow much of ARGV has been scanned so far."]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Callers store zero here to inhibit the error message 'getopt' prints\nfor unrecognized options."]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set to an option character which was unrecognized."]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get definitions and prototypes for functions to process the\narguments in ARGV (ARGC of them, minus the program name) for\noptions given in OPTS.\n\nReturn the option character from OPTS just read.  Return -1 when\nthere are no more options.  For unrecognized options, or options\nmissing arguments, 'optopt' is set to the option letter, and '?' is\nreturned.\n\nThe OPTS string is a list of characters which are recognized option\nletters, optionally followed by colons, specifying that that letter\ntakes an argument, to be placed in 'optarg'.\n\nIf a letter in OPTS is followed by two colons, its argument is\noptional.  This behavior is specific to the GNU 'getopt'.\n\nThe argument '--' causes premature termination of argument\nscanning, explicitly telling 'getopt' that there are no more\noptions.\n\nIf OPTS begins with '-', then non-option arguments are treated as\narguments to the option '\\1'.  This behavior is specific to the GNU\n'getopt'.  If OPTS begins with '+', or POSIXLY_CORRECT is set in\nthe environment, then do not permute arguments.\n\nFor standards compliance, the 'argv' argument has the type\nchar *const *, but this is inaccurate; if argument permutation is\nenabled, the argv array (not the strings it points to) must be\nwritable."]
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the name of the current host in no more than LEN bytes of NAME.\nThe result is null-terminated if LEN is large enough for the full\nname and the terminator."]
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the name of the current host to NAME, which is LEN bytes long.\nThis call is restricted to the super-user."]
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the current machine's Internet number to ID.\nThis call is restricted to the super-user."]
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get and set the NIS (aka YP) domain name, if any.\nCalled just like `gethostname' and `sethostname'.\nThe NIS domain name is usually the empty string when not using NIS."]
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Revoke access permissions to all processes currently communicating\nwith the control terminal, and then send a SIGHUP signal to the process\ngroup of the control terminal."]
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Revoke the access of all descriptors currently open on FILE."]
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable statistical profiling, writing samples of the PC into at most\nSIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling\nis enabled, the system examines the user PC and increments\nSAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,\ndisable profiling.  Returns zero on success, -1 on error."]
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn accounting on if NAME is an existing file.  The system will then write\na record for each process as it terminates, to this file.  If NAME is NULL,\nturn accounting off.  This call is restricted to the super-user."]
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Successive calls return the shells listed in `/etc/shells'."]
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    #[doc = " Put the program in the background, and dissociate from the controlling\nterminal.  If NOCHDIR is zero, do `chdir (\"/\")'.  If NOCLOSE is zero,\nredirects stdin, stdout, and stderr to /dev/null."]
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make PATH be the root directory (the starting point for absolute paths).\nThis call is restricted to the super-user."]
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prompt with PROMPT and read a string from the terminal without echoing.\nUses /dev/tty if possible; otherwise stderr and stdin."]
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Make all changes done to FD actually appear on disk.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return identifier for the current host."]
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Make all changes done to all files actually appear on disk."]
    pub fn sync();
}
extern "C" {
    #[doc = " Return the number of bytes in a page.  This is the system's page size,\nwhich is not necessarily the same as the hardware page size."]
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the maximum number of file descriptors\nthe current process could possibly have."]
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the end of accessible data space (aka \"the break\") to ADDR.\nReturns zero on success and -1 for errors (with errno set)."]
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increase or decrease the end of accessible data space by DELTA bytes.\nIf successful, returns the address the previous end of data space\n(i.e. the beginning of the new space, if DELTA > 0);\nreturns (void *) -1 for errors (with errno set)."]
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Invoke `system call' number SYSNO, passing it the remaining arguments.\nThis is completely system-dependent, and not often useful.\n\nIn Unix, `syscall' sets `errno' for all errors and most calls return -1\nfor errors; in many systems you cannot pass arguments or get return\nvalues for all system calls (`pipe', `fork', and `getppid' typically\namong them).\n\nIn Mach, all system calls take normal arguments and always return an\nerror code (zero for success)."]
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Synchronize at least the data part of a file with the underlying\nmedia."]
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " One-way hash PHRASE, returning a string suitable for storage in the\nuser database.  SALT selects the one-way function to use, and\nensures that no two users' hashes are the same, even if they use\nthe same passphrase.  The return value points to static storage\nwhich will be overwritten by the next call to crypt."]
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on\nsuccess or -1 on error."]
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This prints an \"Assertion failed\" message and aborts."]
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " Likewise, but prints the error text for ERRNUM."]
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " The following is not at all used here but needed for standard\ncompliance."]
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[doc = " We have to define the `uintmax_t' type using `ldiv_t'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct imaxdiv_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_long,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    #[doc = " Compute absolute value of N."]
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    #[doc = " Return the `imaxdiv_t' representation of the value of NUMER over DENOM."]
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    #[doc = " Like `strtol' but convert to `intmax_t'."]
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    #[doc = " Like `strtoul' but convert to `uintmax_t'."]
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    #[doc = " Like `wcstol' but convert to `intmax_t'."]
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    #[doc = " Like `wcstoul' but convert to `uintmax_t'."]
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = " uintptr_t is the C9X name for an unsigned integral type such that a\n legitimate void* can be cast to uintptr_t and then back to void* again\n without loss of information.  Similarly for intptr_t, wrt a signed\n integral type."]
pub type Py_uintptr_t = usize;
pub type Py_intptr_t = isize;
pub type Py_ssize_t = isize;
pub type Py_hash_t = Py_ssize_t;
pub type Py_uhash_t = usize;
pub type Py_ssize_clean_t = ::std::os::raw::c_int;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    #[doc = " This variable is used by `gamma' and `lgamma'."]
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_4 = 0;
pub const FP_INFINITE: _bindgen_ty_4 = 1;
pub const FP_ZERO: _bindgen_ty_4 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_4 = 3;
pub const FP_NORMAL: _bindgen_ty_4 = 4;
#[doc = " All floating-point numbers can be put in one of these categories."]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = " Structure crudely representing a timezone.\nThis is obsolete and should never be used."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timezone {
    #[doc = " Minutes west of GMT."]
    pub tz_minuteswest: ::std::os::raw::c_int,
    #[doc = " Nonzero if DST is ever in effect."]
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the current time of day and timezone information.\nThis call is restricted to the super-user.\nSetting the timezone in this way is obsolete, but we don't yet\nwarn about it because it still has some uses for which there is\nno alternative."]
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjust the current time of day by the amount in DELTA.\nIf OLDDELTA is not NULL, it is filled in with the amount\nof time adjustment remaining to be done from the last `adjtime' call.\nThis call is restricted to the super-user."]
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
#[doc = " Timers run in real time."]
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
#[doc = " Timers run only when the process is executing."]
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
#[doc = " Timers run when the process is executing and when\nthe system is executing on behalf of the process."]
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
#[doc = " Values for the first argument to `getitimer' and `setitimer'."]
pub type __itimer_which = ::std::os::raw::c_uint;
#[doc = " Type of the second argument to `getitimer' and\nthe second and third arguments `setitimer'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct itimerval {
    #[doc = " Value to put into `it_value' when the timer expires."]
    pub it_interval: timeval,
    #[doc = " Time to the next timer expiration."]
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Set *VALUE to the current setting of timer WHICH.\nReturn 0 on success, -1 on errors."]
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the timer WHICH to *NEW.  If OLD is not NULL,\nset *OLD to the old value of timer WHICH.\nReturns 0 on success, -1 on errors."]
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the access time of FILE to TVP[0] and the modification time of\nFILE to TVP[1].  If TVP is a null pointer, use the current time instead.\nReturns 0 on success, -1 on errors."]
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as `utimes', but does not follow symbolic links."]
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as `utimes', but takes an open file descriptor instead of a name."]
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
#[doc = " ISO C `broken-down time' structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: ::std::os::raw::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: ::std::os::raw::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: ::std::os::raw::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: ::std::os::raw::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: ::std::os::raw::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: ::std::os::raw::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: ::std::os::raw::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: ::std::os::raw::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: ::std::os::raw::c_int,
    #[doc = " Seconds east of UTC."]
    pub tm_gmtoff: ::std::os::raw::c_long,
    #[doc = " Timezone abbreviation."]
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " POSIX.1b structure for timer start values and intervals."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Time used by the program so far (user time + system time).\nThe result / CLOCKS_PER_SEC is program time in seconds."]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[doc = " Return the current time and put it in *TIMER if TIMER is not NULL."]
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    #[doc = " Return the difference between TIME1 and TIME0."]
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    #[doc = " Return the `time_t' representation of TP and normalize TP."]
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT.\nWrite no more than MAXSIZE characters and return the number\nof characters written, or 0 if it would exceed MAXSIZE."]
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    #[doc = " Similar to the two functions above but take the information from\nthe provided locale and not the global locale."]
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER\nin Universal Coordinated Time (aka Greenwich Mean Time)."]
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation\nof *TIMER in the local timezone."]
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in UTC,\nusing *TP to store the result."]
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in local time,\nusing *TP to store the result."]
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Current timezone names."]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[doc = " If daylight-saving time is ever in use."]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seconds west of UTC."]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Same as above."]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[doc = " Set time conversion information from the TZ environment variable.\nIf TZ is not defined, a locale-dependent default is used."]
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Like `mktime', but for TP represents Universal Time, not local time."]
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Another name for `mktime'."]
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Return the number of days in YEAR."]
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause execution for a number of nanoseconds.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get resolution of clock CLOCK_ID."]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current value of clock CLOCK_ID and store it in TP."]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set clock CLOCK_ID to value TP."]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return clock ID for CPU-time clock."]
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create new per-process timer using CLOCK_ID."]
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete timer TIMERID."]
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current value of timer TIMERID and store it in VALUE."]
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get expiration overrun for timer TIMERID."]
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set TS to calendar time based in time base BASE."]
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct stat {
    #[doc = " Device."]
    pub st_dev: __dev_t,
    #[doc = " File serial number."]
    pub st_ino: __ino_t,
    #[doc = " Link count."]
    pub st_nlink: __nlink_t,
    #[doc = " File mode."]
    pub st_mode: __mode_t,
    #[doc = " User ID of the file's owner."]
    pub st_uid: __uid_t,
    #[doc = " Group ID of the file's group."]
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    #[doc = " Device number, if device."]
    pub st_rdev: __dev_t,
    #[doc = " Size of file, in bytes."]
    pub st_size: __off_t,
    #[doc = " Optimal block size for I/O."]
    pub st_blksize: __blksize_t,
    #[doc = " Number 512-byte blocks allocated."]
    pub st_blocks: __blkcnt_t,
    #[doc = " Time of last access."]
    pub st_atim: timespec,
    #[doc = " Time of last modification."]
    pub st_mtim: timespec,
    #[doc = " Time of last status change."]
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    #[doc = " Get file attributes for FILE and put them in BUF."]
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get file attributes for the file, device, pipe, or socket\nthat file descriptor FD is open on and put them in BUF."]
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get file attributes about FILE and put them in BUF.\nIf FILE is a symbolic link, do not follow it."]
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set file access permissions for FILE to MODE.\nIf FILE is a symbolic link, this affects its target instead."]
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set file access permissions for FILE to MODE.\nIf FILE is a symbolic link, this affects the link itself\nrather than its target."]
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set file access permissions of FILE relative to\nthe directory FD is open on."]
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the file creation mask of the current process to MASK,\nand return the old creation mask."]
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    #[doc = " Create a new directory named PATH, with permission bits MODE."]
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like mkdir, create a new directory with permission bits MODE.  But\ninterpret relative PATH names relative to the directory associated\nwith FD."]
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like mknod, create a new device file with permission bits MODE and\ndevice number DEV.  But interpret relative PATH names relative to\nthe directory associated with FD."]
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new FIFO named PATH, with permission bits MODE."]
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like mkfifo, create a new FIFO with permission bits MODE.  But\ninterpret relative PATH names relative to the directory associated\nwith FD."]
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set file access and modification times relative to directory file\ndescriptor."]
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set file access and modification times of the file associated with FD."]
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_get_387controlword() -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _Py_set_387controlword(arg1: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn _Py_bit_length(d: ::std::os::raw::c_ulong) -> ::std::os::raw::c_uint;
}
#[doc = " PyTypeObject structure is defined in cpython/object.h.\nIn Py_LIMITED_API, PyTypeObject is an opaque structure."]
pub type PyTypeObject = _typeobject;
#[doc = " Nothing is actually declared to be a PyObject, but every pointer to\n a Python object can be cast to a PyObject*.  This is inheritance built\n by hand.  Similarly every pointer to a variable-size Python object can,\n in addition, be cast to PyVarObject*."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut PyTypeObject,
}
#[test]
fn bindgen_test_layout__object() {
    const UNINIT: ::std::mem::MaybeUninit<_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_object>(),
        16usize,
        concat!("Size of: ", stringify!(_object))
    );
    assert_eq!(
        ::std::mem::align_of::<_object>(),
        8usize,
        concat!("Alignment of ", stringify!(_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_refcnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_object),
            "::",
            stringify!(ob_refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_object),
            "::",
            stringify!(ob_type)
        )
    );
}
impl Default for _object {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Nothing is actually declared to be a PyObject, but every pointer to\n a Python object can be cast to a PyObject*.  This is inheritance built\n by hand.  Similarly every pointer to a variable-size Python object can,\n in addition, be cast to PyVarObject*."]
pub type PyObject = _object;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyVarObject {
    pub ob_base: PyObject,
    #[doc = " Number of items in variable part"]
    pub ob_size: Py_ssize_t,
}
#[test]
fn bindgen_test_layout_PyVarObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyVarObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyVarObject>(),
        24usize,
        concat!("Size of: ", stringify!(PyVarObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyVarObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyVarObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyVarObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyVarObject),
            "::",
            stringify!(ob_size)
        )
    );
}
impl Default for PyVarObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Type objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks."]
pub type unaryfunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> *mut PyObject>;
pub type binaryfunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,
>;
pub type ternaryfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject,
>;
pub type inquiry =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;
pub type lenfunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> Py_ssize_t>;
pub type ssizeargfunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,
>;
pub type ssizessizeargfunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: Py_ssize_t, arg3: Py_ssize_t) -> *mut PyObject,
>;
pub type ssizeobjargproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type ssizessizeobjargproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: Py_ssize_t,
        arg4: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type objobjargproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type objobjproc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,
>;
pub type visitproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type traverseproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: visitproc,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type freefunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type destructor = ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject)>;
pub type getattrfunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,
>;
pub type getattrofunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,
>;
pub type setattrfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type setattrofunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type reprfunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> *mut PyObject>;
pub type hashfunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> Py_hash_t>;
pub type richcmpfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: ::std::os::raw::c_int,
    ) -> *mut PyObject,
>;
pub type getiterfunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> *mut PyObject>;
pub type iternextfunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject) -> *mut PyObject>;
pub type descrgetfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject,
>;
pub type descrsetfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type initproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
pub type newfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyTypeObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject,
>;
pub type allocfunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyTypeObject, arg2: Py_ssize_t) -> *mut PyObject,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyType_Slot {
    #[doc = " slot id, see below"]
    pub slot: ::std::os::raw::c_int,
    #[doc = " function pointer"]
    pub pfunc: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PyType_Slot() {
    const UNINIT: ::std::mem::MaybeUninit<PyType_Slot> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyType_Slot>(),
        16usize,
        concat!("Size of: ", stringify!(PyType_Slot))
    );
    assert_eq!(
        ::std::mem::align_of::<PyType_Slot>(),
        8usize,
        concat!("Alignment of ", stringify!(PyType_Slot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Slot),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Slot),
            "::",
            stringify!(pfunc)
        )
    );
}
impl Default for PyType_Slot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyType_Spec {
    pub name: *const ::std::os::raw::c_char,
    pub basicsize: ::std::os::raw::c_int,
    pub itemsize: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
    #[doc = " terminated by slot==0."]
    pub slots: *mut PyType_Slot,
}
#[test]
fn bindgen_test_layout_PyType_Spec() {
    const UNINIT: ::std::mem::MaybeUninit<PyType_Spec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyType_Spec>(),
        32usize,
        concat!("Size of: ", stringify!(PyType_Spec))
    );
    assert_eq!(
        ::std::mem::align_of::<PyType_Spec>(),
        8usize,
        concat!("Alignment of ", stringify!(PyType_Spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Spec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basicsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Spec),
            "::",
            stringify!(basicsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itemsize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Spec),
            "::",
            stringify!(itemsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Spec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyType_Spec),
            "::",
            stringify!(slots)
        )
    );
}
impl Default for PyType_Spec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn PyType_FromSpec(arg1: *mut PyType_Spec) -> *mut PyObject;
}
extern "C" {
    pub fn PyType_FromSpecWithBases(arg1: *mut PyType_Spec, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyType_GetSlot(
        arg1: *mut PyTypeObject,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyType_FromModuleAndSpec(
        arg1: *mut PyObject,
        arg2: *mut PyType_Spec,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyType_GetModule(arg1: *mut _typeobject) -> *mut PyObject;
}
extern "C" {
    pub fn PyType_GetModuleState(arg1: *mut _typeobject) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Generic type check"]
    pub fn PyType_IsSubtype(
        arg1: *mut PyTypeObject,
        arg2: *mut PyTypeObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " built-in 'type'"]
    pub static mut PyType_Type: PyTypeObject;
}
extern "C" {
    #[doc = " built-in 'object'"]
    pub static mut PyBaseObject_Type: PyTypeObject;
}
extern "C" {
    #[doc = " built-in 'super'"]
    pub static mut PySuper_Type: PyTypeObject;
}
extern "C" {
    pub fn PyType_GetFlags(arg1: *mut PyTypeObject) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PyType_Ready(arg1: *mut PyTypeObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyType_GenericAlloc(arg1: *mut PyTypeObject, arg2: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn PyType_GenericNew(
        arg1: *mut PyTypeObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyType_ClearCache() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn PyType_Modified(arg1: *mut PyTypeObject);
}
extern "C" {
    #[doc = " Generic operations on objects"]
    pub fn PyObject_Repr(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_Str(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_ASCII(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_Bytes(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_RichCompare(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_RichCompareBool(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_GetAttrString(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_SetAttrString(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_HasAttrString(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_GetAttr(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_SetAttr(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_HasAttr(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_SelfIter(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_GenericGetAttr(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_GenericSetAttr(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_GenericSetDict(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_Hash(arg1: *mut PyObject) -> Py_hash_t;
}
extern "C" {
    pub fn PyObject_HashNotImplemented(arg1: *mut PyObject) -> Py_hash_t;
}
extern "C" {
    pub fn PyObject_IsTrue(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_Not(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCallable_Check(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_ClearWeakRefs(arg1: *mut PyObject);
}
extern "C" {
    #[doc = " PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\nlist of strings.  PyObject_Dir(NULL) is like builtins.dir(),\nreturning the names of the current locals.  In this case, if there are\nno current locals, NULL is returned, and PyErr_Occurred() is false."]
    pub fn PyObject_Dir(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Helpers for printing recursive container types"]
    pub fn Py_ReprEnter(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_ReprLeave(arg1: *mut PyObject);
}
extern "C" {
    pub fn _Py_Dealloc(arg1: *mut PyObject);
}
extern "C" {
    #[doc = "These are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags."]
    pub fn Py_IncRef(arg1: *mut PyObject);
}
extern "C" {
    pub fn Py_DecRef(arg1: *mut PyObject);
}
extern "C" {
    #[doc = " Don't use this directly"]
    pub static mut _Py_NoneStruct: PyObject;
}
extern "C" {
    #[doc = " Don't use this directly"]
    pub static mut _Py_NotImplementedStruct: PyObject;
}
extern "C" {
    pub fn _Py_NewReference(op: *mut PyObject);
}
extern "C" {
    #[doc = " Update the Python traceback of an object. This function must be called\nwhen a memory block is reused from a free list."]
    pub fn _PyTraceMalloc_NewReference(op: *mut PyObject) -> ::std::os::raw::c_int;
}
#[doc = " String Literals ****************************************/\n/* This structure helps managing static strings. The basic usage goes like this:\nInstead of doing\n\nr = PyObject_CallMethod(o, \"foo\", \"args\", ...);\n\ndo\n\n_Py_IDENTIFIER(foo);\n...\nr = _PyObject_CallMethodId(o, &PyId_foo, \"args\", ...);\n\nPyId_foo is a static variable, either on block level or file level. On first\nusage, the string \"foo\" is interned, and the structures are linked. On interpreter\nshutdown, all strings are released.\n\nAlternatively, _Py_static_string allows choosing the variable name.\n_PyUnicode_FromId returns a borrowed reference to the interned string.\n_PyObject_{Get,Set,Has}AttrId are __getattr__ versions using _Py_Identifier*."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Py_Identifier {
    pub next: *mut _Py_Identifier,
    pub string: *const ::std::os::raw::c_char,
    pub object: *mut PyObject,
}
#[test]
fn bindgen_test_layout__Py_Identifier() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_Identifier> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_Identifier>(),
        24usize,
        concat!("Size of: ", stringify!(_Py_Identifier))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_Identifier>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_Identifier))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_Identifier),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_Identifier),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_Identifier),
            "::",
            stringify!(object)
        )
    );
}
impl Default for _Py_Identifier {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " buffer interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bufferinfo {
    pub buf: *mut ::std::os::raw::c_void,
    #[doc = " owned reference"]
    pub obj: *mut PyObject,
    pub len: Py_ssize_t,
    #[doc = " This is Py_ssize_t so it can be\npointed to by strides in simple case."]
    pub itemsize: Py_ssize_t,
    pub readonly: ::std::os::raw::c_int,
    pub ndim: ::std::os::raw::c_int,
    pub format: *mut ::std::os::raw::c_char,
    pub shape: *mut Py_ssize_t,
    pub strides: *mut Py_ssize_t,
    pub suboffsets: *mut Py_ssize_t,
    pub internal: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_bufferinfo() {
    const UNINIT: ::std::mem::MaybeUninit<bufferinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bufferinfo>(),
        80usize,
        concat!("Size of: ", stringify!(bufferinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<bufferinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(bufferinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itemsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(itemsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readonly) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(readonly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ndim) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(ndim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strides) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(strides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suboffsets) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(suboffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferinfo),
            "::",
            stringify!(internal)
        )
    );
}
impl Default for bufferinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " buffer interface"]
pub type Py_buffer = bufferinfo;
pub type getbufferproc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut Py_buffer,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type releasebufferproc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;
pub type vectorcallfunc = ::std::option::Option<
    unsafe extern "C" fn(
        callable: *mut PyObject,
        args: *const *mut PyObject,
        nargsf: usize,
        kwnames: *mut PyObject,
    ) -> *mut PyObject,
>;
#[doc = " End buffer interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyNumberMethods {
    #[doc = " Number implementations must check *both*\narguments for proper type and implement the necessary conversions\nin the slot functions themselves."]
    pub nb_add: binaryfunc,
    pub nb_subtract: binaryfunc,
    pub nb_multiply: binaryfunc,
    pub nb_remainder: binaryfunc,
    pub nb_divmod: binaryfunc,
    pub nb_power: ternaryfunc,
    pub nb_negative: unaryfunc,
    pub nb_positive: unaryfunc,
    pub nb_absolute: unaryfunc,
    pub nb_bool: inquiry,
    pub nb_invert: unaryfunc,
    pub nb_lshift: binaryfunc,
    pub nb_rshift: binaryfunc,
    pub nb_and: binaryfunc,
    pub nb_xor: binaryfunc,
    pub nb_or: binaryfunc,
    pub nb_int: unaryfunc,
    #[doc = " the slot formerly known as nb_long"]
    pub nb_reserved: *mut ::std::os::raw::c_void,
    pub nb_float: unaryfunc,
    pub nb_inplace_add: binaryfunc,
    pub nb_inplace_subtract: binaryfunc,
    pub nb_inplace_multiply: binaryfunc,
    pub nb_inplace_remainder: binaryfunc,
    pub nb_inplace_power: ternaryfunc,
    pub nb_inplace_lshift: binaryfunc,
    pub nb_inplace_rshift: binaryfunc,
    pub nb_inplace_and: binaryfunc,
    pub nb_inplace_xor: binaryfunc,
    pub nb_inplace_or: binaryfunc,
    pub nb_floor_divide: binaryfunc,
    pub nb_true_divide: binaryfunc,
    pub nb_inplace_floor_divide: binaryfunc,
    pub nb_inplace_true_divide: binaryfunc,
    pub nb_index: unaryfunc,
    pub nb_matrix_multiply: binaryfunc,
    pub nb_inplace_matrix_multiply: binaryfunc,
}
#[test]
fn bindgen_test_layout_PyNumberMethods() {
    const UNINIT: ::std::mem::MaybeUninit<PyNumberMethods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyNumberMethods>(),
        288usize,
        concat!("Size of: ", stringify!(PyNumberMethods))
    );
    assert_eq!(
        ::std::mem::align_of::<PyNumberMethods>(),
        8usize,
        concat!("Alignment of ", stringify!(PyNumberMethods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_subtract) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_subtract)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_multiply) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_multiply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_remainder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_remainder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_divmod) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_divmod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_power) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_negative) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_negative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_positive) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_positive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_absolute) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_absolute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_bool) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_invert) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_invert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_lshift) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_lshift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_rshift) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_rshift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_and) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_and)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_xor) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_xor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_or) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_or)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_int) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_reserved) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_float) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_add) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_subtract) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_subtract)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_multiply) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_multiply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_remainder) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_remainder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_power) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_lshift) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_lshift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_rshift) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_rshift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_and) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_and)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_xor) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_xor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_or) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_or)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_floor_divide) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_floor_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_true_divide) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_true_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_floor_divide) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_floor_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_true_divide) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_true_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_index) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_matrix_multiply) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_matrix_multiply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inplace_matrix_multiply) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(PyNumberMethods),
            "::",
            stringify!(nb_inplace_matrix_multiply)
        )
    );
}
impl Default for PyNumberMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PySequenceMethods {
    pub sq_length: lenfunc,
    pub sq_concat: binaryfunc,
    pub sq_repeat: ssizeargfunc,
    pub sq_item: ssizeargfunc,
    pub was_sq_slice: *mut ::std::os::raw::c_void,
    pub sq_ass_item: ssizeobjargproc,
    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,
    pub sq_contains: objobjproc,
    pub sq_inplace_concat: binaryfunc,
    pub sq_inplace_repeat: ssizeargfunc,
}
#[test]
fn bindgen_test_layout_PySequenceMethods() {
    const UNINIT: ::std::mem::MaybeUninit<PySequenceMethods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PySequenceMethods>(),
        80usize,
        concat!("Size of: ", stringify!(PySequenceMethods))
    );
    assert_eq!(
        ::std::mem::align_of::<PySequenceMethods>(),
        8usize,
        concat!("Alignment of ", stringify!(PySequenceMethods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_concat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_concat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_repeat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_repeat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_item) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_item)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).was_sq_slice) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(was_sq_slice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_ass_item) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_ass_item)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).was_sq_ass_slice) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(was_sq_ass_slice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_contains) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_contains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_inplace_concat) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_inplace_concat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sq_inplace_repeat) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PySequenceMethods),
            "::",
            stringify!(sq_inplace_repeat)
        )
    );
}
impl Default for PySequenceMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMappingMethods {
    pub mp_length: lenfunc,
    pub mp_subscript: binaryfunc,
    pub mp_ass_subscript: objobjargproc,
}
#[test]
fn bindgen_test_layout_PyMappingMethods() {
    const UNINIT: ::std::mem::MaybeUninit<PyMappingMethods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMappingMethods>(),
        24usize,
        concat!("Size of: ", stringify!(PyMappingMethods))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMappingMethods>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMappingMethods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMappingMethods),
            "::",
            stringify!(mp_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp_subscript) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMappingMethods),
            "::",
            stringify!(mp_subscript)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp_ass_subscript) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMappingMethods),
            "::",
            stringify!(mp_ass_subscript)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyAsyncMethods {
    pub am_await: unaryfunc,
    pub am_aiter: unaryfunc,
    pub am_anext: unaryfunc,
}
#[test]
fn bindgen_test_layout_PyAsyncMethods() {
    const UNINIT: ::std::mem::MaybeUninit<PyAsyncMethods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyAsyncMethods>(),
        24usize,
        concat!("Size of: ", stringify!(PyAsyncMethods))
    );
    assert_eq!(
        ::std::mem::align_of::<PyAsyncMethods>(),
        8usize,
        concat!("Alignment of ", stringify!(PyAsyncMethods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_await) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncMethods),
            "::",
            stringify!(am_await)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_aiter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncMethods),
            "::",
            stringify!(am_aiter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_anext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncMethods),
            "::",
            stringify!(am_anext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyBufferProcs {
    pub bf_getbuffer: getbufferproc,
    pub bf_releasebuffer: releasebufferproc,
}
#[test]
fn bindgen_test_layout_PyBufferProcs() {
    const UNINIT: ::std::mem::MaybeUninit<PyBufferProcs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyBufferProcs>(),
        16usize,
        concat!("Size of: ", stringify!(PyBufferProcs))
    );
    assert_eq!(
        ::std::mem::align_of::<PyBufferProcs>(),
        8usize,
        concat!("Alignment of ", stringify!(PyBufferProcs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bf_getbuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBufferProcs),
            "::",
            stringify!(bf_getbuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bf_releasebuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBufferProcs),
            "::",
            stringify!(bf_releasebuffer)
        )
    );
}
#[doc = " Allow printfunc in the tp_vectorcall_offset slot for\n backwards-compatibility"]
pub type printfunc = Py_ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _typeobject {
    pub ob_base: PyVarObject,
    #[doc = " For printing, in format \"<module>.<name>\""]
    pub tp_name: *const ::std::os::raw::c_char,
    #[doc = " For allocation"]
    pub tp_basicsize: Py_ssize_t,
    #[doc = " For allocation"]
    pub tp_itemsize: Py_ssize_t,
    #[doc = " Methods to implement standard operations"]
    pub tp_dealloc: destructor,
    pub tp_vectorcall_offset: Py_ssize_t,
    pub tp_getattr: getattrfunc,
    pub tp_setattr: setattrfunc,
    #[doc = " formerly known as tp_compare (Python 2)\nor tp_reserved (Python 3)"]
    pub tp_as_async: *mut PyAsyncMethods,
    pub tp_repr: reprfunc,
    #[doc = " Method suites for standard classes"]
    pub tp_as_number: *mut PyNumberMethods,
    pub tp_as_sequence: *mut PySequenceMethods,
    pub tp_as_mapping: *mut PyMappingMethods,
    #[doc = " More standard operations (here for binary compatibility)"]
    pub tp_hash: hashfunc,
    pub tp_call: ternaryfunc,
    pub tp_str: reprfunc,
    pub tp_getattro: getattrofunc,
    pub tp_setattro: setattrofunc,
    #[doc = " Functions to access object as input/output buffer"]
    pub tp_as_buffer: *mut PyBufferProcs,
    #[doc = " Flags to define presence of optional/expanded features"]
    pub tp_flags: ::std::os::raw::c_ulong,
    #[doc = " Documentation string"]
    pub tp_doc: *const ::std::os::raw::c_char,
    #[doc = " Assigned meaning in release 2.0 */\n/* call function for all accessible objects"]
    pub tp_traverse: traverseproc,
    #[doc = " delete references to contained objects"]
    pub tp_clear: inquiry,
    #[doc = " Assigned meaning in release 2.1 */\n/* rich comparisons"]
    pub tp_richcompare: richcmpfunc,
    #[doc = " weak reference enabler"]
    pub tp_weaklistoffset: Py_ssize_t,
    #[doc = " Iterators"]
    pub tp_iter: getiterfunc,
    pub tp_iternext: iternextfunc,
    #[doc = " Attribute descriptor and subclassing stuff"]
    pub tp_methods: *mut PyMethodDef,
    pub tp_members: *mut PyMemberDef,
    pub tp_getset: *mut PyGetSetDef,
    pub tp_base: *mut _typeobject,
    pub tp_dict: *mut PyObject,
    pub tp_descr_get: descrgetfunc,
    pub tp_descr_set: descrsetfunc,
    pub tp_dictoffset: Py_ssize_t,
    pub tp_init: initproc,
    pub tp_alloc: allocfunc,
    pub tp_new: newfunc,
    #[doc = " Low-level free-memory routine"]
    pub tp_free: freefunc,
    #[doc = " For PyObject_IS_GC"]
    pub tp_is_gc: inquiry,
    pub tp_bases: *mut PyObject,
    #[doc = " method resolution order"]
    pub tp_mro: *mut PyObject,
    pub tp_cache: *mut PyObject,
    pub tp_subclasses: *mut PyObject,
    pub tp_weaklist: *mut PyObject,
    pub tp_del: destructor,
    #[doc = " Type attribute cache version tag. Added in version 2.6"]
    pub tp_version_tag: ::std::os::raw::c_uint,
    pub tp_finalize: destructor,
    pub tp_vectorcall: vectorcallfunc,
}
#[test]
fn bindgen_test_layout__typeobject() {
    const UNINIT: ::std::mem::MaybeUninit<_typeobject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_typeobject>(),
        408usize,
        concat!("Size of: ", stringify!(_typeobject))
    );
    assert_eq!(
        ::std::mem::align_of::<_typeobject>(),
        8usize,
        concat!("Alignment of ", stringify!(_typeobject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_basicsize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_basicsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_itemsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_itemsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_dealloc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_dealloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_vectorcall_offset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_vectorcall_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_getattr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_getattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_setattr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_setattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_as_async) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_as_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_repr) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_repr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_as_number) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_as_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_as_sequence) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_as_sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_as_mapping) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_as_mapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_hash) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_call) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_str) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_getattro) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_getattro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_setattro) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_setattro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_as_buffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_as_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_flags) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_doc) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_traverse) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_traverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_clear) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_richcompare) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_richcompare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_weaklistoffset) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_weaklistoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_iter) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_iter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_iternext) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_iternext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_methods) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_members) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_members)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_getset) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_getset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_base) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_dict) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_descr_get) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_descr_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_descr_set) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_descr_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_dictoffset) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_dictoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_init) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_alloc) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_new) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_free) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_is_gc) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_is_gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_bases) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_bases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_mro) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_mro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_cache) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_subclasses) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_subclasses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_weaklist) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_weaklist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_del) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_del)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_version_tag) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_version_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_finalize) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp_vectorcall) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_typeobject),
            "::",
            stringify!(tp_vectorcall)
        )
    );
}
impl Default for _typeobject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The *real* layout of a type object when allocated on the heap"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _heaptypeobject {
    #[doc = " Note: there's a dependency on the order of these members\nin slotptr() in typeobject.c ."]
    pub ht_type: PyTypeObject,
    pub as_async: PyAsyncMethods,
    pub as_number: PyNumberMethods,
    pub as_mapping: PyMappingMethods,
    #[doc = " as_sequence comes after as_mapping,\nso that the mapping wins when both\nthe mapping and the sequence define\na given operator (e.g. __getitem__).\nsee add_operators() in typeobject.c ."]
    pub as_sequence: PySequenceMethods,
    pub as_buffer: PyBufferProcs,
    pub ht_name: *mut PyObject,
    pub ht_slots: *mut PyObject,
    pub ht_qualname: *mut PyObject,
    pub ht_cached_keys: *mut _dictkeysobject,
    pub ht_module: *mut PyObject,
}
#[test]
fn bindgen_test_layout__heaptypeobject() {
    const UNINIT: ::std::mem::MaybeUninit<_heaptypeobject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_heaptypeobject>(),
        880usize,
        concat!("Size of: ", stringify!(_heaptypeobject))
    );
    assert_eq!(
        ::std::mem::align_of::<_heaptypeobject>(),
        8usize,
        concat!("Alignment of ", stringify!(_heaptypeobject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(ht_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_async) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(as_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_number) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(as_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_mapping) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(as_mapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_sequence) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(as_sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_buffer) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(as_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht_name) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(ht_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht_slots) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(ht_slots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht_qualname) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(ht_qualname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht_cached_keys) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(ht_cached_keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht_module) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(_heaptypeobject),
            "::",
            stringify!(ht_module)
        )
    );
}
impl Default for _heaptypeobject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The *real* layout of a type object when allocated on the heap"]
pub type PyHeapTypeObject = _heaptypeobject;
extern "C" {
    pub fn _PyType_Name(arg1: *mut PyTypeObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _PyType_Lookup(arg1: *mut PyTypeObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyType_LookupId(arg1: *mut PyTypeObject, arg2: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_LookupSpecial(arg1: *mut PyObject, arg2: *mut _Py_Identifier)
        -> *mut PyObject;
}
extern "C" {
    pub fn _PyType_CalculateMetaclass(
        arg1: *mut PyTypeObject,
        arg2: *mut PyObject,
    ) -> *mut PyTypeObject;
}
extern "C" {
    pub fn _PyType_GetDocFromInternalDoc(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyType_GetTextSignatureFromInternalDoc(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_Print(
        arg1: *mut PyObject,
        arg2: *mut FILE,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_BreakPoint();
}
extern "C" {
    pub fn _PyObject_Dump(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyObject_IsFreed(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_IsAbstract(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_GetAttrId(arg1: *mut PyObject, arg2: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_SetAttrId(
        arg1: *mut PyObject,
        arg2: *mut _Py_Identifier,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_HasAttrId(
        arg1: *mut PyObject,
        arg2: *mut _Py_Identifier,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replacements of PyObject_GetAttr() and _PyObject_GetAttrId() which\ndon't raise AttributeError.\n\nReturn 1 and set *result != NULL if an attribute is found.\nReturn 0 and set *result == NULL if an attribute is not found;\nan AttributeError is silenced.\nReturn -1 and set *result == NULL if an error other than AttributeError\nis raised."]
    pub fn _PyObject_LookupAttr(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_LookupAttrId(
        arg1: *mut PyObject,
        arg2: *mut _Py_Identifier,
        arg3: *mut *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_GetMethod(
        obj: *mut PyObject,
        name: *mut PyObject,
        method: *mut *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_GetDictPtr(arg1: *mut PyObject) -> *mut *mut PyObject;
}
extern "C" {
    pub fn _PyObject_NextNotImplemented(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_CallFinalizer(arg1: *mut PyObject);
}
extern "C" {
    pub fn PyObject_CallFinalizerFromDealloc(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as PyObject_Generic{Get,Set}Attr, but passing the attributes\ndict as the last parameter."]
    pub fn _PyObject_GenericGetAttrWithDict(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
        arg4: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_GenericSetAttrWithDict(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
        arg4: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_FunctionStr(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static mut _PyNone_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyNotImplemented_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.\n Defined in object.c."]
    pub static mut _Py_SwappedOp: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    pub fn _PyDebugAllocatorStats(
        out: *mut FILE,
        block_name: *const ::std::os::raw::c_char,
        num_blocks: ::std::os::raw::c_int,
        sizeof_block: usize,
    );
}
extern "C" {
    pub fn _PyObject_DebugTypeStats(out: *mut FILE);
}
extern "C" {
    #[doc = " Declare and define _PyObject_AssertFailed() even when NDEBUG is defined,\nto avoid causing compiler/linker errors when building extensions without\nNDEBUG against a Python built with NDEBUG defined.\n\nmsg, expr and function can be NULL."]
    pub fn _PyObject_AssertFailed(
        obj: *mut PyObject,
        expr: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " Check if an object is consistent. For example, ensure that the reference\ncounter is greater than or equal to 1, and ensure that ob_type is not NULL.\n\nCall _PyObject_AssertFailed() if the object is inconsistent.\n\nIf check_content is zero, only check header fields: reduce the overhead.\n\nThe function always return 1. The return value is just here to be able to\nwrite:\n\nassert(_PyObject_CheckConsistency(obj, 1));"]
    pub fn _PyObject_CheckConsistency(
        op: *mut PyObject,
        check_content: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This is the old private API, invoked by the macros before 3.2.4.\nKept for binary compatibility of extensions using the stable ABI."]
    pub fn _PyTrash_deposit_object(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyTrash_destroy_chain();
}
extern "C" {
    #[doc = " This is the old private API, invoked by the macros before 3.9.\nKept for binary compatibility of extensions using the stable ABI."]
    pub fn _PyTrash_thread_deposit_object(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyTrash_thread_destroy_chain();
}
extern "C" {
    #[doc = " Python 3.9 private API, invoked by the macros below."]
    pub fn _PyTrash_begin(tstate: *mut _ts, op: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyTrash_end(tstate: *mut _ts);
}
#[doc = " _PyTime_t: Python timestamp with subsecond precision. It can be used to\nstore a duration, and so indirectly a date (related to another date, like\nUNIX epoch)."]
pub type _PyTime_t = i64;
#[doc = " Round towards minus infinity (-inf).\nFor example, used to read a clock."]
pub const _PyTime_round_t__PyTime_ROUND_FLOOR: _PyTime_round_t = 0;
#[doc = " Round towards infinity (+inf).\nFor example, used for timeout to wait \"at least\" N seconds."]
pub const _PyTime_round_t__PyTime_ROUND_CEILING: _PyTime_round_t = 1;
#[doc = " Round to nearest with ties going to nearest even integer.\nFor example, used to round from a Python float."]
pub const _PyTime_round_t__PyTime_ROUND_HALF_EVEN: _PyTime_round_t = 2;
#[doc = " Round away from zero\nFor example, used for timeout. _PyTime_ROUND_CEILING rounds\n-1e-9 to 0 milliseconds which causes bpo-31786 issue.\n_PyTime_ROUND_UP rounds -1e-9 to -1 millisecond which keeps\nthe timeout sign as expected. select.poll(timeout) must block\nfor negative values.\""]
pub const _PyTime_round_t__PyTime_ROUND_UP: _PyTime_round_t = 3;
#[doc = " _PyTime_ROUND_TIMEOUT (an alias for _PyTime_ROUND_UP) should be\nused for timeouts."]
pub const _PyTime_round_t__PyTime_ROUND_TIMEOUT: _PyTime_round_t = 3;
pub type _PyTime_round_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Convert a time_t to a PyLong."]
    pub fn _PyLong_FromTime_t(sec: time_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Convert a PyLong to a time_t."]
    pub fn _PyLong_AsTime_t(obj: *mut PyObject) -> time_t;
}
extern "C" {
    #[doc = " Convert a number of seconds, int or float, to time_t."]
    pub fn _PyTime_ObjectToTime_t(
        obj: *mut PyObject,
        sec: *mut time_t,
        arg1: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a number of seconds, int or float, to a timeval structure.\nusec is in the range [0; 999999] and rounded towards zero.\nFor example, -1.2 is converted to (-2, 800000)."]
    pub fn _PyTime_ObjectToTimeval(
        obj: *mut PyObject,
        sec: *mut time_t,
        usec: *mut ::std::os::raw::c_long,
        arg1: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a number of seconds, int or float, to a timespec structure.\nnsec is in the range [0; 999999999] and rounded towards zero.\nFor example, -1.2 is converted to (-2, 800000000)."]
    pub fn _PyTime_ObjectToTimespec(
        obj: *mut PyObject,
        sec: *mut time_t,
        nsec: *mut ::std::os::raw::c_long,
        arg1: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a timestamp from a number of seconds."]
    pub fn _PyTime_FromSeconds(seconds: ::std::os::raw::c_int) -> _PyTime_t;
}
extern "C" {
    #[doc = " Create a timestamp from a number of nanoseconds."]
    pub fn _PyTime_FromNanoseconds(ns: _PyTime_t) -> _PyTime_t;
}
extern "C" {
    #[doc = " Create a timestamp from nanoseconds (Python int)."]
    pub fn _PyTime_FromNanosecondsObject(
        t: *mut _PyTime_t,
        obj: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a number of seconds (Python float or int) to a timestamp.\nRaise an exception and return -1 on error, return 0 on success."]
    pub fn _PyTime_FromSecondsObject(
        t: *mut _PyTime_t,
        obj: *mut PyObject,
        round: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a number of milliseconds (Python float or int, 10^-3) to a timestamp.\nRaise an exception and return -1 on error, return 0 on success."]
    pub fn _PyTime_FromMillisecondsObject(
        t: *mut _PyTime_t,
        obj: *mut PyObject,
        round: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a timestamp to a number of seconds as a C double."]
    pub fn _PyTime_AsSecondsDouble(t: _PyTime_t) -> f64;
}
extern "C" {
    #[doc = " Convert timestamp to a number of milliseconds (10^-3 seconds)."]
    pub fn _PyTime_AsMilliseconds(t: _PyTime_t, round: _PyTime_round_t) -> _PyTime_t;
}
extern "C" {
    #[doc = " Convert timestamp to a number of microseconds (10^-6 seconds)."]
    pub fn _PyTime_AsMicroseconds(t: _PyTime_t, round: _PyTime_round_t) -> _PyTime_t;
}
extern "C" {
    #[doc = " Convert timestamp to a number of nanoseconds (10^-9 seconds) as a Python int\nobject."]
    pub fn _PyTime_AsNanosecondsObject(t: _PyTime_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a timestamp from a timeval structure.\nRaise an exception and return -1 on overflow, return 0 on success."]
    pub fn _PyTime_FromTimeval(tp: *mut _PyTime_t, tv: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a timestamp to a timeval structure (microsecond resolution).\ntv_usec is always positive.\nRaise an exception and return -1 if the conversion overflowed,\nreturn 0 on success."]
    pub fn _PyTime_AsTimeval(
        t: _PyTime_t,
        tv: *mut timeval,
        round: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Similar to _PyTime_AsTimeval(), but don't raise an exception on error."]
    pub fn _PyTime_AsTimeval_noraise(
        t: _PyTime_t,
        tv: *mut timeval,
        round: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a timestamp to a number of seconds (secs) and microseconds (us).\nus is always positive. This function is similar to _PyTime_AsTimeval()\nexcept that secs is always a time_t type, whereas the timeval structure\nuses a C long for tv_sec on Windows.\nRaise an exception and return -1 if the conversion overflowed,\nreturn 0 on success."]
    pub fn _PyTime_AsTimevalTime_t(
        t: _PyTime_t,
        secs: *mut time_t,
        us: *mut ::std::os::raw::c_int,
        round: _PyTime_round_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a timestamp from a timespec structure.\nRaise an exception and return -1 on overflow, return 0 on success."]
    pub fn _PyTime_FromTimespec(tp: *mut _PyTime_t, ts: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a timestamp to a timespec structure (nanosecond resolution).\ntv_nsec is always positive.\nRaise an exception and return -1 on error, return 0 on success."]
    pub fn _PyTime_AsTimespec(t: _PyTime_t, ts: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute ticks * mul / div.\nThe caller must ensure that ((div - 1) * mul) cannot overflow."]
    pub fn _PyTime_MulDiv(ticks: _PyTime_t, mul: _PyTime_t, div: _PyTime_t) -> _PyTime_t;
}
extern "C" {
    #[doc = " Get the current time from the system clock.\n\nThe function cannot fail. _PyTime_Init() ensures that the system clock\nworks."]
    pub fn _PyTime_GetSystemClock() -> _PyTime_t;
}
extern "C" {
    #[doc = " Get the time of a monotonic clock, i.e. a clock that cannot go backwards.\nThe clock is not affected by system clock updates. The reference point of\nthe returned value is undefined, so that only the difference between the\nresults of consecutive calls is valid.\n\nThe function cannot fail. _PyTime_Init() ensures that a monotonic clock\nis available and works."]
    pub fn _PyTime_GetMonotonicClock() -> _PyTime_t;
}
#[doc = " Structure used by time.get_clock_info()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct _Py_clock_info_t {
    pub implementation: *const ::std::os::raw::c_char,
    pub monotonic: ::std::os::raw::c_int,
    pub adjustable: ::std::os::raw::c_int,
    pub resolution: f64,
}
#[test]
fn bindgen_test_layout__Py_clock_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_clock_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_clock_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(_Py_clock_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_clock_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_clock_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_clock_info_t),
            "::",
            stringify!(implementation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monotonic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_clock_info_t),
            "::",
            stringify!(monotonic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adjustable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_clock_info_t),
            "::",
            stringify!(adjustable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_clock_info_t),
            "::",
            stringify!(resolution)
        )
    );
}
impl Default for _Py_clock_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get the current time from the system clock.\n Fill clock information if info is not NULL.\n Raise an exception and return -1 on error, return 0 on success."]
    pub fn _PyTime_GetSystemClockWithInfo(
        t: *mut _PyTime_t,
        info: *mut _Py_clock_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the time of a monotonic clock, i.e. a clock that cannot go backwards.\nThe clock is not affected by system clock updates. The reference point of\nthe returned value is undefined, so that only the difference between the\nresults of consecutive calls is valid.\n\nFill info (if set) with information of the function used to get the time.\n\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyTime_GetMonotonicClockWithInfo(
        t: *mut _PyTime_t,
        info: *mut _Py_clock_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize time.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyTime_Init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a timestamp to the Gregorian time, using the local time zone.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyTime_localtime(t: time_t, tm: *mut tm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a timestamp to the Gregorian time, assuming UTC.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyTime_gmtime(t: time_t, tm: *mut tm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the performance counter: clock with the highest available resolution to\nmeasure a short duration.\n\nThe function cannot fail. _PyTime_Init() ensures that the system clock\nworks."]
    pub fn _PyTime_GetPerfCounter() -> _PyTime_t;
}
extern "C" {
    #[doc = " Get the performance counter: clock with the highest available resolution to\nmeasure a short duration.\n\nFill info (if set) with information of the function used to get the time.\n\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyTime_GetPerfCounterWithInfo(
        t: *mut _PyTime_t,
        info: *mut _Py_clock_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Functions\n\nFunctions supplying platform-independent semantics for malloc/realloc/\nfree.  These functions make sure that allocating 0 bytes returns a distinct\nnon-NULL pointer (whenever possible -- if we're flat out of memory, NULL\nmay be returned), even if the platform malloc and realloc don't.\nReturned pointers must be checked for NULL explicitly.  No action is\nperformed on failure (no exception is set, no warning is printed, etc)."]
    pub fn PyMem_Malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyMem_Realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyMem_Free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn PyMem_RawMalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyMem_RawCalloc(nelem: usize, elsize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyMem_RawRealloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyMem_RawFree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Try to get the allocators name set by _PyMem_SetupAllocators()."]
    pub fn _PyMem_GetCurrentAllocatorName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyMem_Calloc(nelem: usize, elsize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " strdup() using PyMem_RawMalloc()"]
    pub fn _PyMem_RawStrdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " strdup() using PyMem_Malloc()"]
    pub fn _PyMem_Strdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " wcsdup() using PyMem_RawMalloc()"]
    pub fn _PyMem_RawWcsdup(str_: *const wchar_t) -> *mut wchar_t;
}
#[doc = " PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree()"]
pub const PyMemAllocatorDomain_PYMEM_DOMAIN_RAW: PyMemAllocatorDomain = 0;
#[doc = " PyMem_Malloc(), PyMem_Realloc() and PyMem_Free()"]
pub const PyMemAllocatorDomain_PYMEM_DOMAIN_MEM: PyMemAllocatorDomain = 1;
#[doc = " PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()"]
pub const PyMemAllocatorDomain_PYMEM_DOMAIN_OBJ: PyMemAllocatorDomain = 2;
pub type PyMemAllocatorDomain = ::std::os::raw::c_uint;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_NOT_SET: PyMemAllocatorName = 0;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_DEFAULT: PyMemAllocatorName = 1;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_DEBUG: PyMemAllocatorName = 2;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_MALLOC: PyMemAllocatorName = 3;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_MALLOC_DEBUG: PyMemAllocatorName = 4;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_PYMALLOC: PyMemAllocatorName = 5;
pub const PyMemAllocatorName_PYMEM_ALLOCATOR_PYMALLOC_DEBUG: PyMemAllocatorName = 6;
pub type PyMemAllocatorName = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMemAllocatorEx {
    #[doc = " user context passed as the first argument to the 4 functions"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " allocate a memory block"]
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " allocate a memory block initialized by zeros"]
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            nelem: usize,
            elsize: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " allocate or resize a memory block"]
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            new_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " release a memory block"]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_PyMemAllocatorEx() {
    const UNINIT: ::std::mem::MaybeUninit<PyMemAllocatorEx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMemAllocatorEx>(),
        40usize,
        concat!("Size of: ", stringify!(PyMemAllocatorEx))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMemAllocatorEx>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMemAllocatorEx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemAllocatorEx),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemAllocatorEx),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemAllocatorEx),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemAllocatorEx),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemAllocatorEx),
            "::",
            stringify!(free)
        )
    );
}
impl Default for PyMemAllocatorEx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get the memory block allocator of the specified domain."]
    pub fn PyMem_GetAllocator(domain: PyMemAllocatorDomain, allocator: *mut PyMemAllocatorEx);
}
extern "C" {
    #[doc = " Set the memory block allocator of the specified domain.\n\nThe new allocator must return a distinct non-NULL pointer when requesting\nzero bytes.\n\nFor the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL\nis not held when the allocator is called.\n\nIf the new allocator is not a hook (don't call the previous allocator), the\nPyMem_SetupDebugHooks() function must be called to reinstall the debug hooks\non top on the new allocator."]
    pub fn PyMem_SetAllocator(domain: PyMemAllocatorDomain, allocator: *mut PyMemAllocatorEx);
}
extern "C" {
    #[doc = " Setup hooks to detect bugs in the following Python memory allocator\nfunctions:\n\n- PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()\n- PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()\n- PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()\n\nNewly allocated memory is filled with the byte 0xCB, freed memory is filled\nwith the byte 0xDB. Additional checks:\n\n- detect API violations, ex: PyObject_Free() called on a buffer allocated\nby PyMem_Malloc()\n- detect write before the start of the buffer (buffer underflow)\n- detect write after the end of the buffer (buffer overflow)\n\nThe function does nothing if Python is not compiled is debug mode."]
    pub fn PyMem_SetupDebugHooks();
}
extern "C" {
    #[doc = " Functions to call the same malloc/realloc/free as used by Python's\nobject allocator.  If WITH_PYMALLOC is enabled, these may differ from\nthe platform malloc/realloc/free.  The Python object allocator is\ndesigned for fast, cache-conscious allocation of many \"small\" objects,\nand with low hidden memory overhead.\n\nPyObject_Malloc(0) returns a unique non-NULL pointer if possible.\n\nPyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).\nPyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory\nat p.\n\nReturned pointers must be checked for NULL explicitly; no action is\nperformed on failure other than to return NULL (no warning it printed, no\nexception is set, etc).\n\nFor allocating objects, use PyObject_{New, NewVar} instead whenever\npossible.  The PyObject_{Malloc, Realloc, Free} family is exposed\nso that you can exploit Python's small-block allocator for non-object\nuses.  If you must use these routines to allocate object memory, make sure\nthe object gets initialized via PyObject_{Init, InitVar} after obtaining\nthe raw memory."]
    pub fn PyObject_Malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyObject_Calloc(nelem: usize, elsize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyObject_Realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyObject_Free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Functions"]
    pub fn PyObject_Init(arg1: *mut PyObject, arg2: *mut PyTypeObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_InitVar(
        arg1: *mut PyVarObject,
        arg2: *mut PyTypeObject,
        arg3: Py_ssize_t,
    ) -> *mut PyVarObject;
}
extern "C" {
    pub fn _PyObject_New(arg1: *mut PyTypeObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_NewVar(arg1: *mut PyTypeObject, arg2: Py_ssize_t) -> *mut PyVarObject;
}
extern "C" {
    #[doc = " C equivalent of gc.collect() which ignores the state of gc.enabled."]
    pub fn PyGC_Collect() -> Py_ssize_t;
}
extern "C" {
    pub fn _PyObject_GC_Resize(arg1: *mut PyVarObject, arg2: Py_ssize_t) -> *mut PyVarObject;
}
extern "C" {
    pub fn _PyObject_GC_New(arg1: *mut PyTypeObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_GC_NewVar(arg1: *mut PyTypeObject, arg2: Py_ssize_t) -> *mut PyVarObject;
}
extern "C" {
    #[doc = " Tell the GC to track this object.\n\n See also private _PyObject_GC_TRACK() macro."]
    pub fn PyObject_GC_Track(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Tell the GC to stop tracking this object.\n\n See also private _PyObject_GC_UNTRACK() macro."]
    pub fn PyObject_GC_UnTrack(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn PyObject_GC_Del(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn PyObject_GC_IsTracked(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_GC_IsFinalized(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function returns the number of allocated memory blocks, regardless of size"]
    pub fn _Py_GetAllocatedBlocks() -> Py_ssize_t;
}
extern "C" {
    pub fn _PyObject_DebugMallocStats(out: *mut FILE) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyObjectArenaAllocator {
    #[doc = " user context passed as the first argument to the 2 functions"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " allocate an arena of size bytes"]
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " free an arena"]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
        ),
    >,
}
#[test]
fn bindgen_test_layout_PyObjectArenaAllocator() {
    const UNINIT: ::std::mem::MaybeUninit<PyObjectArenaAllocator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyObjectArenaAllocator>(),
        24usize,
        concat!("Size of: ", stringify!(PyObjectArenaAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<PyObjectArenaAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(PyObjectArenaAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyObjectArenaAllocator),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyObjectArenaAllocator),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyObjectArenaAllocator),
            "::",
            stringify!(free)
        )
    );
}
impl Default for PyObjectArenaAllocator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get the arena allocator."]
    pub fn PyObject_GetArenaAllocator(allocator: *mut PyObjectArenaAllocator);
}
extern "C" {
    #[doc = " Set the arena allocator."]
    pub fn PyObject_SetArenaAllocator(allocator: *mut PyObjectArenaAllocator);
}
extern "C" {
    pub fn _PyGC_CollectNoFail() -> Py_ssize_t;
}
extern "C" {
    pub fn _PyGC_CollectIfEnabled() -> Py_ssize_t;
}
extern "C" {
    #[doc = " Test if an object implements the garbage collector protocol"]
    pub fn PyObject_IS_GC(obj: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_GC_Malloc(size: usize) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_GC_Calloc(size: usize) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_GET_WEAKREFS_LISTPTR(op: *mut PyObject) -> *mut *mut PyObject;
}
extern "C" {
    pub fn _Py_HashDouble(arg1: f64) -> Py_hash_t;
}
extern "C" {
    pub fn _Py_HashPointer(arg1: *const ::std::os::raw::c_void) -> Py_hash_t;
}
extern "C" {
    #[doc = " Similar to _Py_HashPointer(), but don't replace -1 with -2"]
    pub fn _Py_HashPointerRaw(arg1: *const ::std::os::raw::c_void) -> Py_hash_t;
}
extern "C" {
    pub fn _Py_HashBytes(arg1: *const ::std::os::raw::c_void, arg2: Py_ssize_t) -> Py_hash_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Py_HashSecret_t {
    #[doc = " ensure 24 bytes"]
    pub uc: [::std::os::raw::c_uchar; 24usize],
    pub fnv: _Py_HashSecret_t__bindgen_ty_1,
    pub siphash: _Py_HashSecret_t__bindgen_ty_2,
    pub djbx33a: _Py_HashSecret_t__bindgen_ty_3,
    pub expat: _Py_HashSecret_t__bindgen_ty_4,
}
#[doc = " two Py_hash_t for FNV"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Py_HashSecret_t__bindgen_ty_1 {
    pub prefix: Py_hash_t,
    pub suffix: Py_hash_t,
}
#[test]
fn bindgen_test_layout__Py_HashSecret_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_HashSecret_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_HashSecret_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_Py_HashSecret_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_HashSecret_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_HashSecret_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_1),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suffix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_1),
            "::",
            stringify!(suffix)
        )
    );
}
#[doc = " two uint64 for SipHash24"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Py_HashSecret_t__bindgen_ty_2 {
    pub k0: u64,
    pub k1: u64,
}
#[test]
fn bindgen_test_layout__Py_HashSecret_t__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_HashSecret_t__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_HashSecret_t__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_Py_HashSecret_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_HashSecret_t__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_HashSecret_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_2),
            "::",
            stringify!(k0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_2),
            "::",
            stringify!(k1)
        )
    );
}
#[doc = " a different (!) Py_hash_t for small string optimization"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Py_HashSecret_t__bindgen_ty_3 {
    pub padding: [::std::os::raw::c_uchar; 16usize],
    pub suffix: Py_hash_t,
}
#[test]
fn bindgen_test_layout__Py_HashSecret_t__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_HashSecret_t__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_HashSecret_t__bindgen_ty_3>(),
        24usize,
        concat!("Size of: ", stringify!(_Py_HashSecret_t__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_HashSecret_t__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_HashSecret_t__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_3),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suffix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_3),
            "::",
            stringify!(suffix)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Py_HashSecret_t__bindgen_ty_4 {
    pub padding: [::std::os::raw::c_uchar; 16usize],
    pub hashsalt: Py_hash_t,
}
#[test]
fn bindgen_test_layout__Py_HashSecret_t__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_HashSecret_t__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_HashSecret_t__bindgen_ty_4>(),
        24usize,
        concat!("Size of: ", stringify!(_Py_HashSecret_t__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_HashSecret_t__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_HashSecret_t__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_4),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashsalt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t__bindgen_ty_4),
            "::",
            stringify!(hashsalt)
        )
    );
}
#[test]
fn bindgen_test_layout__Py_HashSecret_t() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_HashSecret_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_HashSecret_t>(),
        24usize,
        concat!("Size of: ", stringify!(_Py_HashSecret_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_HashSecret_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_Py_HashSecret_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t),
            "::",
            stringify!(uc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fnv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t),
            "::",
            stringify!(fnv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).siphash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t),
            "::",
            stringify!(siphash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).djbx33a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t),
            "::",
            stringify!(djbx33a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_HashSecret_t),
            "::",
            stringify!(expat)
        )
    );
}
impl Default for _Py_HashSecret_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _Py_HashSecret: _Py_HashSecret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyHash_FuncDef {
    pub hash: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: Py_ssize_t) -> Py_hash_t,
    >,
    pub name: *const ::std::os::raw::c_char,
    pub hash_bits: ::std::os::raw::c_int,
    pub seed_bits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PyHash_FuncDef() {
    const UNINIT: ::std::mem::MaybeUninit<PyHash_FuncDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyHash_FuncDef>(),
        24usize,
        concat!("Size of: ", stringify!(PyHash_FuncDef))
    );
    assert_eq!(
        ::std::mem::align_of::<PyHash_FuncDef>(),
        8usize,
        concat!("Alignment of ", stringify!(PyHash_FuncDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyHash_FuncDef),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyHash_FuncDef),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_bits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyHash_FuncDef),
            "::",
            stringify!(hash_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed_bits) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PyHash_FuncDef),
            "::",
            stringify!(seed_bits)
        )
    );
}
impl Default for PyHash_FuncDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn PyHash_GetFuncDef() -> *mut PyHash_FuncDef;
}
extern "C" {
    pub static mut Py_DebugFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_VerboseFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_QuietFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_InteractiveFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_InspectFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_OptimizeFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_NoSiteFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_BytesWarningFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_FrozenFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_IgnoreEnvironmentFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_DontWriteBytecodeFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_NoUserSiteDirectory: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_UnbufferedStdioFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_HashRandomizationFlag: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_IsolatedFlag: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Type object"]
    pub static mut PyByteArray_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyByteArrayIter_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Direct API functions"]
    pub fn PyByteArray_FromObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyByteArray_Concat(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyByteArray_FromStringAndSize(
        arg1: *const ::std::os::raw::c_char,
        arg2: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyByteArray_Size(arg1: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyByteArray_AsString(arg1: *mut PyObject) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyByteArray_Resize(arg1: *mut PyObject, arg2: Py_ssize_t) -> ::std::os::raw::c_int;
}
#[doc = " Object layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyByteArrayObject {
    pub ob_base: PyVarObject,
    #[doc = " How many bytes allocated in ob_bytes"]
    pub ob_alloc: Py_ssize_t,
    #[doc = " Physical backing buffer"]
    pub ob_bytes: *mut ::std::os::raw::c_char,
    #[doc = " Logical start inside ob_bytes"]
    pub ob_start: *mut ::std::os::raw::c_char,
    #[doc = " How many buffer exports"]
    pub ob_exports: Py_ssize_t,
}
#[test]
fn bindgen_test_layout_PyByteArrayObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyByteArrayObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyByteArrayObject>(),
        56usize,
        concat!("Size of: ", stringify!(PyByteArrayObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyByteArrayObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyByteArrayObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyByteArrayObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_alloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyByteArrayObject),
            "::",
            stringify!(ob_alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_bytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyByteArrayObject),
            "::",
            stringify!(ob_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_start) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyByteArrayObject),
            "::",
            stringify!(ob_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_exports) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyByteArrayObject),
            "::",
            stringify!(ob_exports)
        )
    );
}
impl Default for PyByteArrayObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _PyByteArray_empty_string: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = " Caching the hash (ob_shash) saves recalculation of a string's hash value.\nThis significantly speeds up dict lookups."]
    pub static mut PyBytes_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyBytesIter_Type: PyTypeObject;
}
extern "C" {
    pub fn PyBytes_FromStringAndSize(
        arg1: *const ::std::os::raw::c_char,
        arg2: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyBytes_FromString(arg1: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyBytes_FromObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyBytes_FromFormatV(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyBytes_FromFormat(arg1: *const ::std::os::raw::c_char, ...) -> *mut PyObject;
}
extern "C" {
    pub fn PyBytes_Size(arg1: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyBytes_AsString(arg1: *mut PyObject) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyBytes_Repr(arg1: *mut PyObject, arg2: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    pub fn PyBytes_Concat(arg1: *mut *mut PyObject, arg2: *mut PyObject);
}
extern "C" {
    pub fn PyBytes_ConcatAndDel(arg1: *mut *mut PyObject, arg2: *mut PyObject);
}
extern "C" {
    pub fn PyBytes_DecodeEscape(
        arg1: *const ::std::os::raw::c_char,
        arg2: Py_ssize_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: Py_ssize_t,
        arg5: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Provides access to the internal data buffer and size of a string\nobject or the default encoded version of a Unicode object. Passing\nNULL as *len parameter will force the string buffer to be\n0-terminated (passing a string with embedded NULL characters will\ncause an exception)."]
    pub fn PyBytes_AsStringAndSize(
        obj: *mut PyObject,
        s: *mut *mut ::std::os::raw::c_char,
        len: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyBytesObject {
    pub ob_base: PyVarObject,
    pub ob_shash: Py_hash_t,
    pub ob_sval: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_PyBytesObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyBytesObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyBytesObject>(),
        40usize,
        concat!("Size of: ", stringify!(PyBytesObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyBytesObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyBytesObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBytesObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_shash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBytesObject),
            "::",
            stringify!(ob_shash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_sval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBytesObject),
            "::",
            stringify!(ob_sval)
        )
    );
}
impl Default for PyBytesObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyBytes_Resize(arg1: *mut *mut PyObject, arg2: Py_ssize_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyBytes_FormatEx(
        format: *const ::std::os::raw::c_char,
        format_len: Py_ssize_t,
        args: *mut PyObject,
        use_bytearray: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyBytes_FromHex(
        string: *mut PyObject,
        use_bytearray: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Helper for PyBytes_DecodeEscape that detects invalid escape chars."]
    pub fn _PyBytes_DecodeEscape(
        arg1: *const ::std::os::raw::c_char,
        arg2: Py_ssize_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " _PyBytes_Join(sep, x) is like sep.join(x).  sep must be PyBytesObject*,\nx must be an iterable object."]
    pub fn _PyBytes_Join(sep: *mut PyObject, x: *mut PyObject) -> *mut PyObject;
}
#[doc = " The _PyBytesWriter structure is big: it contains an embedded \"stack buffer\".\nA _PyBytesWriter variable must be declared at the end of variables in a\nfunction to optimize the memory allocation on the stack."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyBytesWriter {
    #[doc = " bytes, bytearray or NULL (when the small buffer is used)"]
    pub buffer: *mut PyObject,
    #[doc = " Number of allocated size."]
    pub allocated: Py_ssize_t,
    #[doc = " Minimum number of allocated bytes,\nincremented by _PyBytesWriter_Prepare()"]
    pub min_size: Py_ssize_t,
    #[doc = " If non-zero, use a bytearray instead of a bytes object for buffer."]
    pub use_bytearray: ::std::os::raw::c_int,
    #[doc = " If non-zero, overallocate the buffer (default: 0).\nThis flag must be zero if use_bytearray is non-zero."]
    pub overallocate: ::std::os::raw::c_int,
    #[doc = " Stack buffer"]
    pub use_small_buffer: ::std::os::raw::c_int,
    pub small_buffer: [::std::os::raw::c_char; 512usize],
}
#[test]
fn bindgen_test_layout__PyBytesWriter() {
    const UNINIT: ::std::mem::MaybeUninit<_PyBytesWriter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyBytesWriter>(),
        552usize,
        concat!("Size of: ", stringify!(_PyBytesWriter))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyBytesWriter>(),
        8usize,
        concat!("Alignment of ", stringify!(_PyBytesWriter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(min_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_bytearray) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(use_bytearray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overallocate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(overallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_small_buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(use_small_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).small_buffer) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyBytesWriter),
            "::",
            stringify!(small_buffer)
        )
    );
}
impl Default for _PyBytesWriter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initialize a bytes writer\n\nBy default, the overallocation is disabled. Set the overallocate attribute\nto control the allocation of the buffer."]
    pub fn _PyBytesWriter_Init(writer: *mut _PyBytesWriter);
}
extern "C" {
    #[doc = " Get the buffer content and reset the writer.\nReturn a bytes object, or a bytearray object if use_bytearray is non-zero.\nRaise an exception and return NULL on error."]
    pub fn _PyBytesWriter_Finish(
        writer: *mut _PyBytesWriter,
        str_: *mut ::std::os::raw::c_void,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Deallocate memory of a writer (clear its internal buffer)."]
    pub fn _PyBytesWriter_Dealloc(writer: *mut _PyBytesWriter);
}
extern "C" {
    #[doc = " Allocate the buffer to write size bytes.\nReturn the pointer to the beginning of buffer data.\nRaise an exception and return NULL on error."]
    pub fn _PyBytesWriter_Alloc(
        writer: *mut _PyBytesWriter,
        size: Py_ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Ensure that the buffer is large enough to write *size* bytes.\nAdd size to the writer minimum size (min_size attribute).\n\nstr is the current pointer inside the buffer.\nReturn the updated current pointer inside the buffer.\nRaise an exception and return NULL on error."]
    pub fn _PyBytesWriter_Prepare(
        writer: *mut _PyBytesWriter,
        str_: *mut ::std::os::raw::c_void,
        size: Py_ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Resize the buffer to make it larger.\nThe new buffer may be larger than size bytes because of overallocation.\nReturn the updated current pointer inside the buffer.\nRaise an exception and return NULL on error.\n\nNote: size must be greater than the number of allocated bytes in the writer.\n\nThis function doesn't use the writer minimum size (min_size attribute).\n\nSee also _PyBytesWriter_Prepare()."]
    pub fn _PyBytesWriter_Resize(
        writer: *mut _PyBytesWriter,
        str_: *mut ::std::os::raw::c_void,
        size: Py_ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Write bytes.\nRaise an exception and return NULL on error."]
    pub fn _PyBytesWriter_WriteBytes(
        writer: *mut _PyBytesWriter,
        str_: *mut ::std::os::raw::c_void,
        bytes: *const ::std::os::raw::c_void,
        size: Py_ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " UPPERCASE."]
pub const _ISupper: _bindgen_ty_5 = 256;
#[doc = " lowercase."]
pub const _ISlower: _bindgen_ty_5 = 512;
#[doc = " Alphabetic."]
pub const _ISalpha: _bindgen_ty_5 = 1024;
#[doc = " Numeric."]
pub const _ISdigit: _bindgen_ty_5 = 2048;
#[doc = " Hexadecimal numeric."]
pub const _ISxdigit: _bindgen_ty_5 = 4096;
#[doc = " Whitespace."]
pub const _ISspace: _bindgen_ty_5 = 8192;
#[doc = " Printing."]
pub const _ISprint: _bindgen_ty_5 = 16384;
#[doc = " Graphical."]
pub const _ISgraph: _bindgen_ty_5 = 32768;
#[doc = " Blank (usually SPC and TAB)."]
pub const _ISblank: _bindgen_ty_5 = 1;
#[doc = " Control character."]
pub const _IScntrl: _bindgen_ty_5 = 2;
#[doc = " Punctuation."]
pub const _ISpunct: _bindgen_ty_5 = 4;
#[doc = " Alphanumeric."]
pub const _ISalnum: _bindgen_ty_5 = 8;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " These are defined in ctype-info.c.\nThe declarations here must match those in localeinfo.h.\n\nIn the thread-specific locale model (see `uselocale' in <locale.h>)\nwe cannot use global variables for these as was done in the past.\nInstead, the following accessor functions return the address of\neach variable, which is local to the current thread if multithreaded.\n\nThese point into arrays of 384, so they can be indexed by any `unsigned\nchar' value [0,255]; by EOF (-1); or by any `signed char' value\n[-128,-1).  ISO C requires that the ctype functions work for `unsigned\nchar' values and for EOF; we also support negative `signed char' values\nfor broken old programs.  The case conversion arrays are of `int's\nrather than `unsigned char's because tolower (EOF) must be EOF, which\ndoesn't fit into an `unsigned char'.  But today more important is that\nthe arrays are also used for multi-byte character sets."]
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the lowercase version of C."]
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the uppercase version of C."]
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return nonzero iff C is in the ASCII set\n(i.e., is no more than 7 bits wide)."]
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the part of C that is in the ASCII set\n(i.e., the low-order 7 bits of C)."]
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the lowercase version of C in locale L."]
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the uppercase version of C."]
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
pub type wint_t = ::std::os::raw::c_uint;
#[doc = " Conversion state information."]
pub type mbstate_t = __mbstate_t;
extern "C" {
    #[doc = " Copy SRC to DEST."]
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Copy no more than N wide-characters of SRC to DEST."]
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Append SRC onto DEST."]
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Append no more than N wide-characters of SRC onto DEST."]
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Compare S1 and S2."]
    pub fn wcscmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare N wide-characters of S1 and S2."]
    pub fn wcsncmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare S1 and S2, ignoring case."]
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare no more than N chars of S1 and S2, ignoring case."]
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Similar to the two functions above but take the information from\nthe provided locale and not the global locale."]
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare S1 and S2, both interpreted as appropriate to the\nLC_COLLATE category of the current locale."]
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Transform S2 into array pointed to by S1 such that if wcscmp is\napplied to two transformed strings the result is the as applying\n`wcscoll' to the original strings."]
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    #[doc = " Compare S1 and S2, both interpreted as appropriate to the\nLC_COLLATE category of the given locale."]
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Transform S2 into array pointed to by S1 such that if wcscmp is\napplied to two transformed strings the result is the as applying\n`wcscoll' to the original strings."]
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Duplicate S, returning an identical malloc'd string."]
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(
        __wcs: *const ::std::os::raw::c_int,
        __wc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Return the length of the initial segmet of WCS which\nconsists entirely of wide characters not in REJECT."]
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    #[doc = " Return the length of the initial segmet of WCS which\nconsists entirely of wide characters in  ACCEPT."]
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Divide WCS into tokens separated by characters in DELIM."]
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Return the number of wide characters in S."]
    pub fn wcslen(__s: *const ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Return the number of wide characters in S, but at most MAXLEN."]
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(
        __s: *const ::std::os::raw::c_int,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare N wide characters of S1 and S2."]
    pub fn wmemcmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy N wide characters of SRC to DEST."]
    pub fn wmemcpy(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy N wide characters of SRC to DEST, guaranteeing\ncorrect behavior for overlapping strings."]
    pub fn wmemmove(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set N wide characters of S to C."]
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Determine whether C constitutes a valid (one-byte) multibyte\ncharacter."]
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    #[doc = " Determine whether C corresponds to a member of the extended\ncharacter set whose multibyte representation is a single byte."]
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine whether PS points to an object representing the initial\nstate."]
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write wide character representation of multibyte character pointed\nto by S to PWC."]
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Write multibyte representation of wide character WC to S."]
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    #[doc = " Return number of bytes in multibyte character pointed to by S."]
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    #[doc = " Write wide character representation of multibyte character string\nSRC to DST."]
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Write multibyte character representation of wide character string\nSRC to DST."]
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Write wide character representation of at most NMC bytes of the\nmultibyte character string SRC to DST."]
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Write multibyte character representation of at most NWC characters\nfrom the wide character string SRC to DST."]
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Convert initial portion of the wide string NPTR to `double'\nrepresentation."]
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    #[doc = " Likewise for `float' and `long double' sizes of floating-point numbers."]
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `long int'\nrepresentation."]
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `unsigned long int'\nrepresentation."]
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `long long int'\nrepresentation."]
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `unsigned long long int'\nrepresentation."]
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Copy SRC to DEST, returning the address of the terminating L'\\0' in\nDEST."]
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Copy no more than N characters of SRC to DEST, returning the address of\nthe last character written into DEST."]
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Like OPEN_MEMSTREAM, but the stream is wide oriented and produces\na wide character string."]
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize) -> *mut __FILE;
}
extern "C" {
    #[doc = " Select orientation for stream."]
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output of at most N characters to S."]
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output of at most N character to S from argument\nlist ARG."]
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a character from STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    #[doc = " Read a character from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getwchar() -> wint_t;
}
extern "C" {
    #[doc = " Write a character to STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    #[doc = " Write a character to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    #[doc = " Get a newline-terminated wide character string of finite length\nfrom STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Write a string to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Push a character back onto the input buffer of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT.\nWrite no more than MAXSIZE wide characters and return the number\nof wide characters written, or 0 if it would exceed MAXSIZE."]
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
#[doc = " Py_UCS4 and Py_UCS2 are typedefs for the respective\nunicode representations."]
pub type Py_UCS4 = u32;
pub type Py_UCS2 = u16;
pub type Py_UCS1 = u8;
extern "C" {
    pub static mut PyUnicode_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyUnicodeIter_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes"]
    pub fn PyUnicode_FromStringAndSize(
        u: *const ::std::os::raw::c_char,
        size: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Similar to PyUnicode_FromUnicode(), but u points to null-terminated\nUTF-8 encoded bytes.  The size is determined with strlen()."]
    pub fn PyUnicode_FromString(u: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_Substring(
        str_: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Copy the string into a UCS4 buffer including the null character if copy_null\nis set. Return NULL and raise an exception on error. Raise a SystemError if\nthe buffer is smaller than the string. Return buffer on success.\n\nbuflen is the length of the buffer in (Py_UCS4) characters."]
    pub fn PyUnicode_AsUCS4(
        unicode: *mut PyObject,
        buffer: *mut Py_UCS4,
        buflen: Py_ssize_t,
        copy_null: ::std::os::raw::c_int,
    ) -> *mut Py_UCS4;
}
extern "C" {
    #[doc = " Copy the string into a UCS4 buffer. A new buffer is allocated using\n PyMem_Malloc; if this fails, NULL is returned with a memory error\nexception set."]
    pub fn PyUnicode_AsUCS4Copy(unicode: *mut PyObject) -> *mut Py_UCS4;
}
extern "C" {
    #[doc = " Get the length of the Unicode object."]
    pub fn PyUnicode_GetLength(unicode: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Get the number of Py_UNICODE units in the\nstring representation."]
    pub fn PyUnicode_GetSize(unicode: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Read a character from the string."]
    pub fn PyUnicode_ReadChar(unicode: *mut PyObject, index: Py_ssize_t) -> Py_UCS4;
}
extern "C" {
    #[doc = " Write a character to the string. The string must have been created through\nPyUnicode_New, must not be shared, and must not have been hashed yet.\n\nReturn 0 on success, -1 on error."]
    pub fn PyUnicode_WriteChar(
        unicode: *mut PyObject,
        index: Py_ssize_t,
        character: Py_UCS4,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resize a Unicode object. The length is the number of characters, except\nif the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length\nis the number of Py_UNICODE characters.\n\nunicode is modified to point to the new (resized) object and 0\nreturned on success.\n\nTry to resize the string in place (which is usually faster than allocating\na new string and copy characters), or create a new string.\n\nError handling is implemented as follows: an exception is set, -1\nis returned and *unicode left untouched.\n\nWARNING: The function doesn't check string content, the result may not be a\nstring in canonical representation."]
    pub fn PyUnicode_Resize(
        unicode: *mut *mut PyObject,
        length: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode obj to a Unicode object.\n\nbytes, bytearray and other bytes-like objects are decoded according to the\ngiven encoding and error handler. The encoding and error handler can be\nNULL to have the interface use UTF-8 and \"strict\".\n\nAll other objects (including Unicode objects) raise an exception.\n\nThe API returns NULL in case of an error. The caller is responsible\nfor decref'ing the returned objects."]
    pub fn PyUnicode_FromEncodedObject(
        obj: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Copy an instance of a Unicode subtype to a new true Unicode object if\nnecessary. If obj is already a true Unicode object (not a subtype), return\nthe reference with *incremented* refcount.\n\nThe API returns NULL in case of an error. The caller is responsible\nfor decref'ing the returned objects."]
    pub fn PyUnicode_FromObject(obj: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_FromFormatV(
        format: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_FromFormat(format: *const ::std::os::raw::c_char, ...) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_InternInPlace(arg1: *mut *mut PyObject);
}
extern "C" {
    pub fn PyUnicode_InternImmortal(arg1: *mut *mut PyObject);
}
extern "C" {
    pub fn PyUnicode_InternFromString(u: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a Unicode Object from the wchar_t buffer w of the given\nsize.\n\nThe buffer is copied into the new object."]
    pub fn PyUnicode_FromWideChar(w: *const wchar_t, size: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Copies the Unicode Object contents into the wchar_t buffer w.  At\nmost size wchar_t characters are copied.\n\nNote that the resulting wchar_t string may or may not be\n0-terminated.  It is the responsibility of the caller to make sure\nthat the wchar_t string is 0-terminated in case this is required by\nthe application.\n\nReturns the number of wchar_t characters copied (excluding a\npossibly trailing 0-termination character) or -1 in case of an\nerror."]
    pub fn PyUnicode_AsWideChar(
        unicode: *mut PyObject,
        w: *mut wchar_t,
        size: Py_ssize_t,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Convert the Unicode object to a wide character string. The output string\nalways ends with a nul character. If size is not NULL, write the number of\nwide characters (excluding the null character) into *size.\n\nReturns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)\non success. On error, returns NULL, *size is undefined and raises a\nMemoryError."]
    pub fn PyUnicode_AsWideCharString(
        unicode: *mut PyObject,
        size: *mut Py_ssize_t,
    ) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Create a Unicode Object from the given Unicode code point ordinal.\n\nThe ordinal must be in range(0x110000). A ValueError is\nraised in case it is not."]
    pub fn PyUnicode_FromOrdinal(ordinal: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns \"utf-8\"."]
    pub fn PyUnicode_GetDefaultEncoding() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a Unicode object by decoding the encoded string s of the\ngiven size."]
    pub fn PyUnicode_Decode(
        s: *const ::std::os::raw::c_char,
        size: Py_ssize_t,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Decode a Unicode object unicode and return the result as Python\nobject.\n\nThis API is DEPRECATED. The only supported standard encoding is rot13.\nUse PyCodec_Decode() to decode with rot13 and non-standard codecs\nthat decode from str."]
    pub fn PyUnicode_AsDecodedObject(
        unicode: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Decode a Unicode object unicode and return the result as Unicode\nobject.\n\nThis API is DEPRECATED. The only supported standard encoding is rot13.\nUse PyCodec_Decode() to decode with rot13 and non-standard codecs\nthat decode from str to str."]
    pub fn PyUnicode_AsDecodedUnicode(
        unicode: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Encodes a Unicode object and returns the result as Python\nobject.\n\nThis API is DEPRECATED.  It is superseded by PyUnicode_AsEncodedString()\nsince all standard encodings (except rot13) encode str to bytes.\nUse PyCodec_Encode() for encoding with rot13 and non-standard codecs\nthat encode form str to non-bytes."]
    pub fn PyUnicode_AsEncodedObject(
        unicode: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Encodes a Unicode object and returns the result as Python string\nobject."]
    pub fn PyUnicode_AsEncodedString(
        unicode: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Encodes a Unicode object and returns the result as Unicode\nobject.\n\nThis API is DEPRECATED.  The only supported standard encodings is rot13.\nUse PyCodec_Encode() to encode with rot13 and non-standard codecs\nthat encode from str to str."]
    pub fn PyUnicode_AsEncodedUnicode(
        unicode: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Build an encoding map."]
    pub fn PyUnicode_BuildEncodingMap(string: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- UTF-7 Codecs -------------------------------------------------------"]
    pub fn PyUnicode_DecodeUTF7(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_DecodeUTF7Stateful(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        consumed: *mut Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- UTF-8 Codecs -------------------------------------------------------"]
    pub fn PyUnicode_DecodeUTF8(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_DecodeUTF8Stateful(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        consumed: *mut Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_AsUTF8String(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Decodes length bytes from a UTF-32 encoded buffer string and returns\nthe corresponding Unicode object.\n\nerrors (if non-NULL) defines the error handling. It defaults\nto \"strict\".\n\nIf byteorder is non-NULL, the decoder starts decoding using the\ngiven byte order:\n\nbyteorder == -1: little endian\nbyteorder == 0:  native order\nbyteorder == 1:  big endian\n\nIn native mode, the first four bytes of the stream are checked for a\nBOM mark. If found, the BOM mark is analysed, the byte order\nadjusted and the BOM skipped.  In the other modes, no BOM mark\ninterpretation is done. After completion, *byteorder is set to the\ncurrent byte order at the end of input data.\n\nIf byteorder is NULL, the codec starts in native order mode."]
    pub fn PyUnicode_DecodeUTF32(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        byteorder: *mut ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_DecodeUTF32Stateful(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        byteorder: *mut ::std::os::raw::c_int,
        consumed: *mut Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns a Python string using the UTF-32 encoding in native byte\norder. The string always starts with a BOM mark."]
    pub fn PyUnicode_AsUTF32String(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Decodes length bytes from a UTF-16 encoded buffer string and returns\nthe corresponding Unicode object.\n\nerrors (if non-NULL) defines the error handling. It defaults\nto \"strict\".\n\nIf byteorder is non-NULL, the decoder starts decoding using the\ngiven byte order:\n\nbyteorder == -1: little endian\nbyteorder == 0:  native order\nbyteorder == 1:  big endian\n\nIn native mode, the first two bytes of the stream are checked for a\nBOM mark. If found, the BOM mark is analysed, the byte order\nadjusted and the BOM skipped.  In the other modes, no BOM mark\ninterpretation is done. After completion, *byteorder is set to the\ncurrent byte order at the end of input data.\n\nIf byteorder is NULL, the codec starts in native order mode."]
    pub fn PyUnicode_DecodeUTF16(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        byteorder: *mut ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_DecodeUTF16Stateful(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        byteorder: *mut ::std::os::raw::c_int,
        consumed: *mut Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns a Python string using the UTF-16 encoding in native byte\norder. The string always starts with a BOM mark."]
    pub fn PyUnicode_AsUTF16String(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Unicode-Escape Codecs ----------------------------------------------"]
    pub fn PyUnicode_DecodeUnicodeEscape(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_AsUnicodeEscapeString(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Raw-Unicode-Escape Codecs ------------------------------------------"]
    pub fn PyUnicode_DecodeRawUnicodeEscape(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_AsRawUnicodeEscapeString(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Latin-1 Codecs -----------------------------------------------------\n\nNote: Latin-1 corresponds to the first 256 Unicode ordinals."]
    pub fn PyUnicode_DecodeLatin1(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_AsLatin1String(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- ASCII Codecs -------------------------------------------------------\n\nOnly 7-bit ASCII data is excepted. All other codes generate errors."]
    pub fn PyUnicode_DecodeASCII(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_AsASCIIString(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Character Map Codecs -----------------------------------------------\n\nThis codec uses mappings to encode and decode characters.\n\nDecoding mappings must map byte ordinals (integers in the range from 0 to\n255) to Unicode strings, integers (which are then interpreted as Unicode\nordinals) or None.  Unmapped data bytes (ones which cause a LookupError)\nas well as mapped to None, 0xFFFE or '\\ufffe' are treated as \"undefined\nmapping\" and cause an error.\n\nEncoding mappings must map Unicode ordinal integers to bytes objects,\nintegers in the range from 0 to 255 or None.  Unmapped character\nordinals (ones which cause a LookupError) as well as mapped to\nNone are treated as \"undefined mapping\" and cause an error."]
    pub fn PyUnicode_DecodeCharmap(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        mapping: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_AsCharmapString(
        unicode: *mut PyObject,
        mapping: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Decode a string from the current locale encoding. The decoder is strict if\nsurrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'\nerror handler (PEP 383) to escape undecodable bytes. If a byte sequence can\nbe decoded as a surrogate character and *surrogateescape* is not equal to\nzero, the byte sequence is escaped using the 'surrogateescape' error handler\ninstead of being decoded. *str* must end with a null character but cannot\ncontain embedded null characters."]
    pub fn PyUnicode_DecodeLocaleAndSize(
        str_: *const ::std::os::raw::c_char,
        len: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string\nlength using strlen()."]
    pub fn PyUnicode_DecodeLocale(
        str_: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Encode a Unicode object to the current locale encoding. The encoder is\nstrict is *surrogateescape* is equal to zero, otherwise the\n\"surrogateescape\" error handler is used. Return a bytes object. The string\ncannot contain embedded null characters."]
    pub fn PyUnicode_EncodeLocale(
        unicode: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " ParseTuple converter: encode str objects to bytes using\nPyUnicode_EncodeFSDefault(); bytes objects are output as-is."]
    pub fn PyUnicode_FSConverter(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ParseTuple converter: decode bytes objects to unicode using\nPyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is."]
    pub fn PyUnicode_FSDecoder(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a null-terminated string using Py_FileSystemDefaultEncoding\nand the \"surrogateescape\" error handler.\n\nIf Py_FileSystemDefaultEncoding is not set, fall back to the locale\nencoding.\n\nUse PyUnicode_DecodeFSDefaultAndSize() if the string length is known."]
    pub fn PyUnicode_DecodeFSDefault(s: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    #[doc = " Decode a string using Py_FileSystemDefaultEncoding\nand the \"surrogateescape\" error handler.\n\nIf Py_FileSystemDefaultEncoding is not set, fall back to the locale\nencoding."]
    pub fn PyUnicode_DecodeFSDefaultAndSize(
        s: *const ::std::os::raw::c_char,
        size: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Encode a Unicode object to Py_FileSystemDefaultEncoding with the\n\"surrogateescape\" error handler, and return bytes.\n\nIf Py_FileSystemDefaultEncoding is not set, fall back to the locale\nencoding."]
    pub fn PyUnicode_EncodeFSDefault(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Concat two strings giving a new Unicode string."]
    pub fn PyUnicode_Concat(left: *mut PyObject, right: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Concat two strings and put the result in *pleft\n(sets *pleft to NULL on error)"]
    pub fn PyUnicode_Append(pleft: *mut *mut PyObject, right: *mut PyObject);
}
extern "C" {
    #[doc = " Concat two strings, put the result in *pleft and drop the right object\n(sets *pleft to NULL on error)"]
    pub fn PyUnicode_AppendAndDel(pleft: *mut *mut PyObject, right: *mut PyObject);
}
extern "C" {
    #[doc = " Split a string giving a list of Unicode strings.\n\nIf sep is NULL, splitting will be done at all whitespace\nsubstrings. Otherwise, splits occur at the given separator.\n\nAt most maxsplit splits will be done. If negative, no limit is set.\n\nSeparators are not included in the resulting list."]
    pub fn PyUnicode_Split(
        s: *mut PyObject,
        sep: *mut PyObject,
        maxsplit: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Dito, but split at line breaks.\n\nCRLF is considered to be one line break. Line breaks are not\nincluded in the resulting list."]
    pub fn PyUnicode_Splitlines(s: *mut PyObject, keepends: ::std::os::raw::c_int)
        -> *mut PyObject;
}
extern "C" {
    #[doc = " Partition a string using a given separator."]
    pub fn PyUnicode_Partition(s: *mut PyObject, sep: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Partition a string using a given separator, searching from the end of the\nstring."]
    pub fn PyUnicode_RPartition(s: *mut PyObject, sep: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Split a string giving a list of Unicode strings.\n\nIf sep is NULL, splitting will be done at all whitespace\nsubstrings. Otherwise, splits occur at the given separator.\n\nAt most maxsplit splits will be done. But unlike PyUnicode_Split\nPyUnicode_RSplit splits from the end of the string. If negative,\nno limit is set.\n\nSeparators are not included in the resulting list."]
    pub fn PyUnicode_RSplit(
        s: *mut PyObject,
        sep: *mut PyObject,
        maxsplit: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Translate a string by applying a character mapping table to it and\nreturn the resulting Unicode object.\n\nThe mapping table must map Unicode ordinal integers to Unicode strings,\nUnicode ordinal integers or None (causing deletion of the character).\n\nMapping tables may be dictionaries or sequences. Unmapped character\nordinals (ones which cause a LookupError) are left untouched and\nare copied as-is."]
    pub fn PyUnicode_Translate(
        str_: *mut PyObject,
        table: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Join a sequence of strings using the given separator and return\nthe resulting Unicode string."]
    pub fn PyUnicode_Join(separator: *mut PyObject, seq: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return 1 if substr matches str[start:end] at the given tail end, 0\notherwise."]
    pub fn PyUnicode_Tailmatch(
        str_: *mut PyObject,
        substr: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
        direction: ::std::os::raw::c_int,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Return the first position of substr in str[start:end] using the\ngiven search direction or -1 if not found. -2 is returned in case\nan error occurred and an exception is set."]
    pub fn PyUnicode_Find(
        str_: *mut PyObject,
        substr: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
        direction: ::std::os::raw::c_int,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Like PyUnicode_Find, but search for single character only."]
    pub fn PyUnicode_FindChar(
        str_: *mut PyObject,
        ch: Py_UCS4,
        start: Py_ssize_t,
        end: Py_ssize_t,
        direction: ::std::os::raw::c_int,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Count the number of occurrences of substr in str[start:end]."]
    pub fn PyUnicode_Count(
        str_: *mut PyObject,
        substr: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Replace at most maxcount occurrences of substr in str with replstr\nand return the resulting Unicode object."]
    pub fn PyUnicode_Replace(
        str_: *mut PyObject,
        substr: *mut PyObject,
        replstr: *mut PyObject,
        maxcount: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Compare two strings and return -1, 0, 1 for less than, equal,\ngreater than resp.\nRaise an exception and return -1 on error."]
    pub fn PyUnicode_Compare(left: *mut PyObject, right: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare a Unicode object with C string and return -1, 0, 1 for less than,\nequal, and greater than, respectively.  It is best to pass only\nASCII-encoded strings, but the function interprets the input string as\nISO-8859-1 if it contains non-ASCII characters.\nThis function does not raise exceptions."]
    pub fn PyUnicode_CompareWithASCIIString(
        left: *mut PyObject,
        right: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rich compare two strings and return one of the following:\n\n- NULL in case an exception was raised\n- Py_True or Py_False for successful comparisons\n- Py_NotImplemented in case the type combination is unknown\n\nPossible values for op:\n\nPy_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE"]
    pub fn PyUnicode_RichCompare(
        left: *mut PyObject,
        right: *mut PyObject,
        op: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Apply an argument tuple or dictionary to a format string and return\nthe resulting Unicode string."]
    pub fn PyUnicode_Format(format: *mut PyObject, args: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Checks whether element is contained in container and return 1/0\naccordingly.\n\nelement has to coerce to a one element Unicode string. -1 is\nreturned in case of an error."]
    pub fn PyUnicode_Contains(
        container: *mut PyObject,
        element: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether argument is a valid identifier."]
    pub fn PyUnicode_IsIdentifier(s: *mut PyObject) -> ::std::os::raw::c_int;
}
#[doc = " Py_DEPRECATED(3.3)"]
pub type Py_UNICODE = wchar_t;
#[doc = " ASCII-only strings created through PyUnicode_New use the PyASCIIObject\nstructure. state.ascii and state.compact are set, and the data\nimmediately follow the structure. utf8_length and wstr_length can be found\nin the length field; the utf8 pointer is equal to the data pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyASCIIObject {
    pub ob_base: PyObject,
    #[doc = " Number of code points in the string"]
    pub length: Py_ssize_t,
    #[doc = " Hash value; -1 if not set"]
    pub hash: Py_hash_t,
    pub state: PyASCIIObject__bindgen_ty_1,
    #[doc = " wchar_t representation (null-terminated)"]
    pub wstr: *mut wchar_t,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyASCIIObject__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PyASCIIObject__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PyASCIIObject__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PyASCIIObject__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<PyASCIIObject__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PyASCIIObject__bindgen_ty_1))
    );
}
impl PyASCIIObject__bindgen_ty_1 {
    #[inline]
    pub fn interned(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn kind(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn compact(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ascii(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ready(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interned: ::std::os::raw::c_uint,
        kind: ::std::os::raw::c_uint,
        compact: ::std::os::raw::c_uint,
        ascii: ::std::os::raw::c_uint,
        ready: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let interned: u32 = unsafe { ::std::mem::transmute(interned) };
            interned as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let compact: u32 = unsafe { ::std::mem::transmute(compact) };
            compact as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };
            ascii as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ready: u32 = unsafe { ::std::mem::transmute(ready) };
            ready as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PyASCIIObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyASCIIObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyASCIIObject>(),
        48usize,
        concat!("Size of: ", stringify!(PyASCIIObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyASCIIObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyASCIIObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyASCIIObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyASCIIObject),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyASCIIObject),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyASCIIObject),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wstr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyASCIIObject),
            "::",
            stringify!(wstr)
        )
    );
}
impl Default for PyASCIIObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Non-ASCII strings allocated through PyUnicode_New use the\nPyCompactUnicodeObject structure. state.compact is set, and the data\nimmediately follow the structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCompactUnicodeObject {
    pub _base: PyASCIIObject,
    #[doc = " Number of bytes in utf8, excluding the\n terminating \\0."]
    pub utf8_length: Py_ssize_t,
    #[doc = " UTF-8 representation (null-terminated)"]
    pub utf8: *mut ::std::os::raw::c_char,
    #[doc = " Number of code points in wstr, possible\n surrogates count as two code points."]
    pub wstr_length: Py_ssize_t,
}
#[test]
fn bindgen_test_layout_PyCompactUnicodeObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyCompactUnicodeObject> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCompactUnicodeObject>(),
        72usize,
        concat!("Size of: ", stringify!(PyCompactUnicodeObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCompactUnicodeObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyCompactUnicodeObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCompactUnicodeObject),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utf8_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCompactUnicodeObject),
            "::",
            stringify!(utf8_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utf8) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCompactUnicodeObject),
            "::",
            stringify!(utf8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wstr_length) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCompactUnicodeObject),
            "::",
            stringify!(wstr_length)
        )
    );
}
impl Default for PyCompactUnicodeObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Strings allocated through PyUnicode_FromUnicode(NULL, len) use the\nPyUnicodeObject structure. The actual string data is initially in the wstr\nblock, and copied into the data block using _PyUnicode_Ready."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PyUnicodeObject {
    pub _base: PyCompactUnicodeObject,
    #[doc = " Canonical, smallest-form Unicode buffer"]
    pub data: PyUnicodeObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PyUnicodeObject__bindgen_ty_1 {
    pub any: *mut ::std::os::raw::c_void,
    pub latin1: *mut Py_UCS1,
    pub ucs2: *mut Py_UCS2,
    pub ucs4: *mut Py_UCS4,
}
#[test]
fn bindgen_test_layout_PyUnicodeObject__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<PyUnicodeObject__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyUnicodeObject__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(PyUnicodeObject__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<PyUnicodeObject__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(PyUnicodeObject__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).any) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeObject__bindgen_ty_1),
            "::",
            stringify!(any)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latin1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeObject__bindgen_ty_1),
            "::",
            stringify!(latin1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucs2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeObject__bindgen_ty_1),
            "::",
            stringify!(ucs2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucs4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeObject__bindgen_ty_1),
            "::",
            stringify!(ucs4)
        )
    );
}
impl Default for PyUnicodeObject__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_PyUnicodeObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyUnicodeObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyUnicodeObject>(),
        80usize,
        concat!("Size of: ", stringify!(PyUnicodeObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyUnicodeObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyUnicodeObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeObject),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeObject),
            "::",
            stringify!(data)
        )
    );
}
impl Default for PyUnicodeObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyUnicode_CheckConsistency(
        op: *mut PyObject,
        check_content: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " String contains only wstr byte characters.  This is only possible\nwhen the string was created with a legacy API and _PyUnicode_Ready()\nhas not been called yet."]
pub const PyUnicode_Kind_PyUnicode_WCHAR_KIND: PyUnicode_Kind = 0;
#[doc = " Return values of the PyUnicode_KIND() macro:"]
pub const PyUnicode_Kind_PyUnicode_1BYTE_KIND: PyUnicode_Kind = 1;
#[doc = " Return values of the PyUnicode_KIND() macro:"]
pub const PyUnicode_Kind_PyUnicode_2BYTE_KIND: PyUnicode_Kind = 2;
#[doc = " Return values of the PyUnicode_KIND() macro:"]
pub const PyUnicode_Kind_PyUnicode_4BYTE_KIND: PyUnicode_Kind = 4;
pub type PyUnicode_Kind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " With PEP 393, this is the recommended way to allocate a new unicode object.\nThis function will allocate the object and its buffer in a single memory\nblock.  Objects created using this function are not resizable."]
    pub fn PyUnicode_New(size: Py_ssize_t, maxchar: Py_UCS4) -> *mut PyObject;
}
extern "C" {
    #[doc = " Initializes the canonical string representation from the deprecated\nwstr/Py_UNICODE representation. This function is used to convert Unicode\nobjects which were created using the old API to the new flexible format\nintroduced with PEP 393.\n\nDon't call this function directly, use the public PyUnicode_READY() macro\ninstead."]
    pub fn _PyUnicode_Ready(unicode: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a copy of a Unicode string."]
    pub fn _PyUnicode_Copy(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Copy character from one unicode object into another, this function performs\ncharacter conversion when necessary and falls back to memcpy() if possible.\n\nFail if to is too small (smaller than *how_many* or smaller than\nlen(from)-from_start), or if kind(from[from_start:from_start+how_many]) >\nkind(to), or if *to* has more than 1 reference.\n\nReturn the number of written character, or return -1 and raise an exception\non error.\n\nPseudo-code:\n\nhow_many = min(how_many, len(from) - from_start)\nto[to_start:to_start+how_many] = from[from_start:from_start+how_many]\nreturn how_many\n\nNote: The function doesn't write a terminating null character."]
    pub fn PyUnicode_CopyCharacters(
        to: *mut PyObject,
        to_start: Py_ssize_t,
        from: *mut PyObject,
        from_start: Py_ssize_t,
        how_many: Py_ssize_t,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Unsafe version of PyUnicode_CopyCharacters(): don't check arguments and so\nmay crash if parameters are invalid (e.g. if the output string\nis too short)."]
    pub fn _PyUnicode_FastCopyCharacters(
        to: *mut PyObject,
        to_start: Py_ssize_t,
        from: *mut PyObject,
        from_start: Py_ssize_t,
        how_many: Py_ssize_t,
    );
}
extern "C" {
    #[doc = " Fill a string with a character: write fill_char into\nunicode[start:start+length].\n\nFail if fill_char is bigger than the string maximum character, or if the\nstring has more than 1 reference.\n\nReturn the number of written character, or return -1 and raise an exception\non error."]
    pub fn PyUnicode_Fill(
        unicode: *mut PyObject,
        start: Py_ssize_t,
        length: Py_ssize_t,
        fill_char: Py_UCS4,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Unsafe version of PyUnicode_Fill(): don't check arguments and so may crash\nif parameters are invalid (e.g. if length is longer than the string)."]
    pub fn _PyUnicode_FastFill(
        unicode: *mut PyObject,
        start: Py_ssize_t,
        length: Py_ssize_t,
        fill_char: Py_UCS4,
    );
}
extern "C" {
    #[doc = " Create a Unicode Object from the Py_UNICODE buffer u of the given\nsize.\n\nu may be NULL which causes the contents to be undefined. It is the\nuser's responsibility to fill in the needed data afterwards. Note\nthat modifying the Unicode object contents after construction is\nonly allowed if u was set to NULL.\n\nThe buffer is copied into the new object."]
    pub fn PyUnicode_FromUnicode(u: *const Py_UNICODE, size: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a new string from a buffer of Py_UCS1, Py_UCS2 or Py_UCS4 characters.\nScan the string to find the maximum character."]
    pub fn PyUnicode_FromKindAndData(
        kind: ::std::os::raw::c_int,
        buffer: *const ::std::os::raw::c_void,
        size: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a new string from a buffer of ASCII characters.\nWARNING: Don't check if the string contains any non-ASCII character."]
    pub fn _PyUnicode_FromASCII(
        buffer: *const ::std::os::raw::c_char,
        size: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Compute the maximum character of the substring unicode[start:end].\nReturn 127 for an empty string."]
    pub fn _PyUnicode_FindMaxChar(
        unicode: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> Py_UCS4;
}
extern "C" {
    #[doc = " Return a read-only pointer to the Unicode object's internal\nPy_UNICODE buffer.\nIf the wchar_t/Py_UNICODE representation is not yet available, this\nfunction will calculate it."]
    pub fn PyUnicode_AsUnicode(unicode: *mut PyObject) -> *mut Py_UNICODE;
}
extern "C" {
    #[doc = " Similar to PyUnicode_AsUnicode(), but raises a ValueError if the string\ncontains null characters."]
    pub fn _PyUnicode_AsUnicode(unicode: *mut PyObject) -> *const Py_UNICODE;
}
extern "C" {
    #[doc = " Return a read-only pointer to the Unicode object's internal\nPy_UNICODE buffer and save the length at size.\nIf the wchar_t/Py_UNICODE representation is not yet available, this\nfunction will calculate it."]
    pub fn PyUnicode_AsUnicodeAndSize(
        unicode: *mut PyObject,
        size: *mut Py_ssize_t,
    ) -> *mut Py_UNICODE;
}
extern "C" {
    #[doc = " Get the maximum ordinal for a Unicode character."]
    pub fn PyUnicode_GetMax() -> Py_UNICODE;
}
#[doc = " --- _PyUnicodeWriter API -----------------------------------------------"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyUnicodeWriter {
    pub buffer: *mut PyObject,
    pub data: *mut ::std::os::raw::c_void,
    pub kind: PyUnicode_Kind,
    pub maxchar: Py_UCS4,
    pub size: Py_ssize_t,
    pub pos: Py_ssize_t,
    #[doc = " minimum number of allocated characters (default: 0)"]
    pub min_length: Py_ssize_t,
    #[doc = " minimum character (default: 127, ASCII)"]
    pub min_char: Py_UCS4,
    #[doc = " If non-zero, overallocate the buffer (default: 0)."]
    pub overallocate: ::std::os::raw::c_uchar,
    #[doc = " If readonly is 1, buffer is a shared string (cannot be modified)\nand size is set to 0."]
    pub readonly: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__PyUnicodeWriter() {
    const UNINIT: ::std::mem::MaybeUninit<_PyUnicodeWriter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyUnicodeWriter>(),
        56usize,
        concat!("Size of: ", stringify!(_PyUnicodeWriter))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyUnicodeWriter>(),
        8usize,
        concat!("Alignment of ", stringify!(_PyUnicodeWriter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxchar) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(maxchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(min_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_char) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(min_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overallocate) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(overallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readonly) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyUnicodeWriter),
            "::",
            stringify!(readonly)
        )
    );
}
impl Default for _PyUnicodeWriter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initialize a Unicode writer.\n\n By default, the minimum buffer size is 0 character and overallocation is\n disabled. Set min_length, min_char and overallocate attributes to control\n the allocation of the buffer."]
    pub fn _PyUnicodeWriter_Init(writer: *mut _PyUnicodeWriter);
}
extern "C" {
    #[doc = " Don't call this function directly, use the _PyUnicodeWriter_Prepare() macro\ninstead."]
    pub fn _PyUnicodeWriter_PrepareInternal(
        writer: *mut _PyUnicodeWriter,
        length: Py_ssize_t,
        maxchar: Py_UCS4,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Don't call this function directly, use the _PyUnicodeWriter_PrepareKind()\nmacro instead."]
    pub fn _PyUnicodeWriter_PrepareKindInternal(
        writer: *mut _PyUnicodeWriter,
        kind: PyUnicode_Kind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a Unicode character.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyUnicodeWriter_WriteChar(
        writer: *mut _PyUnicodeWriter,
        ch: Py_UCS4,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a Unicode string.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyUnicodeWriter_WriteStr(
        writer: *mut _PyUnicodeWriter,
        str_: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a substring of a Unicode string.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyUnicodeWriter_WriteSubstring(
        writer: *mut _PyUnicodeWriter,
        str_: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append an ASCII-encoded byte string.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyUnicodeWriter_WriteASCIIString(
        writer: *mut _PyUnicodeWriter,
        str_: *const ::std::os::raw::c_char,
        len: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a latin1-encoded byte string.\nReturn 0 on success, raise an exception and return -1 on error."]
    pub fn _PyUnicodeWriter_WriteLatin1String(
        writer: *mut _PyUnicodeWriter,
        str_: *const ::std::os::raw::c_char,
        len: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the value of the writer as a Unicode string. Clear the\nbuffer of the writer. Raise an exception and return NULL\non error."]
    pub fn _PyUnicodeWriter_Finish(writer: *mut _PyUnicodeWriter) -> *mut PyObject;
}
extern "C" {
    #[doc = " Deallocate memory of a writer (clear its internal buffer)."]
    pub fn _PyUnicodeWriter_Dealloc(writer: *mut _PyUnicodeWriter);
}
extern "C" {
    #[doc = " Format the object based on the format_spec, as defined in PEP 3101\n(Advanced String Formatting)."]
    pub fn _PyUnicode_FormatAdvancedWriter(
        writer: *mut _PyUnicodeWriter,
        obj: *mut PyObject,
        format_spec: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a pointer to the default encoding (UTF-8) of the\nUnicode object unicode and the size of the encoded representation\nin bytes stored in *size.\n\nIn case of an error, no *size is set.\n\nThis function caches the UTF-8 encoded string in the unicodeobject\nand subsequent calls will return the same string.  The memory is released\nwhen the unicodeobject is deallocated.\n\n_PyUnicode_AsStringAndSize is a #define for PyUnicode_AsUTF8AndSize to\nsupport the previous internal function with the same behaviour."]
    pub fn PyUnicode_AsUTF8AndSize(
        unicode: *mut PyObject,
        size: *mut Py_ssize_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a pointer to the default encoding (UTF-8) of the\nUnicode object unicode.\n\nLike PyUnicode_AsUTF8AndSize(), this also caches the UTF-8 representation\nin the unicodeobject.\n\n_PyUnicode_AsString is a #define for PyUnicode_AsUTF8 to\nsupport the previous internal function with the same behaviour.\n\nUse of this API is DEPRECATED since no size information can be\nextracted from the returned data."]
    pub fn PyUnicode_AsUTF8(unicode: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Encodes a Py_UNICODE buffer of the given size and returns a\nPython string object."]
    pub fn PyUnicode_Encode(
        s: *const Py_UNICODE,
        size: Py_ssize_t,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- UTF-7 Codecs -------------------------------------------------------"]
    pub fn PyUnicode_EncodeUTF7(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        base64SetO: ::std::os::raw::c_int,
        base64WhiteSpace: ::std::os::raw::c_int,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyUnicode_EncodeUTF7(
        unicode: *mut PyObject,
        base64SetO: ::std::os::raw::c_int,
        base64WhiteSpace: ::std::os::raw::c_int,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- UTF-8 Codecs -------------------------------------------------------"]
    pub fn _PyUnicode_AsUTF8String(
        unicode: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_EncodeUTF8(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- UTF-32 Codecs ------------------------------------------------------"]
    pub fn PyUnicode_EncodeUTF32(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        byteorder: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyUnicode_EncodeUTF32(
        object: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
        byteorder: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns a Python string object holding the UTF-16 encoded value of\nthe Unicode data.\n\nIf byteorder is not 0, output is written according to the following\nbyte order:\n\nbyteorder == -1: little endian\nbyteorder == 0:  native byte order (writes a BOM mark)\nbyteorder == 1:  big endian\n\nIf byteorder is 0, the output string will always start with the\nUnicode BOM mark (U+FEFF). In the other two modes, no BOM mark is\nprepended.\n\nNote that Py_UNICODE data is being interpreted as UTF-16 reduced to\nUCS-2. This trick makes it possible to add full UTF-16 capabilities\nat a later point without compromising the APIs."]
    pub fn PyUnicode_EncodeUTF16(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        byteorder: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyUnicode_EncodeUTF16(
        unicode: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
        byteorder: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Variant of PyUnicode_DecodeUnicodeEscape that supports partial decoding."]
    pub fn _PyUnicode_DecodeUnicodeEscapeStateful(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        consumed: *mut Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Helper for PyUnicode_DecodeUnicodeEscape that detects invalid escape\nchars."]
    pub fn _PyUnicode_DecodeUnicodeEscapeInternal(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        consumed: *mut Py_ssize_t,
        first_invalid_escape: *mut *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_EncodeUnicodeEscape(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Raw-Unicode-Escape Codecs ------------------------------------------"]
    pub fn PyUnicode_EncodeRawUnicodeEscape(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Variant of PyUnicode_DecodeRawUnicodeEscape that supports partial decoding."]
    pub fn _PyUnicode_DecodeRawUnicodeEscapeStateful(
        string: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
        consumed: *mut Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Latin-1 Codecs -----------------------------------------------------"]
    pub fn _PyUnicode_AsLatin1String(
        unicode: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_EncodeLatin1(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- ASCII Codecs -------------------------------------------------------"]
    pub fn _PyUnicode_AsASCIIString(
        unicode: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicode_EncodeASCII(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Character Map Codecs -----------------------------------------------"]
    pub fn PyUnicode_EncodeCharmap(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        mapping: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyUnicode_EncodeCharmap(
        unicode: *mut PyObject,
        mapping: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Translate a Py_UNICODE buffer of the given length by applying a\ncharacter mapping table to it and return the resulting Unicode\nobject.\n\nThe mapping table must map Unicode ordinal integers to Unicode strings,\nUnicode ordinal integers or None (causing deletion of the character).\n\nMapping tables may be dictionaries or sequences. Unmapped character\nordinals (ones which cause a LookupError) are left untouched and\nare copied as-is."]
    pub fn PyUnicode_TranslateCharmap(
        data: *const Py_UNICODE,
        length: Py_ssize_t,
        table: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Takes a Unicode string holding a decimal value and writes it into\nan output buffer using standard ASCII digit codes.\n\nThe output buffer has to provide at least length+1 bytes of storage\narea. The output string is 0-terminated.\n\nThe encoder converts whitespace to ' ', decimal characters to their\ncorresponding ASCII digit and all other Latin-1 characters except\n\\0 as-is. Characters outside this range (Unicode ordinals 1-256)\nare treated as errors. This includes embedded NULL bytes.\n\nError handling is defined by the errors argument:\n\nNULL or \"strict\": raise a ValueError\n\"ignore\": ignore the wrong characters (these are not copied to the\noutput buffer)\n\"replace\": replaces illegal characters with '?'\n\nReturns 0 on success, -1 on failure."]
    pub fn PyUnicode_EncodeDecimal(
        s: *mut Py_UNICODE,
        length: Py_ssize_t,
        output: *mut ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Transforms code points that have decimal digit property to the\ncorresponding ASCII digit code points.\n\nReturns a new Unicode string on success, NULL on failure."]
    pub fn PyUnicode_TransformDecimalToASCII(
        s: *mut Py_UNICODE,
        length: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Coverts a Unicode object holding a decimal value to an ASCII string\nfor using in int, float and complex parsers.\nTransforms code points that have decimal digit property to the\ncorresponding ASCII digit code points.  Transforms spaces to ASCII.\nTransforms code points starting from the first non-ASCII code point that\nis neither a decimal digit nor a space to the end into '?'."]
    pub fn _PyUnicode_TransformDecimalAndSpaceToASCII(unicode: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " --- Methods & Slots ----------------------------------------------------"]
    pub fn _PyUnicode_JoinArray(
        separator: *mut PyObject,
        items: *const *mut PyObject,
        seqlen: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Test whether a unicode is equal to ASCII identifier.  Return 1 if true,\n0 otherwise.  The right argument must be ASCII identifier.\nAny error occurs inside will be cleared before return."]
    pub fn _PyUnicode_EqualToASCIIId(
        left: *mut PyObject,
        right: *mut _Py_Identifier,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test whether a unicode is equal to ASCII string.  Return 1 if true,\n0 otherwise.  The right argument must be ASCII-encoded string.\nAny error occurs inside will be cleared before return."]
    pub fn _PyUnicode_EqualToASCIIString(
        left: *mut PyObject,
        right: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Externally visible for str.strip(unicode)"]
    pub fn _PyUnicode_XStrip(
        self_: *mut PyObject,
        striptype: ::std::os::raw::c_int,
        sepobj: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Using explicit passed-in values, insert the thousands grouping\ninto the string pointed to by buffer.  For the argument descriptions,\nsee Objects/stringlib/localeutil.h"]
    pub fn _PyUnicode_InsertThousandsGrouping(
        writer: *mut _PyUnicodeWriter,
        n_buffer: Py_ssize_t,
        digits: *mut PyObject,
        d_pos: Py_ssize_t,
        n_digits: Py_ssize_t,
        min_width: Py_ssize_t,
        grouping: *const ::std::os::raw::c_char,
        thousands_sep: *mut PyObject,
        maxchar: *mut Py_UCS4,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Helper array used by Py_UNICODE_ISSPACE()."]
    pub static _Py_ascii_whitespace: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[doc = " These should not be used directly. Use the Py_UNICODE_IS* and\nPy_UNICODE_TO* macros instead.\n\nThese APIs are implemented in Objects/unicodectype.c."]
    pub fn _PyUnicode_IsLowercase(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsUppercase(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsTitlecase(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsXidStart(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsXidContinue(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsWhitespace(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsLinebreak(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Py_DEPRECATED(3.3)"]
    pub fn _PyUnicode_ToLowercase(ch: Py_UCS4) -> Py_UCS4;
}
extern "C" {
    #[doc = " Py_DEPRECATED(3.3)"]
    pub fn _PyUnicode_ToUppercase(ch: Py_UCS4) -> Py_UCS4;
}
extern "C" {
    pub fn _PyUnicode_ToTitlecase(ch: Py_UCS4) -> Py_UCS4;
}
extern "C" {
    pub fn _PyUnicode_ToLowerFull(ch: Py_UCS4, res: *mut Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ToTitleFull(ch: Py_UCS4, res: *mut Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ToUpperFull(ch: Py_UCS4, res: *mut Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ToFoldedFull(ch: Py_UCS4, res: *mut Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsCaseIgnorable(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsCased(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ToDecimalDigit(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ToDigit(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ToNumeric(ch: Py_UCS4) -> f64;
}
extern "C" {
    pub fn _PyUnicode_IsDecimalDigit(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsDigit(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsNumeric(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsPrintable(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_IsAlpha(ch: Py_UCS4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_UNICODE_strlen(u: *const Py_UNICODE) -> usize;
}
extern "C" {
    pub fn Py_UNICODE_strcpy(s1: *mut Py_UNICODE, s2: *const Py_UNICODE) -> *mut Py_UNICODE;
}
extern "C" {
    pub fn Py_UNICODE_strcat(s1: *mut Py_UNICODE, s2: *const Py_UNICODE) -> *mut Py_UNICODE;
}
extern "C" {
    pub fn Py_UNICODE_strncpy(
        s1: *mut Py_UNICODE,
        s2: *const Py_UNICODE,
        n: usize,
    ) -> *mut Py_UNICODE;
}
extern "C" {
    pub fn Py_UNICODE_strcmp(s1: *const Py_UNICODE, s2: *const Py_UNICODE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_UNICODE_strncmp(
        s1: *const Py_UNICODE,
        s2: *const Py_UNICODE,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_UNICODE_strchr(s: *const Py_UNICODE, c: Py_UNICODE) -> *mut Py_UNICODE;
}
extern "C" {
    pub fn Py_UNICODE_strrchr(s: *const Py_UNICODE, c: Py_UNICODE) -> *mut Py_UNICODE;
}
extern "C" {
    pub fn _PyUnicode_FormatLong(
        arg1: *mut PyObject,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a copy of a unicode string ending with a nul character. Return NULL\nand raise a MemoryError exception on memory allocation failure, otherwise\nreturn a new allocated buffer (use PyMem_Free() to free the buffer)."]
    pub fn PyUnicode_AsUnicodeCopy(unicode: *mut PyObject) -> *mut Py_UNICODE;
}
extern "C" {
    #[doc = " Return an interned Unicode object for an Identifier; may fail if there is no memory."]
    pub fn _PyUnicode_FromId(arg1: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    #[doc = " Fast equality check when the inputs are known to be exact unicode types\nand where the hash values are equal (i.e. a very probable match)"]
    pub fn _PyUnicode_EQ(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyUnicode_ScanIdentifier(arg1: *mut PyObject) -> Py_ssize_t;
}
#[doc = " Long (arbitrary precision) integer object interface"]
pub type PyLongObject = _longobject;
extern "C" {
    pub static mut PyLong_Type: PyTypeObject;
}
extern "C" {
    pub fn PyLong_FromLong(arg1: ::std::os::raw::c_long) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromUnsignedLong(arg1: ::std::os::raw::c_ulong) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromSize_t(arg1: usize) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromSsize_t(arg1: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromDouble(arg1: f64) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_AsLong(arg1: *mut PyObject) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn PyLong_AsLongAndOverflow(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn PyLong_AsSsize_t(arg1: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyLong_AsSize_t(arg1: *mut PyObject) -> usize;
}
extern "C" {
    pub fn PyLong_AsUnsignedLong(arg1: *mut PyObject) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PyLong_AsUnsignedLongMask(arg1: *mut PyObject) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _PyLong_AsInt(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyLong_GetInfo() -> *mut PyObject;
}
extern "C" {
    pub fn _PyLong_UnsignedShort_Converter(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyLong_UnsignedInt_Converter(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyLong_UnsignedLong_Converter(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyLong_UnsignedLongLong_Converter(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyLong_Size_t_Converter(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _PyLong_DigitValue: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    pub fn _PyLong_Frexp(a: *mut PyLongObject, e: *mut Py_ssize_t) -> f64;
}
extern "C" {
    pub fn PyLong_AsDouble(arg1: *mut PyObject) -> f64;
}
extern "C" {
    pub fn PyLong_FromVoidPtr(arg1: *mut ::std::os::raw::c_void) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_AsVoidPtr(arg1: *mut PyObject) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyLong_FromLongLong(arg1: ::std::os::raw::c_longlong) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromUnsignedLongLong(arg1: ::std::os::raw::c_ulonglong) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_AsLongLong(arg1: *mut PyObject) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn PyLong_AsUnsignedLongLong(arg1: *mut PyObject) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn PyLong_AsUnsignedLongLongMask(arg1: *mut PyObject) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn PyLong_AsLongLongAndOverflow(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn PyLong_FromString(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromUnicode(
        arg1: *mut Py_UNICODE,
        arg2: Py_ssize_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyLong_FromUnicodeObject(u: *mut PyObject, base: ::std::os::raw::c_int)
        -> *mut PyObject;
}
extern "C" {
    pub fn _PyLong_FromBytes(
        arg1: *const ::std::os::raw::c_char,
        arg2: Py_ssize_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " _PyLong_Sign.  Return 0 if v is 0, -1 if v < 0, +1 if v > 0.\nv must not be NULL, and must be a normalized long.\nThere are no error cases."]
    pub fn _PyLong_Sign(v: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " _PyLong_NumBits.  Return the number of bits needed to represent the\nabsolute value of a long.  For example, this returns 1 for 1 and -1, 2\nfor 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.\nv must not be NULL, and must be a normalized long.\n(size_t)-1 is returned and OverflowError set if the true result doesn't\nfit in a size_t."]
    pub fn _PyLong_NumBits(v: *mut PyObject) -> usize;
}
extern "C" {
    #[doc = " _PyLong_DivmodNear.  Given integers a and b, compute the nearest\ninteger q to the exact quotient a / b, rounding to the nearest even integer\nin the case of a tie.  Return (q, r), where r = a - q*b.  The remainder r\nwill satisfy abs(r) <= abs(b)/2, with equality possible only if q is\neven."]
    pub fn _PyLong_DivmodNear(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in\nbase 256, and return a Python int with the same numeric value.\nIf n is 0, the integer is 0.  Else:\nIf little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;\nelse (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the\nLSB.\nIf is_signed is 0/false, view the bytes as a non-negative integer.\nIf is_signed is 1/true, view the bytes as a 2's-complement integer,\nnon-negative if bit 0x80 of the MSB is clear, negative if set.\nError returns:\n+ Return NULL with the appropriate exception set if there's not\nenough memory to create the Python int."]
    pub fn _PyLong_FromByteArray(
        bytes: *const ::std::os::raw::c_uchar,
        n: usize,
        little_endian: ::std::os::raw::c_int,
        is_signed: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " _PyLong_AsByteArray: Convert the least-significant 8*n bits of long\nv to a base-256 integer, stored in array bytes.  Normally return 0,\nreturn -1 on error.\nIf little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at\nbytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and\nthe LSB at bytes[n-1].\nIf is_signed is 0/false, it's an error if v < 0; else (v >= 0) n bytes\nare filled and there's nothing special about bit 0x80 of the MSB.\nIf is_signed is 1/true, bytes is filled with the 2's-complement\nrepresentation of v's value.  Bit 0x80 of the MSB is the sign bit.\nError returns (-1):\n+ is_signed is 0 and v < 0.  TypeError is set in this case, and bytes\nisn't altered.\n+ n isn't big enough to hold the full mathematical value of v.  For\nexample, if is_signed is 0 and there are more digits in the v than\nfit in n; or if is_signed is 1, v < 0, and n is just 1 bit shy of\nbeing large enough to hold a sign bit.  OverflowError is set in this\ncase, but bytes holds the least-significant n bytes of the true value."]
    pub fn _PyLong_AsByteArray(
        v: *mut PyLongObject,
        bytes: *mut ::std::os::raw::c_uchar,
        n: usize,
        little_endian: ::std::os::raw::c_int,
        is_signed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " _PyLong_FromNbInt: Convert the given object to a PyLongObject\nusing the nb_int slot, if available.  Raise TypeError if either the\nnb_int slot is not available or the result of the call to nb_int\nreturns something not of type int."]
    pub fn _PyLong_FromNbInt(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Convert the given object to a PyLongObject using the nb_index or\nnb_int slots, if available (the latter is deprecated).\nRaise TypeError if either nb_index and nb_int slots are not\navailable or the result of the call to nb_index or nb_int\nreturns something not of type int.\nShould be replaced with PyNumber_Index after the end of the\ndeprecation period."]
    pub fn _PyLong_FromNbIndexOrNbInt(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " _PyLong_Format: Convert the long to a string object with given base,\nappending a base prefix of 0[box] if base is 2, 8 or 16."]
    pub fn _PyLong_Format(obj: *mut PyObject, base: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    pub fn _PyLong_FormatWriter(
        writer: *mut _PyUnicodeWriter,
        obj: *mut PyObject,
        base: ::std::os::raw::c_int,
        alternate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyLong_FormatBytesWriter(
        writer: *mut _PyBytesWriter,
        str_: *mut ::std::os::raw::c_char,
        obj: *mut PyObject,
        base: ::std::os::raw::c_int,
        alternate: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Format the object based on the format_spec, as defined in PEP 3101\n(Advanced String Formatting)."]
    pub fn _PyLong_FormatAdvancedWriter(
        writer: *mut _PyUnicodeWriter,
        obj: *mut PyObject,
        format_spec: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " These aren't really part of the int object, but they're handy. The\nfunctions are in Python/mystrtoul.c."]
    pub fn PyOS_strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PyOS_strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " For use by the gcd function in mathmodule.c"]
    pub fn _PyLong_GCD(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static mut _PyLong_Zero: *mut PyObject;
}
extern "C" {
    pub static mut _PyLong_One: *mut PyObject;
}
extern "C" {
    pub fn _PyLong_Rshift(arg1: *mut PyObject, arg2: usize) -> *mut PyObject;
}
extern "C" {
    pub fn _PyLong_Lshift(arg1: *mut PyObject, arg2: usize) -> *mut PyObject;
}
pub type digit = u32;
pub type sdigit = i32;
pub type twodigits = u64;
pub type stwodigits = i64;
#[doc = " Long integer representation.\nThe absolute value of a number is equal to\nSUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)\nNegative numbers are represented with ob_size < 0;\nzero is represented by ob_size == 0.\nIn a normalized number, ob_digit[abs(ob_size)-1] (the most significant\ndigit) is never zero.  Also, in all cases, for all valid i,\n0 <= ob_digit[i] <= MASK.\nThe allocation function takes care of allocating extra memory\nso that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.\n\nCAUTION:  Generic code manipulating subtypes of PyVarObject has to\naware that ints abuse  ob_size's sign bit."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _longobject {
    pub ob_base: PyVarObject,
    pub ob_digit: [digit; 1usize],
}
#[test]
fn bindgen_test_layout__longobject() {
    const UNINIT: ::std::mem::MaybeUninit<_longobject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_longobject>(),
        32usize,
        concat!("Size of: ", stringify!(_longobject))
    );
    assert_eq!(
        ::std::mem::align_of::<_longobject>(),
        8usize,
        concat!("Alignment of ", stringify!(_longobject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_longobject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_digit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_longobject),
            "::",
            stringify!(ob_digit)
        )
    );
}
impl Default for _longobject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyLong_New(arg1: Py_ssize_t) -> *mut PyLongObject;
}
extern "C" {
    #[doc = " Return a copy of src."]
    pub fn _PyLong_Copy(src: *mut PyLongObject) -> *mut PyObject;
}
extern "C" {
    pub static mut PyBool_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Don't use these directly"]
    pub static mut _Py_FalseStruct: _longobject;
}
extern "C" {
    #[doc = " Don't use these directly"]
    pub static mut _Py_TrueStruct: _longobject;
}
extern "C" {
    #[doc = " Function to return a bool from a C long"]
    pub fn PyBool_FromLong(arg1: ::std::os::raw::c_long) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct PyFloatObject {
    pub ob_base: PyObject,
    pub ob_fval: f64,
}
#[test]
fn bindgen_test_layout_PyFloatObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyFloatObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyFloatObject>(),
        24usize,
        concat!("Size of: ", stringify!(PyFloatObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyFloatObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyFloatObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFloatObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_fval) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFloatObject),
            "::",
            stringify!(ob_fval)
        )
    );
}
impl Default for PyFloatObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyFloat_Type: PyTypeObject;
}
extern "C" {
    pub fn PyFloat_GetMax() -> f64;
}
extern "C" {
    pub fn PyFloat_GetMin() -> f64;
}
extern "C" {
    pub fn PyFloat_GetInfo() -> *mut PyObject;
}
extern "C" {
    #[doc = " Return Python float from string PyObject."]
    pub fn PyFloat_FromString(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return Python float from C double."]
    pub fn PyFloat_FromDouble(arg1: f64) -> *mut PyObject;
}
extern "C" {
    #[doc = " Extract C double from Python float.  The macro version trades safety for\nspeed."]
    pub fn PyFloat_AsDouble(arg1: *mut PyObject) -> f64;
}
extern "C" {
    #[doc = " The pack routines write 2, 4 or 8 bytes, starting at p.  le is a bool\n argument, true if you want the string in little-endian format (exponent\n last, at p+1, p+3 or p+7), false if you want big-endian format (exponent\n first, at p).\n Return value:  0 if all is OK, -1 if error (and an exception is\n set, most likely OverflowError).\n There are two problems on non-IEEE platforms:\n 1):  What this does is undefined if x is a NaN or infinity.\n 2):  -0.0 and +0.0 produce the same string."]
    pub fn _PyFloat_Pack2(
        x: f64,
        p: *mut ::std::os::raw::c_uchar,
        le: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyFloat_Pack4(
        x: f64,
        p: *mut ::std::os::raw::c_uchar,
        le: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyFloat_Pack8(
        x: f64,
        p: *mut ::std::os::raw::c_uchar,
        le: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The unpack routines read 2, 4 or 8 bytes, starting at p.  le is a bool\n argument, true if the string is in little-endian format (exponent\n last, at p+1, p+3 or p+7), false if big-endian (exponent first, at p).\n Return value:  The unpacked double.  On error, this is -1.0 and\n PyErr_Occurred() is true (and an exception is set, most likely\n OverflowError).  Note that on a non-IEEE platform this will refuse\n to unpack a string that represents a NaN or infinity."]
    pub fn _PyFloat_Unpack2(p: *const ::std::os::raw::c_uchar, le: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _PyFloat_Unpack4(p: *const ::std::os::raw::c_uchar, le: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _PyFloat_Unpack8(p: *const ::std::os::raw::c_uchar, le: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _PyFloat_DebugMallocStats(out: *mut FILE);
}
extern "C" {
    #[doc = " Format the object based on the format_spec, as defined in PEP 3101\n(Advanced String Formatting)."]
    pub fn _PyFloat_FormatAdvancedWriter(
        writer: *mut _PyUnicodeWriter,
        obj: *mut PyObject,
        format_spec: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct Py_complex {
    pub real: f64,
    pub imag: f64,
}
#[test]
fn bindgen_test_layout_Py_complex() {
    const UNINIT: ::std::mem::MaybeUninit<Py_complex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Py_complex>(),
        16usize,
        concat!("Size of: ", stringify!(Py_complex))
    );
    assert_eq!(
        ::std::mem::align_of::<Py_complex>(),
        8usize,
        concat!("Alignment of ", stringify!(Py_complex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Py_complex),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Py_complex),
            "::",
            stringify!(imag)
        )
    );
}
extern "C" {
    #[doc = " Operations on complex numbers from complexmodule.c"]
    pub fn _Py_c_sum(arg1: Py_complex, arg2: Py_complex) -> Py_complex;
}
extern "C" {
    pub fn _Py_c_diff(arg1: Py_complex, arg2: Py_complex) -> Py_complex;
}
extern "C" {
    pub fn _Py_c_neg(arg1: Py_complex) -> Py_complex;
}
extern "C" {
    pub fn _Py_c_prod(arg1: Py_complex, arg2: Py_complex) -> Py_complex;
}
extern "C" {
    pub fn _Py_c_quot(arg1: Py_complex, arg2: Py_complex) -> Py_complex;
}
extern "C" {
    pub fn _Py_c_pow(arg1: Py_complex, arg2: Py_complex) -> Py_complex;
}
extern "C" {
    pub fn _Py_c_abs(arg1: Py_complex) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct PyComplexObject {
    pub ob_base: PyObject,
    pub cval: Py_complex,
}
#[test]
fn bindgen_test_layout_PyComplexObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyComplexObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyComplexObject>(),
        32usize,
        concat!("Size of: ", stringify!(PyComplexObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyComplexObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyComplexObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyComplexObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cval) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyComplexObject),
            "::",
            stringify!(cval)
        )
    );
}
impl Default for PyComplexObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyComplex_Type: PyTypeObject;
}
extern "C" {
    pub fn PyComplex_FromCComplex(arg1: Py_complex) -> *mut PyObject;
}
extern "C" {
    pub fn PyComplex_FromDoubles(real: f64, imag: f64) -> *mut PyObject;
}
extern "C" {
    pub fn PyComplex_RealAsDouble(op: *mut PyObject) -> f64;
}
extern "C" {
    pub fn PyComplex_ImagAsDouble(op: *mut PyObject) -> f64;
}
extern "C" {
    pub fn PyComplex_AsCComplex(op: *mut PyObject) -> Py_complex;
}
extern "C" {
    pub fn _PyComplex_FormatAdvancedWriter(
        writer: *mut _PyUnicodeWriter,
        obj: *mut PyObject,
        format_spec: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "A range object represents an integer range.  This is an immutable object;\na range cannot change its value after creation.\n\nRange objects behave like the corresponding tuple objects except that\nthey are represented by a start, stop, and step datamembers."]
    pub static mut PyRange_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyRangeIter_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyLongRangeIter_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyManagedBuffer_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyMemoryView_Type: PyTypeObject;
}
extern "C" {
    pub fn PyMemoryView_FromObject(base: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyMemoryView_FromMemory(
        mem: *mut ::std::os::raw::c_char,
        size: Py_ssize_t,
        flags: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyMemoryView_FromBuffer(info: *mut Py_buffer) -> *mut PyObject;
}
extern "C" {
    pub fn PyMemoryView_GetContiguous(
        base: *mut PyObject,
        buffertype: ::std::os::raw::c_int,
        order: ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyManagedBufferObject {
    pub ob_base: PyObject,
    #[doc = " state flags"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " number of direct memoryview exports"]
    pub exports: Py_ssize_t,
    #[doc = " snapshot buffer obtained from the original exporter"]
    pub master: Py_buffer,
}
#[test]
fn bindgen_test_layout__PyManagedBufferObject() {
    const UNINIT: ::std::mem::MaybeUninit<_PyManagedBufferObject> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyManagedBufferObject>(),
        112usize,
        concat!("Size of: ", stringify!(_PyManagedBufferObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyManagedBufferObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_PyManagedBufferObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyManagedBufferObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyManagedBufferObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exports) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyManagedBufferObject),
            "::",
            stringify!(exports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).master) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyManagedBufferObject),
            "::",
            stringify!(master)
        )
    );
}
impl Default for _PyManagedBufferObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMemoryViewObject {
    pub ob_base: PyVarObject,
    #[doc = " managed buffer"]
    pub mbuf: *mut _PyManagedBufferObject,
    #[doc = " hash value for read-only views"]
    pub hash: Py_hash_t,
    #[doc = " state flags"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " number of buffer re-exports"]
    pub exports: Py_ssize_t,
    #[doc = " private copy of the exporter's view"]
    pub view: Py_buffer,
    pub weakreflist: *mut PyObject,
    #[doc = " shape, strides, suboffsets"]
    pub ob_array: [Py_ssize_t; 1usize],
}
#[test]
fn bindgen_test_layout_PyMemoryViewObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyMemoryViewObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMemoryViewObject>(),
        152usize,
        concat!("Size of: ", stringify!(PyMemoryViewObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMemoryViewObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMemoryViewObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbuf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(mbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exports) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(exports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weakreflist) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_array) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemoryViewObject),
            "::",
            stringify!(ob_array)
        )
    );
}
impl Default for PyMemoryViewObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Another generally useful object type is a tuple of object pointers.\nFor Python, this is an immutable type.  C code can change the tuple items\n(but not their number), and even use tuples as general-purpose arrays of\nobject references, but in general only brand new tuples should be mutated,\nnot ones that might already have been exposed to Python code.\n\n WARNING *** PyTuple_SetItem does not increment the new item's reference\ncount, but does decrement the reference count of the item it replaces,\nif not nil.  It does *decrement* the reference count if it is *not*\ninserted in the tuple.  Similarly, PyTuple_GetItem does not increment the\nreturned item's reference count."]
    pub static mut PyTuple_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyTupleIter_Type: PyTypeObject;
}
extern "C" {
    pub fn PyTuple_New(size: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn PyTuple_Size(arg1: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyTuple_GetItem(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn PyTuple_SetItem(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyTuple_GetSlice(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyTuple_Pack(arg1: Py_ssize_t, ...) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyTupleObject {
    pub ob_base: PyVarObject,
    #[doc = " ob_item contains space for 'ob_size' elements.\nItems must normally not be NULL, except during construction when\nthe tuple is not yet visible outside the function that builds it."]
    pub ob_item: [*mut PyObject; 1usize],
}
#[test]
fn bindgen_test_layout_PyTupleObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyTupleObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyTupleObject>(),
        32usize,
        concat!("Size of: ", stringify!(PyTupleObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyTupleObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyTupleObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyTupleObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_item) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyTupleObject),
            "::",
            stringify!(ob_item)
        )
    );
}
impl Default for PyTupleObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyTuple_Resize(arg1: *mut *mut PyObject, arg2: Py_ssize_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyTuple_MaybeUntrack(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyTuple_DebugMallocStats(out: *mut FILE);
}
extern "C" {
    pub static mut PyList_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyListIter_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyListRevIter_Type: PyTypeObject;
}
extern "C" {
    pub fn PyList_New(size: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn PyList_Size(arg1: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyList_GetItem(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn PyList_SetItem(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyList_Insert(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyList_Append(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyList_GetSlice(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: Py_ssize_t,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyList_SetSlice(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
        arg3: Py_ssize_t,
        arg4: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyList_Sort(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyList_Reverse(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyList_AsTuple(arg1: *mut PyObject) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyListObject {
    pub ob_base: PyVarObject,
    #[doc = " Vector of pointers to list elements.  list[0] is ob_item[0], etc."]
    pub ob_item: *mut *mut PyObject,
    #[doc = " ob_item contains space for 'allocated' elements.  The number\n currently in use is ob_size.\n Invariants:\n     0 <= ob_size <= allocated\n     len(list) == ob_size\n     ob_item == NULL implies ob_size == allocated == 0\n list.sort() temporarily sets allocated to -1 to detect mutations.\n\n Items must normally not be NULL, except during construction when\n the list is not yet visible outside the function that builds it."]
    pub allocated: Py_ssize_t,
}
#[test]
fn bindgen_test_layout_PyListObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyListObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyListObject>(),
        40usize,
        concat!("Size of: ", stringify!(PyListObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyListObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyListObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyListObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_item) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyListObject),
            "::",
            stringify!(ob_item)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyListObject),
            "::",
            stringify!(allocated)
        )
    );
}
impl Default for PyListObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyList_Extend(arg1: *mut PyListObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyList_DebugMallocStats(out: *mut FILE);
}
extern "C" {
    #[doc = " The distribution includes a separate file, Objects/dictnotes.txt,\ndescribing explorations into dictionary design and optimization.\nIt covers typical dictionary use patterns, the parameters for\ntuning dictionaries, and several ideas for possible optimizations."]
    pub static mut PyDict_Type: PyTypeObject;
}
extern "C" {
    pub fn PyDict_New() -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_GetItem(mp: *mut PyObject, key: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_GetItemWithError(mp: *mut PyObject, key: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_SetItem(
        mp: *mut PyObject,
        key: *mut PyObject,
        item: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyDict_DelItem(mp: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyDict_Clear(mp: *mut PyObject);
}
extern "C" {
    pub fn PyDict_Next(
        mp: *mut PyObject,
        pos: *mut Py_ssize_t,
        key: *mut *mut PyObject,
        value: *mut *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyDict_Keys(mp: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_Values(mp: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_Items(mp: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_Size(mp: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyDict_Copy(mp: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_Contains(mp: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1)."]
    pub fn PyDict_Update(mp: *mut PyObject, other: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " PyDict_Merge updates/merges from a mapping object (an object that\nsupports PyMapping_Keys() and PyObject_GetItem()).  If override is true,\nthe last occurrence of a key wins, else the first.  The Python\ndict.update(other) is equivalent to PyDict_Merge(dict, other, 1)."]
    pub fn PyDict_Merge(
        mp: *mut PyObject,
        other: *mut PyObject,
        override_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " PyDict_MergeFromSeq2 updates/merges from an iterable object producing\niterable objects of length 2.  If override is true, the last occurrence\nof a key wins, else the first.  The Python dict constructor dict(seq2)\nis equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1)."]
    pub fn PyDict_MergeFromSeq2(
        d: *mut PyObject,
        seq2: *mut PyObject,
        override_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyDict_GetItemString(
        dp: *mut PyObject,
        key: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_SetItemString(
        dp: *mut PyObject,
        key: *const ::std::os::raw::c_char,
        item: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyDict_DelItemString(
        dp: *mut PyObject,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dictionary (keys, values, items) views"]
    pub static mut PyDictKeys_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictValues_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictItems_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Dictionary (key, value, items) iterators"]
    pub static mut PyDictIterKey_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictIterValue_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictIterItem_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictRevIterKey_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictRevIterItem_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictRevIterValue_Type: PyTypeObject;
}
pub type PyDictKeysObject = _dictkeysobject;
#[doc = " The ma_values pointer is NULL for a combined table\n or points to an array of PyObject* for a split table"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyDictObject {
    pub ob_base: PyObject,
    #[doc = " Number of items in the dictionary"]
    pub ma_used: Py_ssize_t,
    #[doc = " Dictionary version: globally unique, value change each time\nthe dictionary is modified"]
    pub ma_version_tag: u64,
    pub ma_keys: *mut PyDictKeysObject,
    #[doc = " If ma_values is NULL, the table is \"combined\": keys and values\nare stored in ma_keys.\n\nIf ma_values is not NULL, the table is split:\nkeys are stored in ma_keys and values are stored in ma_values"]
    pub ma_values: *mut *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyDictObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyDictObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyDictObject>(),
        48usize,
        concat!("Size of: ", stringify!(PyDictObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyDictObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyDictObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDictObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ma_used) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDictObject),
            "::",
            stringify!(ma_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ma_version_tag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDictObject),
            "::",
            stringify!(ma_version_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ma_keys) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDictObject),
            "::",
            stringify!(ma_keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ma_values) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDictObject),
            "::",
            stringify!(ma_values)
        )
    );
}
impl Default for PyDictObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyDict_GetItem_KnownHash(
        mp: *mut PyObject,
        key: *mut PyObject,
        hash: Py_hash_t,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_GetItemIdWithError(dp: *mut PyObject, key: *mut _Py_Identifier)
        -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_GetItemStringWithError(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyDict_SetDefault(
        mp: *mut PyObject,
        key: *mut PyObject,
        defaultobj: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_SetItem_KnownHash(
        mp: *mut PyObject,
        key: *mut PyObject,
        item: *mut PyObject,
        hash: Py_hash_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_DelItem_KnownHash(
        mp: *mut PyObject,
        key: *mut PyObject,
        hash: Py_hash_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_DelItemIf(
        mp: *mut PyObject,
        key: *mut PyObject,
        predicate: ::std::option::Option<
            unsafe extern "C" fn(value: *mut PyObject) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_NewKeysForClass() -> *mut PyDictKeysObject;
}
extern "C" {
    pub fn PyObject_GenericGetDict(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_Next(
        mp: *mut PyObject,
        pos: *mut Py_ssize_t,
        key: *mut *mut PyObject,
        value: *mut *mut PyObject,
        hash: *mut Py_hash_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_Contains(
        mp: *mut PyObject,
        key: *mut PyObject,
        hash: Py_hash_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_NewPresized(minused: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_MaybeUntrack(mp: *mut PyObject);
}
extern "C" {
    pub fn _PyDict_HasOnlyStringKeys(mp: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_KeysSize(keys: *mut PyDictKeysObject) -> Py_ssize_t;
}
extern "C" {
    pub fn _PyDict_SizeOf(arg1: *mut PyDictObject) -> Py_ssize_t;
}
extern "C" {
    pub fn _PyDict_Pop(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_Pop_KnownHash(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: Py_hash_t,
        arg4: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_FromKeys(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,\nthe first occurrence of a key wins, if override is 1, the last occurrence\nof a key wins, if override is 2, a KeyError with conflicting key as\nargument is raised."]
    pub fn _PyDict_MergeEx(
        mp: *mut PyObject,
        other: *mut PyObject,
        override_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_GetItemId(dp: *mut PyObject, key: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDict_SetItemId(
        dp: *mut PyObject,
        key: *mut _Py_Identifier,
        item: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_DelItemId(mp: *mut PyObject, key: *mut _Py_Identifier) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_DebugMallocStats(out: *mut FILE);
}
extern "C" {
    pub fn _PyObjectDict_SetItem(
        tp: *mut PyTypeObject,
        dictptr: *mut *mut PyObject,
        name: *mut PyObject,
        value: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyDict_LoadGlobal(
        arg1: *mut PyDictObject,
        arg2: *mut PyDictObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
#[doc = " _PyDictView"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyDictViewObject {
    pub ob_base: PyObject,
    pub dv_dict: *mut PyDictObject,
}
#[test]
fn bindgen_test_layout__PyDictViewObject() {
    const UNINIT: ::std::mem::MaybeUninit<_PyDictViewObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyDictViewObject>(),
        24usize,
        concat!("Size of: ", stringify!(_PyDictViewObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyDictViewObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_PyDictViewObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyDictViewObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyDictViewObject),
            "::",
            stringify!(dv_dict)
        )
    );
}
impl Default for _PyDictViewObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyDictView_New(arg1: *mut PyObject, arg2: *mut PyTypeObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyDictView_Intersect(self_: *mut PyObject, other: *mut PyObject) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _odictobject {
    _unused: [u8; 0],
}
pub type PyODictObject = _odictobject;
extern "C" {
    pub static mut PyODict_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyODictIter_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyODictKeys_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyODictItems_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyODictValues_Type: PyTypeObject;
}
extern "C" {
    pub fn PyODict_New() -> *mut PyObject;
}
extern "C" {
    pub fn PyODict_SetItem(
        od: *mut PyObject,
        key: *mut PyObject,
        item: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyODict_DelItem(od: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PyEnum_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyReversed_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct setentry {
    pub key: *mut PyObject,
    #[doc = " Cached hash code of the key"]
    pub hash: Py_hash_t,
}
#[test]
fn bindgen_test_layout_setentry() {
    const UNINIT: ::std::mem::MaybeUninit<setentry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<setentry>(),
        16usize,
        concat!("Size of: ", stringify!(setentry))
    );
    assert_eq!(
        ::std::mem::align_of::<setentry>(),
        8usize,
        concat!("Alignment of ", stringify!(setentry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setentry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setentry),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for setentry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The SetObject data structure is shared by set and frozenset objects.\n\nInvariant for sets:\n- hash is -1\n\nInvariants for frozensets:\n- data is immutable.\n- hash is the hash of the frozenset or -1 if not computed yet."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PySetObject {
    pub ob_base: PyObject,
    #[doc = " Number active and dummy entries"]
    pub fill: Py_ssize_t,
    #[doc = " Number active entries"]
    pub used: Py_ssize_t,
    #[doc = " The table contains mask + 1 slots, and that's a power of 2.\n We store the mask instead of the size because the mask is more\n frequently needed."]
    pub mask: Py_ssize_t,
    #[doc = " The table points to a fixed-size smalltable for small tables\n or to additional malloc'ed memory for bigger tables.\n The table pointer is never NULL which saves us from repeated\n runtime null-tests."]
    pub table: *mut setentry,
    #[doc = " Only used by frozenset objects"]
    pub hash: Py_hash_t,
    #[doc = " Search finger for pop()"]
    pub finger: Py_ssize_t,
    pub smalltable: [setentry; 8usize],
    #[doc = " List of weak references"]
    pub weakreflist: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PySetObject() {
    const UNINIT: ::std::mem::MaybeUninit<PySetObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PySetObject>(),
        200usize,
        concat!("Size of: ", stringify!(PySetObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PySetObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PySetObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finger) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(finger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smalltable) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(smalltable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weakreflist) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(PySetObject),
            "::",
            stringify!(weakreflist)
        )
    );
}
impl Default for PySetObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _PySet_Dummy: *mut PyObject;
}
extern "C" {
    pub fn _PySet_NextEntry(
        set: *mut PyObject,
        pos: *mut Py_ssize_t,
        key: *mut *mut PyObject,
        hash: *mut Py_hash_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PySet_Update(set: *mut PyObject, iterable: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PySet_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyFrozenSet_Type: PyTypeObject;
}
extern "C" {
    pub static mut PySetIter_Type: PyTypeObject;
}
extern "C" {
    pub fn PySet_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFrozenSet_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PySet_Add(set: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySet_Clear(set: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySet_Contains(anyset: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySet_Discard(set: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySet_Pop(set: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PySet_Size(anyset: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " This is about the type 'builtin_function_or_method',\nnot Python methods in user-defined classes.  See classobject.h\nfor the latter."]
    pub static mut PyCFunction_Type: PyTypeObject;
}
pub type PyCFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,
>;
pub type _PyCFunctionFast = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *const *mut PyObject,
        arg3: Py_ssize_t,
    ) -> *mut PyObject,
>;
pub type PyCFunctionWithKeywords = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject,
>;
pub type _PyCFunctionFastWithKeywords = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *const *mut PyObject,
        arg3: Py_ssize_t,
        arg4: *mut PyObject,
    ) -> *mut PyObject,
>;
pub type PyCMethod = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyTypeObject,
        arg3: *const *mut PyObject,
        arg4: usize,
        arg5: *mut PyObject,
    ) -> *mut PyObject,
>;
extern "C" {
    pub fn PyCFunction_GetFunction(arg1: *mut PyObject) -> PyCFunction;
}
extern "C" {
    pub fn PyCFunction_GetSelf(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCFunction_GetFlags(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCFunction_Call(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMethodDef {
    #[doc = " The name of the built-in function/method"]
    pub ml_name: *const ::std::os::raw::c_char,
    #[doc = " The C function that implements it"]
    pub ml_meth: PyCFunction,
    #[doc = " Combination of METH_xxx flags, which mostly\ndescribe the args expected by the C func"]
    pub ml_flags: ::std::os::raw::c_int,
    #[doc = " The __doc__ attribute, or NULL"]
    pub ml_doc: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PyMethodDef() {
    const UNINIT: ::std::mem::MaybeUninit<PyMethodDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMethodDef>(),
        32usize,
        concat!("Size of: ", stringify!(PyMethodDef))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMethodDef>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMethodDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ml_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDef),
            "::",
            stringify!(ml_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ml_meth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDef),
            "::",
            stringify!(ml_meth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ml_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDef),
            "::",
            stringify!(ml_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ml_doc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDef),
            "::",
            stringify!(ml_doc)
        )
    );
}
impl Default for PyMethodDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn PyCFunction_NewEx(
        arg1: *mut PyMethodDef,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyCMethod_New(
        arg1: *mut PyMethodDef,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
        arg4: *mut PyTypeObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub static mut PyCMethod_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCFunctionObject {
    pub ob_base: PyObject,
    #[doc = " Description of the C function to call"]
    pub m_ml: *mut PyMethodDef,
    #[doc = " Passed as 'self' arg to the C func, can be NULL"]
    pub m_self: *mut PyObject,
    #[doc = " The __module__ attribute, can be anything"]
    pub m_module: *mut PyObject,
    #[doc = " List of weak references"]
    pub m_weakreflist: *mut PyObject,
    pub vectorcall: vectorcallfunc,
}
#[test]
fn bindgen_test_layout_PyCFunctionObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyCFunctionObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCFunctionObject>(),
        56usize,
        concat!("Size of: ", stringify!(PyCFunctionObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCFunctionObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyCFunctionObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCFunctionObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ml) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCFunctionObject),
            "::",
            stringify!(m_ml)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_self) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCFunctionObject),
            "::",
            stringify!(m_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCFunctionObject),
            "::",
            stringify!(m_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_weakreflist) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCFunctionObject),
            "::",
            stringify!(m_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectorcall) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCFunctionObject),
            "::",
            stringify!(vectorcall)
        )
    );
}
impl Default for PyCFunctionObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCMethodObject {
    pub func: PyCFunctionObject,
    #[doc = " Class that defines this method"]
    pub mm_class: *mut PyTypeObject,
}
#[test]
fn bindgen_test_layout_PyCMethodObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyCMethodObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCMethodObject>(),
        64usize,
        concat!("Size of: ", stringify!(PyCMethodObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCMethodObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyCMethodObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCMethodObject),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mm_class) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCMethodObject),
            "::",
            stringify!(mm_class)
        )
    );
}
impl Default for PyCMethodObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyModule_Type: PyTypeObject;
}
extern "C" {
    pub fn PyModule_NewObject(name: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyModule_New(name: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyModule_GetDict(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyModule_GetNameObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyModule_GetName(arg1: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyModule_GetFilename(arg1: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyModule_GetFilenameObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyModule_Clear(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyModule_ClearDict(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyModuleSpec_IsInitializing(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyModule_GetDef(arg1: *mut PyObject) -> *mut PyModuleDef;
}
extern "C" {
    pub fn PyModule_GetState(arg1: *mut PyObject) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " New in 3.5"]
    pub fn PyModuleDef_Init(arg1: *mut PyModuleDef) -> *mut PyObject;
}
extern "C" {
    pub static mut PyModuleDef_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyModuleDef_Base {
    pub ob_base: PyObject,
    pub m_init: ::std::option::Option<unsafe extern "C" fn() -> *mut PyObject>,
    pub m_index: Py_ssize_t,
    pub m_copy: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyModuleDef_Base() {
    const UNINIT: ::std::mem::MaybeUninit<PyModuleDef_Base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyModuleDef_Base>(),
        40usize,
        concat!("Size of: ", stringify!(PyModuleDef_Base))
    );
    assert_eq!(
        ::std::mem::align_of::<PyModuleDef_Base>(),
        8usize,
        concat!("Alignment of ", stringify!(PyModuleDef_Base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef_Base),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef_Base),
            "::",
            stringify!(m_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef_Base),
            "::",
            stringify!(m_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_copy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef_Base),
            "::",
            stringify!(m_copy)
        )
    );
}
impl Default for PyModuleDef_Base {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " New in 3.5"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyModuleDef_Slot {
    pub slot: ::std::os::raw::c_int,
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PyModuleDef_Slot() {
    const UNINIT: ::std::mem::MaybeUninit<PyModuleDef_Slot> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyModuleDef_Slot>(),
        16usize,
        concat!("Size of: ", stringify!(PyModuleDef_Slot))
    );
    assert_eq!(
        ::std::mem::align_of::<PyModuleDef_Slot>(),
        8usize,
        concat!("Alignment of ", stringify!(PyModuleDef_Slot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef_Slot),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef_Slot),
            "::",
            stringify!(value)
        )
    );
}
impl Default for PyModuleDef_Slot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyModuleDef {
    pub m_base: PyModuleDef_Base,
    pub m_name: *const ::std::os::raw::c_char,
    pub m_doc: *const ::std::os::raw::c_char,
    pub m_size: Py_ssize_t,
    pub m_methods: *mut PyMethodDef,
    pub m_slots: *mut PyModuleDef_Slot,
    pub m_traverse: traverseproc,
    pub m_clear: inquiry,
    pub m_free: freefunc,
}
#[test]
fn bindgen_test_layout_PyModuleDef() {
    const UNINIT: ::std::mem::MaybeUninit<PyModuleDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyModuleDef>(),
        104usize,
        concat!("Size of: ", stringify!(PyModuleDef))
    );
    assert_eq!(
        ::std::mem::align_of::<PyModuleDef>(),
        8usize,
        concat!("Alignment of ", stringify!(PyModuleDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_doc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_methods) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_slots) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_slots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_traverse) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_traverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_clear) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_free) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyModuleDef),
            "::",
            stringify!(m_free)
        )
    );
}
impl Default for PyModuleDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Function objects and code objects should not be confused with each other:\n\n Function objects are created by the execution of the 'def' statement.\n They reference a code object in their __code__ attribute, which is a\n purely syntactic object, i.e. nothing more than a compiled version of some\n source code lines.  There is one code object per source code \"fragment\",\n but each code object can be referenced by zero or many function objects\n depending only on how many times the 'def' statement in the source was\n executed so far."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyFunctionObject {
    pub ob_base: PyObject,
    #[doc = " A code object, the __code__ attribute"]
    pub func_code: *mut PyObject,
    #[doc = " A dictionary (other mappings won't do)"]
    pub func_globals: *mut PyObject,
    #[doc = " NULL or a tuple"]
    pub func_defaults: *mut PyObject,
    #[doc = " NULL or a dict"]
    pub func_kwdefaults: *mut PyObject,
    #[doc = " NULL or a tuple of cell objects"]
    pub func_closure: *mut PyObject,
    #[doc = " The __doc__ attribute, can be anything"]
    pub func_doc: *mut PyObject,
    #[doc = " The __name__ attribute, a string object"]
    pub func_name: *mut PyObject,
    #[doc = " The __dict__ attribute, a dict or NULL"]
    pub func_dict: *mut PyObject,
    #[doc = " List of weak references"]
    pub func_weakreflist: *mut PyObject,
    #[doc = " The __module__ attribute, can be anything"]
    pub func_module: *mut PyObject,
    #[doc = " Annotations, a dict or NULL"]
    pub func_annotations: *mut PyObject,
    #[doc = " The qualified name"]
    pub func_qualname: *mut PyObject,
    pub vectorcall: vectorcallfunc,
}
#[test]
fn bindgen_test_layout_PyFunctionObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyFunctionObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyFunctionObject>(),
        120usize,
        concat!("Size of: ", stringify!(PyFunctionObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyFunctionObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyFunctionObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_code) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_globals) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_globals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_defaults) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_kwdefaults) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_kwdefaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_closure) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_closure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_doc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_dict) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_weakreflist) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_module) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_annotations) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_annotations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_qualname) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(func_qualname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectorcall) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFunctionObject),
            "::",
            stringify!(vectorcall)
        )
    );
}
impl Default for PyFunctionObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyFunction_Type: PyTypeObject;
}
extern "C" {
    pub fn PyFunction_New(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_NewWithQualName(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_GetCode(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_GetGlobals(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_GetModule(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_GetDefaults(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_SetDefaults(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyFunction_GetKwDefaults(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_SetKwDefaults(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyFunction_GetClosure(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_SetClosure(arg1: *mut PyObject, arg2: *mut PyObject)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyFunction_GetAnnotations(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFunction_SetAnnotations(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyFunction_Vectorcall(
        func: *mut PyObject,
        stack: *const *mut PyObject,
        nargsf: usize,
        kwnames: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " The classmethod and staticmethod types lives here, too"]
    pub static mut PyClassMethod_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyStaticMethod_Type: PyTypeObject;
}
extern "C" {
    pub fn PyClassMethod_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyStaticMethod_New(arg1: *mut PyObject) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMethodObject {
    pub ob_base: PyObject,
    #[doc = " The callable object implementing the method"]
    pub im_func: *mut PyObject,
    #[doc = " The instance it is bound to"]
    pub im_self: *mut PyObject,
    #[doc = " List of weak references"]
    pub im_weakreflist: *mut PyObject,
    pub vectorcall: vectorcallfunc,
}
#[test]
fn bindgen_test_layout_PyMethodObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyMethodObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMethodObject>(),
        48usize,
        concat!("Size of: ", stringify!(PyMethodObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMethodObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMethodObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodObject),
            "::",
            stringify!(im_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im_self) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodObject),
            "::",
            stringify!(im_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im_weakreflist) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodObject),
            "::",
            stringify!(im_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectorcall) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodObject),
            "::",
            stringify!(vectorcall)
        )
    );
}
impl Default for PyMethodObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyMethod_Type: PyTypeObject;
}
extern "C" {
    pub fn PyMethod_New(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyMethod_Function(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyMethod_Self(arg1: *mut PyObject) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyInstanceMethodObject {
    pub ob_base: PyObject,
    pub func: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyInstanceMethodObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyInstanceMethodObject> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyInstanceMethodObject>(),
        24usize,
        concat!("Size of: ", stringify!(PyInstanceMethodObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyInstanceMethodObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyInstanceMethodObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyInstanceMethodObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyInstanceMethodObject),
            "::",
            stringify!(func)
        )
    );
}
impl Default for PyInstanceMethodObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyInstanceMethod_Type: PyTypeObject;
}
extern "C" {
    pub fn PyInstanceMethod_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyInstanceMethod_Function(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFile_FromFd(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *const ::std::os::raw::c_char,
        arg6: *const ::std::os::raw::c_char,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyFile_GetLine(arg1: *mut PyObject, arg2: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    pub fn PyFile_WriteObject(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyFile_WriteString(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyObject_AsFileDescriptor(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The default encoding used by the platform file system APIs\nIf non-NULL, this is different than the default encoding for strings"]
    pub static mut Py_FileSystemDefaultEncoding: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut Py_FileSystemDefaultEncodeErrors: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut Py_HasFileSystemDefaultEncoding: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Py_UTF8Mode: ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_UniversalNewlineFgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
        arg4: *mut PyObject,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The std printer acts as a preliminary sys.stderr until the new io\ninfrastructure is in place."]
    pub fn PyFile_NewStdPrinter(arg1: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    pub static mut PyStdPrinter_Type: PyTypeObject;
}
pub type Py_OpenCodeHookFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,
>;
extern "C" {
    pub fn PyFile_OpenCode(utf8path: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyFile_OpenCodeObject(path: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyFile_SetOpenCodeHook(
        hook: Py_OpenCodeHookFunction,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PyCapsule_Type: PyTypeObject;
}
pub type PyCapsule_Destructor = ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject)>;
extern "C" {
    pub fn PyCapsule_New(
        pointer: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        destructor: PyCapsule_Destructor,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyCapsule_GetPointer(
        capsule: *mut PyObject,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyCapsule_GetDestructor(capsule: *mut PyObject) -> PyCapsule_Destructor;
}
extern "C" {
    pub fn PyCapsule_GetName(capsule: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyCapsule_GetContext(capsule: *mut PyObject) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyCapsule_IsValid(
        capsule: *mut PyObject,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCapsule_SetPointer(
        capsule: *mut PyObject,
        pointer: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCapsule_SetDestructor(
        capsule: *mut PyObject,
        destructor: PyCapsule_Destructor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCapsule_SetName(
        capsule: *mut PyObject,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCapsule_SetContext(
        capsule: *mut PyObject,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCapsule_Import(
        name: *const ::std::os::raw::c_char,
        no_block: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
pub type _Py_CODEUNIT = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PyOpcache {
    _unused: [u8; 0],
}
#[doc = " Bytecode object"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCodeObject {
    pub ob_base: PyObject,
    #[doc = " #arguments, except *args"]
    pub co_argcount: ::std::os::raw::c_int,
    #[doc = " #positional only arguments"]
    pub co_posonlyargcount: ::std::os::raw::c_int,
    #[doc = " #keyword only arguments"]
    pub co_kwonlyargcount: ::std::os::raw::c_int,
    #[doc = " #local variables"]
    pub co_nlocals: ::std::os::raw::c_int,
    #[doc = " #entries needed for evaluation stack"]
    pub co_stacksize: ::std::os::raw::c_int,
    #[doc = " CO_..., see below"]
    pub co_flags: ::std::os::raw::c_int,
    #[doc = " first source line number"]
    pub co_firstlineno: ::std::os::raw::c_int,
    #[doc = " instruction opcodes"]
    pub co_code: *mut PyObject,
    #[doc = " list (constants used)"]
    pub co_consts: *mut PyObject,
    #[doc = " list of strings (names used)"]
    pub co_names: *mut PyObject,
    #[doc = " tuple of strings (local variable names)"]
    pub co_varnames: *mut PyObject,
    #[doc = " tuple of strings (free variable names)"]
    pub co_freevars: *mut PyObject,
    #[doc = " tuple of strings (cell variable names)"]
    pub co_cellvars: *mut PyObject,
    #[doc = " Maps cell vars which are arguments."]
    pub co_cell2arg: *mut Py_ssize_t,
    #[doc = " unicode (where it was loaded from)"]
    pub co_filename: *mut PyObject,
    #[doc = " unicode (name, for reference)"]
    pub co_name: *mut PyObject,
    #[doc = " string (encoding addr<->lineno mapping) See\nObjects/lnotab_notes.txt for details."]
    pub co_lnotab: *mut PyObject,
    #[doc = " for optimization only (see frameobject.c)"]
    pub co_zombieframe: *mut ::std::os::raw::c_void,
    #[doc = " to support weakrefs to code objects"]
    pub co_weakreflist: *mut PyObject,
    #[doc = " Scratch space for extra data relating to the code object.\nType is a void* to keep the format private in codeobject.c to force\npeople to go through the proper APIs."]
    pub co_extra: *mut ::std::os::raw::c_void,
    #[doc = " co_opcache_map is indexed by (next_instr - first_instr).\n  * 0 means there is no cache for this opcode.\n  * n > 0 means there is cache in co_opcache[n-1]."]
    pub co_opcache_map: *mut ::std::os::raw::c_uchar,
    pub co_opcache: *mut _PyOpcache,
    #[doc = " used to determine when create a cache."]
    pub co_opcache_flag: ::std::os::raw::c_int,
    #[doc = " length of co_opcache."]
    pub co_opcache_size: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_PyCodeObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyCodeObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCodeObject>(),
        176usize,
        concat!("Size of: ", stringify!(PyCodeObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCodeObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyCodeObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_argcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_argcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_posonlyargcount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_posonlyargcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_kwonlyargcount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_kwonlyargcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_nlocals) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_nlocals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_stacksize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_stacksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_firstlineno) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_firstlineno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_code) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_consts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_consts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_names) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_varnames) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_varnames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_freevars) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_freevars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_cellvars) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_cellvars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_cell2arg) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_cell2arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_filename) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_name) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_lnotab) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_lnotab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_zombieframe) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_zombieframe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_weakreflist) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_extra) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_opcache_map) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_opcache_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_opcache) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_opcache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_opcache_flag) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_opcache_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).co_opcache_size) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCodeObject),
            "::",
            stringify!(co_opcache_size)
        )
    );
}
impl Default for PyCodeObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyCode_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Public interface"]
    pub fn PyCode_New(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut PyObject,
        arg7: *mut PyObject,
        arg8: *mut PyObject,
        arg9: *mut PyObject,
        arg10: *mut PyObject,
        arg11: *mut PyObject,
        arg12: *mut PyObject,
        arg13: *mut PyObject,
        arg14: ::std::os::raw::c_int,
        arg15: *mut PyObject,
    ) -> *mut PyCodeObject;
}
extern "C" {
    pub fn PyCode_NewWithPosOnlyArgs(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *mut PyObject,
        arg8: *mut PyObject,
        arg9: *mut PyObject,
        arg10: *mut PyObject,
        arg11: *mut PyObject,
        arg12: *mut PyObject,
        arg13: *mut PyObject,
        arg14: *mut PyObject,
        arg15: ::std::os::raw::c_int,
        arg16: *mut PyObject,
    ) -> *mut PyCodeObject;
}
extern "C" {
    #[doc = " Creates a new empty code object with the specified source location."]
    pub fn PyCode_NewEmpty(
        filename: *const ::std::os::raw::c_char,
        funcname: *const ::std::os::raw::c_char,
        firstlineno: ::std::os::raw::c_int,
    ) -> *mut PyCodeObject;
}
extern "C" {
    #[doc = " Return the line number associated with the specified bytecode index\nin this code object.  If you just need the line number of a frame,\nuse PyFrame_GetLineNumber() instead."]
    pub fn PyCode_Addr2Line(
        arg1: *mut PyCodeObject,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " for internal use only"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _addr_pair {
    pub ap_lower: ::std::os::raw::c_int,
    pub ap_upper: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__addr_pair() {
    const UNINIT: ::std::mem::MaybeUninit<_addr_pair> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_addr_pair>(),
        8usize,
        concat!("Size of: ", stringify!(_addr_pair))
    );
    assert_eq!(
        ::std::mem::align_of::<_addr_pair>(),
        4usize,
        concat!("Alignment of ", stringify!(_addr_pair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_addr_pair),
            "::",
            stringify!(ap_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_upper) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_addr_pair),
            "::",
            stringify!(ap_upper)
        )
    );
}
#[doc = " for internal use only"]
pub type PyAddrPair = _addr_pair;
extern "C" {
    #[doc = " Update *bounds to describe the first and one-past-the-last instructions in the\nsame line as lasti.  Return the number of that line."]
    pub fn _PyCode_CheckLineNumber(
        co: *mut PyCodeObject,
        lasti: ::std::os::raw::c_int,
        bounds: *mut PyAddrPair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a comparable key used to compare constants taking in account the\n object type. It is used to make sure types are not coerced (e.g., float and\n complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms\n\n Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)\n depending on the type and the value. The type is the first item to not\n compare bytes and str which can raise a BytesWarning exception."]
    pub fn _PyCode_ConstantKey(obj: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCode_Optimize(
        code: *mut PyObject,
        consts: *mut PyObject,
        names: *mut PyObject,
        lnotab: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyCode_GetExtra(
        code: *mut PyObject,
        index: Py_ssize_t,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyCode_SetExtra(
        code: *mut PyObject,
        index: Py_ssize_t,
        extra: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _frame {
    _unused: [u8; 0],
}
pub type PyFrameObject = _frame;
extern "C" {
    #[doc = " Return the line of code the frame is currently executing."]
    pub fn PyFrame_GetLineNumber(arg1: *mut PyFrameObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyFrame_GetCode(frame: *mut PyFrameObject) -> *mut PyCodeObject;
}
extern "C" {
    #[doc = " Traceback interface"]
    pub fn PyTraceBack_Here(arg1: *mut PyFrameObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyTraceBack_Print(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reveal traceback type so we can typecheck traceback objects"]
    pub static mut PyTraceBack_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _traceback {
    pub ob_base: PyObject,
    pub tb_next: *mut _traceback,
    pub tb_frame: *mut PyFrameObject,
    pub tb_lasti: ::std::os::raw::c_int,
    pub tb_lineno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__traceback() {
    const UNINIT: ::std::mem::MaybeUninit<_traceback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_traceback>(),
        40usize,
        concat!("Size of: ", stringify!(_traceback))
    );
    assert_eq!(
        ::std::mem::align_of::<_traceback>(),
        8usize,
        concat!("Alignment of ", stringify!(_traceback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_traceback),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tb_next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_traceback),
            "::",
            stringify!(tb_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tb_frame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_traceback),
            "::",
            stringify!(tb_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tb_lasti) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_traceback),
            "::",
            stringify!(tb_lasti)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tb_lineno) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_traceback),
            "::",
            stringify!(tb_lineno)
        )
    );
}
impl Default for _traceback {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PyTracebackObject = _traceback;
extern "C" {
    pub fn _Py_DisplaySourceLine(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyTraceback_Add(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Don't use this directly"]
    pub static mut _Py_EllipsisObject: PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PySliceObject {
    pub ob_base: PyObject,
    #[doc = " not NULL"]
    pub start: *mut PyObject,
    #[doc = " not NULL"]
    pub stop: *mut PyObject,
    #[doc = " not NULL"]
    pub step: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PySliceObject() {
    const UNINIT: ::std::mem::MaybeUninit<PySliceObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PySliceObject>(),
        40usize,
        concat!("Size of: ", stringify!(PySliceObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PySliceObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PySliceObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PySliceObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PySliceObject),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PySliceObject),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PySliceObject),
            "::",
            stringify!(step)
        )
    );
}
impl Default for PySliceObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PySlice_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyEllipsis_Type: PyTypeObject;
}
extern "C" {
    pub fn PySlice_New(
        start: *mut PyObject,
        stop: *mut PyObject,
        step: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PySlice_FromIndices(start: Py_ssize_t, stop: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub fn _PySlice_GetLongIndices(
        self_: *mut PySliceObject,
        length: *mut PyObject,
        start_ptr: *mut *mut PyObject,
        stop_ptr: *mut *mut PyObject,
        step_ptr: *mut *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySlice_GetIndices(
        r: *mut PyObject,
        length: Py_ssize_t,
        start: *mut Py_ssize_t,
        stop: *mut Py_ssize_t,
        step: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySlice_GetIndicesEx(
        r: *mut PyObject,
        length: Py_ssize_t,
        start: *mut Py_ssize_t,
        stop: *mut Py_ssize_t,
        step: *mut Py_ssize_t,
        slicelength: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySlice_Unpack(
        slice: *mut PyObject,
        start: *mut Py_ssize_t,
        stop: *mut Py_ssize_t,
        step: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySlice_AdjustIndices(
        length: Py_ssize_t,
        start: *mut Py_ssize_t,
        stop: *mut Py_ssize_t,
        step: Py_ssize_t,
    ) -> Py_ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCellObject {
    pub ob_base: PyObject,
    #[doc = " Content of the cell or NULL when empty"]
    pub ob_ref: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyCellObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyCellObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCellObject>(),
        24usize,
        concat!("Size of: ", stringify!(PyCellObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCellObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyCellObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCellObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_ref) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCellObject),
            "::",
            stringify!(ob_ref)
        )
    );
}
impl Default for PyCellObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyCell_Type: PyTypeObject;
}
extern "C" {
    pub fn PyCell_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCell_Get(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCell_Set(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PySeqIter_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyCallIter_Type: PyTypeObject;
}
extern "C" {
    pub fn PySeqIter_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCallIter_New(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
#[doc = " --- PyStatus -----------------------------------------------"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyStatus {
    pub _type: PyStatus__bindgen_ty_1,
    pub func: *const ::std::os::raw::c_char,
    pub err_msg: *const ::std::os::raw::c_char,
    pub exitcode: ::std::os::raw::c_int,
}
pub const PyStatus__PyStatus_TYPE_OK: PyStatus__bindgen_ty_1 = 0;
pub const PyStatus__PyStatus_TYPE_ERROR: PyStatus__bindgen_ty_1 = 1;
pub const PyStatus__PyStatus_TYPE_EXIT: PyStatus__bindgen_ty_1 = 2;
pub type PyStatus__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_PyStatus() {
    const UNINIT: ::std::mem::MaybeUninit<PyStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyStatus>(),
        32usize,
        concat!("Size of: ", stringify!(PyStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<PyStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(PyStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStatus),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStatus),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_msg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStatus),
            "::",
            stringify!(err_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exitcode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStatus),
            "::",
            stringify!(exitcode)
        )
    );
}
impl Default for PyStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn PyStatus_Ok() -> PyStatus;
}
extern "C" {
    pub fn PyStatus_Error(err_msg: *const ::std::os::raw::c_char) -> PyStatus;
}
extern "C" {
    pub fn PyStatus_NoMemory() -> PyStatus;
}
extern "C" {
    pub fn PyStatus_Exit(exitcode: ::std::os::raw::c_int) -> PyStatus;
}
extern "C" {
    pub fn PyStatus_IsError(err: PyStatus) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyStatus_IsExit(err: PyStatus) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyStatus_Exception(err: PyStatus) -> ::std::os::raw::c_int;
}
#[doc = " --- PyWideStringList ------------------------------------------------"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyWideStringList {
    #[doc = " If length is greater than zero, items must be non-NULL\nand all items strings must be non-NULL"]
    pub length: Py_ssize_t,
    pub items: *mut *mut wchar_t,
}
#[test]
fn bindgen_test_layout_PyWideStringList() {
    const UNINIT: ::std::mem::MaybeUninit<PyWideStringList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyWideStringList>(),
        16usize,
        concat!("Size of: ", stringify!(PyWideStringList))
    );
    assert_eq!(
        ::std::mem::align_of::<PyWideStringList>(),
        8usize,
        concat!("Alignment of ", stringify!(PyWideStringList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyWideStringList),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyWideStringList),
            "::",
            stringify!(items)
        )
    );
}
impl Default for PyWideStringList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn PyWideStringList_Append(list: *mut PyWideStringList, item: *const wchar_t) -> PyStatus;
}
extern "C" {
    pub fn PyWideStringList_Insert(
        list: *mut PyWideStringList,
        index: Py_ssize_t,
        item: *const wchar_t,
    ) -> PyStatus;
}
#[doc = " --- PyPreConfig -----------------------------------------------"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyPreConfig {
    #[doc = " _PyConfigInitEnum value"]
    pub _config_init: ::std::os::raw::c_int,
    #[doc = " Parse Py_PreInitializeFromBytesArgs() arguments?\nSee PyConfig.parse_argv"]
    pub parse_argv: ::std::os::raw::c_int,
    #[doc = " If greater than 0, enable isolated mode: sys.path contains\nneither the script's directory nor the user's site-packages directory.\n\nSet to 1 by the -I command line option. If set to -1 (default), inherit\nPy_IsolatedFlag value."]
    pub isolated: ::std::os::raw::c_int,
    #[doc = " If greater than 0: use environment variables.\nSet to 0 by -E command line option. If set to -1 (default), it is\nset to !Py_IgnoreEnvironmentFlag."]
    pub use_environment: ::std::os::raw::c_int,
    #[doc = " Set the LC_CTYPE locale to the user preferred locale? If equals to 0,\nset coerce_c_locale and coerce_c_locale_warn to 0."]
    pub configure_locale: ::std::os::raw::c_int,
    #[doc = " Coerce the LC_CTYPE locale if it's equal to \"C\"? (PEP 538)\n\nSet to 0 by PYTHONCOERCECLOCALE=0. Set to 1 by PYTHONCOERCECLOCALE=1.\nSet to 2 if the user preferred LC_CTYPE locale is \"C\".\n\nIf it is equal to 1, LC_CTYPE locale is read to decide if it should be\ncoerced or not (ex: PYTHONCOERCECLOCALE=1). Internally, it is set to 2\nif the LC_CTYPE locale must be coerced.\n\nDisable by default (set to 0). Set it to -1 to let Python decide if it\nshould be enabled or not."]
    pub coerce_c_locale: ::std::os::raw::c_int,
    #[doc = " Emit a warning if the LC_CTYPE locale is coerced?\n\nSet to 1 by PYTHONCOERCECLOCALE=warn.\n\nDisable by default (set to 0). Set it to -1 to let Python decide if it\nshould be enabled or not."]
    pub coerce_c_locale_warn: ::std::os::raw::c_int,
    #[doc = " Enable UTF-8 mode? (PEP 540)\n\nDisabled by default (equals to 0).\n\nSet to 1 by \"-X utf8\" and \"-X utf8=1\" command line options.\nSet to 1 by PYTHONUTF8=1 environment variable.\n\nSet to 0 by \"-X utf8=0\" and PYTHONUTF8=0.\n\nIf equals to -1, it is set to 1 if the LC_CTYPE locale is \"C\" or\n\"POSIX\", otherwise it is set to 0. Inherit Py_UTF8Mode value value."]
    pub utf8_mode: ::std::os::raw::c_int,
    #[doc = " If non-zero, enable the Python Development Mode.\n\nSet to 1 by the -X dev command line option. Set by the PYTHONDEVMODE\nenvironment variable."]
    pub dev_mode: ::std::os::raw::c_int,
    #[doc = " Memory allocator: PYTHONMALLOC env var.\nSee PyMemAllocatorName for valid values."]
    pub allocator: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PyPreConfig() {
    const UNINIT: ::std::mem::MaybeUninit<PyPreConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyPreConfig>(),
        40usize,
        concat!("Size of: ", stringify!(PyPreConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<PyPreConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(PyPreConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._config_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(_config_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_argv) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(parse_argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isolated) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(isolated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_environment) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(use_environment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).configure_locale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(configure_locale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coerce_c_locale) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(coerce_c_locale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coerce_c_locale_warn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(coerce_c_locale_warn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utf8_mode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(utf8_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_mode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(dev_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PyPreConfig),
            "::",
            stringify!(allocator)
        )
    );
}
extern "C" {
    pub fn PyPreConfig_InitPythonConfig(config: *mut PyPreConfig);
}
extern "C" {
    pub fn PyPreConfig_InitIsolatedConfig(config: *mut PyPreConfig);
}
#[doc = " --- PyConfig ----------------------------------------------"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyConfig {
    #[doc = " _PyConfigInitEnum value"]
    pub _config_init: ::std::os::raw::c_int,
    #[doc = " Isolated mode? see PyPreConfig.isolated"]
    pub isolated: ::std::os::raw::c_int,
    #[doc = " Use environment variables? see PyPreConfig.use_environment"]
    pub use_environment: ::std::os::raw::c_int,
    #[doc = " Python Development Mode? See PyPreConfig.dev_mode"]
    pub dev_mode: ::std::os::raw::c_int,
    #[doc = " Install signal handlers? Yes by default."]
    pub install_signal_handlers: ::std::os::raw::c_int,
    #[doc = " PYTHONHASHSEED=x"]
    pub use_hash_seed: ::std::os::raw::c_int,
    pub hash_seed: ::std::os::raw::c_ulong,
    #[doc = " Enable faulthandler?\nSet to 1 by -X faulthandler and PYTHONFAULTHANDLER. -1 means unset."]
    pub faulthandler: ::std::os::raw::c_int,
    #[doc = " Enable PEG parser?\n1 by default, set to 0 by -X oldparser and PYTHONOLDPARSER"]
    pub _use_peg_parser: ::std::os::raw::c_int,
    #[doc = " Enable tracemalloc?\nSet by -X tracemalloc=N and PYTHONTRACEMALLOC. -1 means unset"]
    pub tracemalloc: ::std::os::raw::c_int,
    #[doc = " PYTHONPROFILEIMPORTTIME, -X importtime"]
    pub import_time: ::std::os::raw::c_int,
    #[doc = " -X showrefcount"]
    pub show_ref_count: ::std::os::raw::c_int,
    #[doc = " PYTHONDUMPREFS"]
    pub dump_refs: ::std::os::raw::c_int,
    #[doc = " PYTHONMALLOCSTATS"]
    pub malloc_stats: ::std::os::raw::c_int,
    #[doc = " Python filesystem encoding and error handler:\nsys.getfilesystemencoding() and sys.getfilesystemencodeerrors().\n\nDefault encoding and error handler:\n\n if Py_SetStandardStreamEncoding() has been called: they have the\nhighest priority;\n PYTHONIOENCODING environment variable;\n The UTF-8 Mode uses UTF-8/surrogateescape;\n If Python forces the usage of the ASCII encoding (ex: C locale\nor POSIX locale on FreeBSD or HP-UX), use ASCII/surrogateescape;\n locale encoding: ANSI code page on Windows, UTF-8 on Android and\nVxWorks, LC_CTYPE locale encoding on other platforms;\n On Windows, \"surrogateescape\" error handler;\n \"surrogateescape\" error handler if the LC_CTYPE locale is \"C\" or \"POSIX\";\n \"surrogateescape\" error handler if the LC_CTYPE locale has been coerced\n(PEP 538);\n \"strict\" error handler.\n\nSupported error handlers: \"strict\", \"surrogateescape\" and\n\"surrogatepass\". The surrogatepass error handler is only supported\nif Py_DecodeLocale() and Py_EncodeLocale() use directly the UTF-8 codec;\nit's only used on Windows.\n\ninitfsencoding() updates the encoding to the Python codec name.\nFor example, \"ANSI_X3.4-1968\" is replaced with \"ascii\".\n\nOn Windows, sys._enablelegacywindowsfsencoding() sets the\nencoding/errors to mbcs/replace at runtime.\n\n\nSee Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors."]
    pub filesystem_encoding: *mut wchar_t,
    pub filesystem_errors: *mut wchar_t,
    #[doc = " PYTHONPYCACHEPREFIX, -X pycache_prefix=PATH"]
    pub pycache_prefix: *mut wchar_t,
    #[doc = " Parse argv command line arguments?"]
    pub parse_argv: ::std::os::raw::c_int,
    #[doc = " Command line arguments (sys.argv).\n\nSet parse_argv to 1 to parse argv as Python command line arguments\nand then strip Python arguments from argv.\n\nIf argv is empty, an empty string is added to ensure that sys.argv\nalways exists and is never empty."]
    pub argv: PyWideStringList,
    #[doc = " Program name:\n\n- If Py_SetProgramName() was called, use its value.\n- On macOS, use PYTHONEXECUTABLE environment variable if set.\n- If WITH_NEXT_FRAMEWORK macro is defined, use __PYVENV_LAUNCHER__\nenvironment variable is set.\n- Use argv[0] if available and non-empty.\n- Use \"python\" on Windows, or \"python3 on other platforms."]
    pub program_name: *mut wchar_t,
    #[doc = " Command line -X options"]
    pub xoptions: PyWideStringList,
    #[doc = " Warnings options: lowest to highest priority. warnings.filters\nis built in the reverse order (highest to lowest priority)."]
    pub warnoptions: PyWideStringList,
    #[doc = " If equal to zero, disable the import of the module site and the\nsite-dependent manipulations of sys.path that it entails. Also disable\nthese manipulations if site is explicitly imported later (call\nsite.main() if you want them to be triggered).\n\nSet to 0 by the -S command line option. If set to -1 (default), it is\nset to !Py_NoSiteFlag."]
    pub site_import: ::std::os::raw::c_int,
    #[doc = " Bytes warnings:\n\n If equal to 1, issue a warning when comparing bytes or bytearray with\nstr or bytes with int.\n If equal or greater to 2, issue an error.\n\nIncremented by the -b command line option. If set to -1 (default), inherit\nPy_BytesWarningFlag value."]
    pub bytes_warning: ::std::os::raw::c_int,
    #[doc = " If greater than 0, enable inspect: when a script is passed as first\nargument or the -c option is used, enter interactive mode after\nexecuting the script or the command, even when sys.stdin does not appear\nto be a terminal.\n\nIncremented by the -i command line option. Set to 1 if the PYTHONINSPECT\nenvironment variable is non-empty. If set to -1 (default), inherit\nPy_InspectFlag value."]
    pub inspect: ::std::os::raw::c_int,
    #[doc = " If greater than 0: enable the interactive mode (REPL).\n\nIncremented by the -i command line option. If set to -1 (default),\ninherit Py_InteractiveFlag value."]
    pub interactive: ::std::os::raw::c_int,
    #[doc = " Optimization level.\n\nIncremented by the -O command line option. Set by the PYTHONOPTIMIZE\nenvironment variable. If set to -1 (default), inherit Py_OptimizeFlag\nvalue."]
    pub optimization_level: ::std::os::raw::c_int,
    #[doc = " If greater than 0, enable the debug mode: turn on parser debugging\noutput (for expert only, depending on compilation options).\n\nIncremented by the -d command line option. Set by the PYTHONDEBUG\nenvironment variable. If set to -1 (default), inherit Py_DebugFlag\nvalue."]
    pub parser_debug: ::std::os::raw::c_int,
    #[doc = " If equal to 0, Python won't try to write ``.pyc`` files on the\nimport of source modules.\n\nSet to 0 by the -B command line option and the PYTHONDONTWRITEBYTECODE\nenvironment variable. If set to -1 (default), it is set to\nPy_DontWriteBytecodeFlag."]
    pub write_bytecode: ::std::os::raw::c_int,
    #[doc = " If greater than 0, enable the verbose mode: print a message each time a\nmodule is initialized, showing the place (filename or built-in module)\nfrom which it is loaded.\n\nIf greater or equal to 2, print a message for each file that is checked\nfor when searching for a module. Also provides information on module\ncleanup at exit.\n\nIncremented by the -v option. Set by the PYTHONVERBOSE environment\nvariable. If set to -1 (default), inherit Py_VerboseFlag value."]
    pub verbose: ::std::os::raw::c_int,
    #[doc = " If greater than 0, enable the quiet mode: Don't display the copyright\nand version messages even in interactive mode.\n\nIncremented by the -q option. If set to -1 (default), inherit\nPy_QuietFlag value."]
    pub quiet: ::std::os::raw::c_int,
    #[doc = " If greater than 0, don't add the user site-packages directory to\nsys.path.\n\nSet to 0 by the -s and -I command line options , and the PYTHONNOUSERSITE\nenvironment variable. If set to -1 (default), it is set to\nPy_NoUserSiteDirectory."]
    pub user_site_directory: ::std::os::raw::c_int,
    #[doc = " If non-zero, configure C standard steams (stdio, stdout,\nstderr):\n\n- Set O_BINARY mode on Windows.\n- If buffered_stdio is equal to zero, make streams unbuffered.\nOtherwise, enable streams buffering if interactive is non-zero."]
    pub configure_c_stdio: ::std::os::raw::c_int,
    #[doc = " If equal to 0, enable unbuffered mode: force the stdout and stderr\nstreams to be unbuffered.\n\nSet to 0 by the -u option. Set by the PYTHONUNBUFFERED environment\nvariable.\nIf set to -1 (default), it is set to !Py_UnbufferedStdioFlag."]
    pub buffered_stdio: ::std::os::raw::c_int,
    #[doc = " Encoding of sys.stdin, sys.stdout and sys.stderr.\nValue set from PYTHONIOENCODING environment variable and\nPy_SetStandardStreamEncoding() function.\nSee also 'stdio_errors' attribute."]
    pub stdio_encoding: *mut wchar_t,
    #[doc = " Error handler of sys.stdin and sys.stdout.\nValue set from PYTHONIOENCODING environment variable and\nPy_SetStandardStreamEncoding() function.\nSee also 'stdio_encoding' attribute."]
    pub stdio_errors: *mut wchar_t,
    #[doc = " Value of the --check-hash-based-pycs command line option:\n\n- \"default\" means the 'check_source' flag in hash-based pycs\ndetermines invalidation\n- \"always\" causes the interpreter to hash the source file for\ninvalidation regardless of value of 'check_source' bit\n- \"never\" causes the interpreter to always assume hash-based pycs are\nvalid\n\nThe default value is \"default\".\n\nSee PEP 552 \"Deterministic pycs\" for more details."]
    pub check_hash_pycs_mode: *mut wchar_t,
    #[doc = " If greater than 0, suppress _PyPathConfig_Calculate() warnings on Unix.\nThe parameter has no effect on Windows.\n\nIf set to -1 (default), inherit !Py_FrozenFlag value."]
    pub pathconfig_warnings: ::std::os::raw::c_int,
    #[doc = " PYTHONPATH environment variable"]
    pub pythonpath_env: *mut wchar_t,
    #[doc = " PYTHONHOME environment variable,\nsee also Py_SetPythonHome()."]
    pub home: *mut wchar_t,
    #[doc = " If non-zero, use module_search_paths"]
    pub module_search_paths_set: ::std::os::raw::c_int,
    #[doc = " sys.path paths. Computed if\nmodule_search_paths_set is equal\nto zero."]
    pub module_search_paths: PyWideStringList,
    #[doc = " sys.executable"]
    pub executable: *mut wchar_t,
    #[doc = " sys._base_executable"]
    pub base_executable: *mut wchar_t,
    #[doc = " sys.prefix"]
    pub prefix: *mut wchar_t,
    #[doc = " sys.base_prefix"]
    pub base_prefix: *mut wchar_t,
    #[doc = " sys.exec_prefix"]
    pub exec_prefix: *mut wchar_t,
    #[doc = " sys.base_exec_prefix"]
    pub base_exec_prefix: *mut wchar_t,
    #[doc = " sys.platlibdir"]
    pub platlibdir: *mut wchar_t,
    #[doc = " Skip the first line of the source ('run_filename' parameter), allowing use of non-Unix forms of\n\"#!cmd\".  This is intended for a DOS specific hack only.\n\nSet by the -x command line option."]
    pub skip_source_first_line: ::std::os::raw::c_int,
    #[doc = " -c command line argument"]
    pub run_command: *mut wchar_t,
    #[doc = " -m command line argument"]
    pub run_module: *mut wchar_t,
    #[doc = " Trailing command line argument without -c or -m"]
    pub run_filename: *mut wchar_t,
    #[doc = " Install importlib? If set to 0, importlib is not initialized at all.\nNeeded by freeze_importlib."]
    pub _install_importlib: ::std::os::raw::c_int,
    #[doc = " If equal to 0, stop Python initialization before the \"main\" phase"]
    pub _init_main: ::std::os::raw::c_int,
    #[doc = " If non-zero, disallow threads, subprocesses, and fork.\nDefault: 0."]
    pub _isolated_interpreter: ::std::os::raw::c_int,
    #[doc = " Original command line arguments. If _orig_argv is empty and _argv is\nnot equal to [''], PyConfig_Read() copies the configuration 'argv' list\ninto '_orig_argv' list before modifying 'argv' list (if parse_argv\nis non-zero).\n\n_PyConfig_Write() initializes Py_GetArgcArgv() to this list."]
    pub _orig_argv: PyWideStringList,
}
#[test]
fn bindgen_test_layout_PyConfig() {
    const UNINIT: ::std::mem::MaybeUninit<PyConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyConfig>(),
        392usize,
        concat!("Size of: ", stringify!(PyConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<PyConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(PyConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._config_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(_config_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isolated) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(isolated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_environment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(use_environment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(dev_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).install_signal_handlers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(install_signal_handlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_hash_seed) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(use_hash_seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_seed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(hash_seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).faulthandler) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(faulthandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._use_peg_parser) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(_use_peg_parser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracemalloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(tracemalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).import_time) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(import_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(show_ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_refs) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(dump_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc_stats) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(malloc_stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filesystem_encoding) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(filesystem_encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filesystem_errors) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(filesystem_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pycache_prefix) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(pycache_prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_argv) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(parse_argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).program_name) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(program_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xoptions) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(xoptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warnoptions) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(warnoptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).site_import) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(site_import)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_warning) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(bytes_warning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inspect) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(inspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interactive) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optimization_level) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(optimization_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_debug) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(parser_debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_bytecode) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(write_bytecode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quiet) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(quiet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_site_directory) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(user_site_directory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).configure_c_stdio) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(configure_c_stdio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffered_stdio) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(buffered_stdio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stdio_encoding) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(stdio_encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stdio_errors) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(stdio_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_hash_pycs_mode) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(check_hash_pycs_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathconfig_warnings) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(pathconfig_warnings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pythonpath_env) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(pythonpath_env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).home) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_search_paths_set) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(module_search_paths_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_search_paths) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(module_search_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).executable) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(executable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_executable) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(base_executable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_prefix) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(base_prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exec_prefix) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(exec_prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_exec_prefix) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(base_exec_prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).platlibdir) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(platlibdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_source_first_line) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(skip_source_first_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_command) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(run_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_module) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(run_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_filename) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(run_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._install_importlib) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(_install_importlib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._init_main) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(_init_main)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._isolated_interpreter) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(_isolated_interpreter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._orig_argv) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(PyConfig),
            "::",
            stringify!(_orig_argv)
        )
    );
}
impl Default for PyConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn PyConfig_InitPythonConfig(config: *mut PyConfig);
}
extern "C" {
    pub fn PyConfig_InitIsolatedConfig(config: *mut PyConfig);
}
extern "C" {
    pub fn PyConfig_Clear(arg1: *mut PyConfig);
}
extern "C" {
    pub fn PyConfig_SetString(
        config: *mut PyConfig,
        config_str: *mut *mut wchar_t,
        str_: *const wchar_t,
    ) -> PyStatus;
}
extern "C" {
    pub fn PyConfig_SetBytesString(
        config: *mut PyConfig,
        config_str: *mut *mut wchar_t,
        str_: *const ::std::os::raw::c_char,
    ) -> PyStatus;
}
extern "C" {
    pub fn PyConfig_Read(config: *mut PyConfig) -> PyStatus;
}
extern "C" {
    pub fn PyConfig_SetBytesArgv(
        config: *mut PyConfig,
        argc: Py_ssize_t,
        argv: *const *mut ::std::os::raw::c_char,
    ) -> PyStatus;
}
extern "C" {
    pub fn PyConfig_SetArgv(
        config: *mut PyConfig,
        argc: Py_ssize_t,
        argv: *const *mut wchar_t,
    ) -> PyStatus;
}
extern "C" {
    pub fn PyConfig_SetWideStringList(
        config: *mut PyConfig,
        list: *mut PyWideStringList,
        length: Py_ssize_t,
        items: *mut *mut wchar_t,
    ) -> PyStatus;
}
extern "C" {
    #[doc = " Get the original command line arguments, before Python modified them.\n\nSee also PyConfig._orig_argv."]
    pub fn Py_GetArgcArgv(argc: *mut ::std::os::raw::c_int, argv: *mut *mut *mut wchar_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _is {
    _unused: [u8; 0],
}
#[doc = " struct _ts is defined in cpython/pystate.h"]
pub type PyThreadState = _ts;
#[doc = " struct _is is defined in internal/pycore_interp.h"]
pub type PyInterpreterState = _is;
extern "C" {
    pub fn PyInterpreterState_New() -> *mut PyInterpreterState;
}
extern "C" {
    pub fn PyInterpreterState_Clear(arg1: *mut PyInterpreterState);
}
extern "C" {
    pub fn PyInterpreterState_Delete(arg1: *mut PyInterpreterState);
}
extern "C" {
    #[doc = " New in 3.9 */\n/* Get the current interpreter state.\n\nIssue a fatal error if there no current Python thread state or no current\ninterpreter. It cannot return NULL.\n\nThe caller must hold the GIL."]
    pub fn PyInterpreterState_Get() -> *mut PyInterpreterState;
}
extern "C" {
    #[doc = " New in 3.8"]
    pub fn PyInterpreterState_GetDict(arg1: *mut PyInterpreterState) -> *mut PyObject;
}
extern "C" {
    #[doc = " New in 3.7"]
    pub fn PyInterpreterState_GetID(arg1: *mut PyInterpreterState) -> i64;
}
extern "C" {
    #[doc = " New in 3.3"]
    pub fn PyState_AddModule(arg1: *mut PyObject, arg2: *mut PyModuleDef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyState_RemoveModule(arg1: *mut PyModuleDef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyState_FindModule(arg1: *mut PyModuleDef) -> *mut PyObject;
}
extern "C" {
    pub fn PyThreadState_New(arg1: *mut PyInterpreterState) -> *mut PyThreadState;
}
extern "C" {
    pub fn PyThreadState_Clear(arg1: *mut PyThreadState);
}
extern "C" {
    pub fn PyThreadState_Delete(arg1: *mut PyThreadState);
}
extern "C" {
    #[doc = " Get the current thread state.\n\nWhen the current thread state is NULL, this issues a fatal error (so that\nthe caller needn't check for NULL).\n\nThe caller must hold the GIL.\n\nSee also PyThreadState_GET() and _PyThreadState_GET()."]
    pub fn PyThreadState_Get() -> *mut PyThreadState;
}
extern "C" {
    pub fn PyThreadState_Swap(arg1: *mut PyThreadState) -> *mut PyThreadState;
}
extern "C" {
    pub fn PyThreadState_GetDict() -> *mut PyObject;
}
extern "C" {
    pub fn PyThreadState_SetAsyncExc(
        arg1: ::std::os::raw::c_ulong,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " New in 3.9"]
    pub fn PyThreadState_GetInterpreter(tstate: *mut PyThreadState) -> *mut PyInterpreterState;
}
extern "C" {
    pub fn PyThreadState_GetFrame(tstate: *mut PyThreadState) -> *mut PyFrameObject;
}
extern "C" {
    pub fn PyThreadState_GetID(tstate: *mut PyThreadState) -> u64;
}
pub const PyGILState_STATE_PyGILState_LOCKED: PyGILState_STATE = 0;
pub const PyGILState_STATE_PyGILState_UNLOCKED: PyGILState_STATE = 1;
pub type PyGILState_STATE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Ensure that the current thread is ready to call the Python\nC API, regardless of the current state of Python, or of its\nthread lock.  This may be called as many times as desired\nby a thread so long as each call is matched with a call to\nPyGILState_Release().  In general, other thread-state APIs may\nbe used between _Ensure() and _Release() calls, so long as the\nthread-state is restored to its previous state before the Release().\nFor example, normal use of the Py_BEGIN_ALLOW_THREADS/\nPy_END_ALLOW_THREADS macros are acceptable.\n\nThe return value is an opaque \"handle\" to the thread state when\nPyGILState_Ensure() was called, and must be passed to\nPyGILState_Release() to ensure Python is left in the same state. Even\nthough recursive calls are allowed, these handles can *not* be shared -\neach unique call to PyGILState_Ensure must save the handle for its\ncall to PyGILState_Release.\n\nWhen the function returns, the current thread will hold the GIL.\n\nFailure is a fatal error."]
    pub fn PyGILState_Ensure() -> PyGILState_STATE;
}
extern "C" {
    #[doc = " Release any resources previously acquired.  After this call, Python's\nstate will be the same as it was prior to the corresponding\nPyGILState_Ensure() call (but generally this state will be unknown to\nthe caller, hence the use of the GILState API.)\n\nEvery call to PyGILState_Ensure must be matched by a call to\nPyGILState_Release on the same thread."]
    pub fn PyGILState_Release(arg1: PyGILState_STATE);
}
extern "C" {
    #[doc = " Helper/diagnostic function - get the current thread state for\nthis thread.  May return NULL if no GILState API has been used\non the current thread.  Note that the main thread always has such a\nthread-state, even if no auto-thread-state call has been made\non the main thread."]
    pub fn PyGILState_GetThisThreadState() -> *mut PyThreadState;
}
extern "C" {
    pub fn _PyInterpreterState_RequiresIDRef(
        arg1: *mut PyInterpreterState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyInterpreterState_RequireIDRef(
        arg1: *mut PyInterpreterState,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _PyInterpreterState_GetMainModule(arg1: *mut PyInterpreterState) -> *mut PyObject;
}
#[doc = " Py_tracefunc return -1 when raising an exception, or 0 for success."]
pub type Py_tracefunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyFrameObject,
        arg3: ::std::os::raw::c_int,
        arg4: *mut PyObject,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _err_stackitem {
    #[doc = " This struct represents an entry on the exception stack, which is a\n per-coroutine state. (Coroutine in the computer science sense,\n including the thread and generators).\n This ensures that the exception state is not impacted by \"yields\"\n from an except handler."]
    pub exc_type: *mut PyObject,
    #[doc = " This struct represents an entry on the exception stack, which is a\n per-coroutine state. (Coroutine in the computer science sense,\n including the thread and generators).\n This ensures that the exception state is not impacted by \"yields\"\n from an except handler."]
    pub exc_value: *mut PyObject,
    #[doc = " This struct represents an entry on the exception stack, which is a\n per-coroutine state. (Coroutine in the computer science sense,\n including the thread and generators).\n This ensures that the exception state is not impacted by \"yields\"\n from an except handler."]
    pub exc_traceback: *mut PyObject,
    pub previous_item: *mut _err_stackitem,
}
#[test]
fn bindgen_test_layout__err_stackitem() {
    const UNINIT: ::std::mem::MaybeUninit<_err_stackitem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_err_stackitem>(),
        32usize,
        concat!("Size of: ", stringify!(_err_stackitem))
    );
    assert_eq!(
        ::std::mem::align_of::<_err_stackitem>(),
        8usize,
        concat!("Alignment of ", stringify!(_err_stackitem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exc_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_err_stackitem),
            "::",
            stringify!(exc_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exc_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_err_stackitem),
            "::",
            stringify!(exc_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exc_traceback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_err_stackitem),
            "::",
            stringify!(exc_traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previous_item) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_err_stackitem),
            "::",
            stringify!(previous_item)
        )
    );
}
impl Default for _err_stackitem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _PyErr_StackItem = _err_stackitem;
#[doc = " Forward declarations for PyThreadState"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _ts {
    #[doc = " See Python/ceval.c for comments explaining most fields"]
    pub prev: *mut _ts,
    pub next: *mut _ts,
    pub interp: *mut PyInterpreterState,
    #[doc = " Borrowed reference to the current frame (it can be NULL)"]
    pub frame: *mut PyFrameObject,
    pub recursion_depth: ::std::os::raw::c_int,
    #[doc = " The stack has overflowed. Allow 50 more calls\nto handle the runtime error."]
    pub overflowed: ::std::os::raw::c_char,
    #[doc = " The current calls must not cause\na stack overflow."]
    pub recursion_critical: ::std::os::raw::c_char,
    pub stackcheck_counter: ::std::os::raw::c_int,
    #[doc = " 'tracing' keeps track of the execution depth when tracing/profiling.\nThis is to prevent the actual trace/profile code from being recorded in\nthe trace/profile."]
    pub tracing: ::std::os::raw::c_int,
    pub use_tracing: ::std::os::raw::c_int,
    pub c_profilefunc: Py_tracefunc,
    pub c_tracefunc: Py_tracefunc,
    pub c_profileobj: *mut PyObject,
    pub c_traceobj: *mut PyObject,
    #[doc = " The exception currently being raised"]
    pub curexc_type: *mut PyObject,
    pub curexc_value: *mut PyObject,
    pub curexc_traceback: *mut PyObject,
    #[doc = " The exception currently being handled, if no coroutines/generators\n are present. Always last element on the stack referred to be exc_info."]
    pub exc_state: _PyErr_StackItem,
    #[doc = " Pointer to the top of the stack of the exceptions currently\n being handled"]
    pub exc_info: *mut _PyErr_StackItem,
    #[doc = " Stores per-thread state"]
    pub dict: *mut PyObject,
    pub gilstate_counter: ::std::os::raw::c_int,
    #[doc = " Asynchronous exception to raise"]
    pub async_exc: *mut PyObject,
    #[doc = " Thread id where this tstate was created"]
    pub thread_id: ::std::os::raw::c_ulong,
    pub trash_delete_nesting: ::std::os::raw::c_int,
    pub trash_delete_later: *mut PyObject,
    #[doc = " Called when a thread state is deleted normally, but not when it\n is destroyed after fork().\n Pain:  to prevent rare but fatal shutdown errors (issue 18808),\n Thread.join() must wait for the join'ed thread's tstate to be unlinked\n from the tstate chain.  That happens at the end of a thread's life,\n in pystate.c.\n The obvious way doesn't quite work:  create a lock which the tstate\n unlinking code releases, and have Thread.join() wait to acquire that\n lock.  The problem is that we _are_ at the end of the thread's life:\n if the thread holds the last reference to the lock, decref'ing the\n lock will delete the lock, and that may trigger arbitrary Python code\n if there's a weakref, with a callback, to the lock.  But by this time\n _PyRuntime.gilstate.tstate_current is already NULL, so only the simplest\n of C code can be allowed to run (in particular it must not be possible to\n release the GIL).\n So instead of holding the lock directly, the tstate holds a weakref to\n the lock:  that's the value of on_delete_data below.  Decref'ing a\n weakref is harmless.\n on_delete points to _threadmodule.c's static release_sentinel() function.\n After the tstate is unlinked, release_sentinel is called with the\n weakref-to-lock (on_delete_data) argument, and release_sentinel releases\n the indirectly held lock."]
    pub on_delete: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub on_delete_data: *mut ::std::os::raw::c_void,
    pub coroutine_origin_tracking_depth: ::std::os::raw::c_int,
    pub async_gen_firstiter: *mut PyObject,
    pub async_gen_finalizer: *mut PyObject,
    pub context: *mut PyObject,
    pub context_ver: u64,
    #[doc = " Unique thread state id."]
    pub id: u64,
}
#[test]
fn bindgen_test_layout__ts() {
    const UNINIT: ::std::mem::MaybeUninit<_ts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ts>(),
        264usize,
        concat!("Size of: ", stringify!(_ts))
    );
    assert_eq!(
        ::std::mem::align_of::<_ts>(),
        8usize,
        concat!("Alignment of ", stringify!(_ts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_ts), "::", stringify!(prev))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_ts), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(interp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recursion_depth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(recursion_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflowed) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(overflowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recursion_critical) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(recursion_critical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stackcheck_counter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(stackcheck_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracing) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(tracing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_tracing) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(use_tracing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_profilefunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(c_profilefunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_tracefunc) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(c_tracefunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_profileobj) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(c_profileobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_traceobj) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(c_traceobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curexc_type) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(curexc_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curexc_value) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(curexc_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curexc_traceback) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(curexc_traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exc_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(exc_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exc_info) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(exc_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        152usize,
        concat!("Offset of field: ", stringify!(_ts), "::", stringify!(dict))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gilstate_counter) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(gilstate_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_exc) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(async_exc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash_delete_nesting) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(trash_delete_nesting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash_delete_later) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(trash_delete_later)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_delete) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(on_delete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_delete_data) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(on_delete_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).coroutine_origin_tracking_depth) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(coroutine_origin_tracking_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_gen_firstiter) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(async_gen_firstiter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_gen_finalizer) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(async_gen_finalizer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_ver) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_ts),
            "::",
            stringify!(context_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        256usize,
        concat!("Offset of field: ", stringify!(_ts), "::", stringify!(id))
    );
}
impl Default for _ts {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyThreadState_Prealloc(arg1: *mut PyInterpreterState) -> *mut PyThreadState;
}
extern "C" {
    #[doc = " Similar to PyThreadState_Get(), but don't issue a fatal error\n if it is NULL."]
    pub fn _PyThreadState_UncheckedGet() -> *mut PyThreadState;
}
extern "C" {
    pub fn _PyThreadState_GetDict(tstate: *mut PyThreadState) -> *mut PyObject;
}
extern "C" {
    #[doc = " Helper/diagnostic function - return 1 if the current thread\ncurrently holds the GIL, 0 otherwise.\n\nThe function returns 1 if _PyGILState_check_enabled is non-zero."]
    pub fn PyGILState_Check() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the single PyInterpreterState used by this process' GILState\nimplementation.\n\nThis function doesn't check for error. Return NULL before _PyGILState_Init()\nis called and after _PyGILState_Fini() is called.\n\nSee also _PyInterpreterState_Get() and _PyInterpreterState_GET()."]
    pub fn _PyGILState_GetInterpreterStateUnsafe() -> *mut PyInterpreterState;
}
extern "C" {
    #[doc = " The implementation of sys._current_frames()  Returns a dict mapping\nthread id to that thread's current frame."]
    pub fn _PyThread_CurrentFrames() -> *mut PyObject;
}
extern "C" {
    #[doc = " Routines for advanced debuggers, requested by David Beazley.\nDon't use unless you know what you are doing!"]
    pub fn PyInterpreterState_Main() -> *mut PyInterpreterState;
}
extern "C" {
    pub fn PyInterpreterState_Head() -> *mut PyInterpreterState;
}
extern "C" {
    pub fn PyInterpreterState_Next(arg1: *mut PyInterpreterState) -> *mut PyInterpreterState;
}
extern "C" {
    pub fn PyInterpreterState_ThreadHead(arg1: *mut PyInterpreterState) -> *mut PyThreadState;
}
extern "C" {
    pub fn PyThreadState_Next(arg1: *mut PyThreadState) -> *mut PyThreadState;
}
extern "C" {
    pub fn PyThreadState_DeleteCurrent();
}
#[doc = " Frame evaluation API"]
pub type _PyFrameEvalFunction = ::std::option::Option<
    unsafe extern "C" fn(
        tstate: *mut PyThreadState,
        arg1: *mut PyFrameObject,
        arg2: ::std::os::raw::c_int,
    ) -> *mut PyObject,
>;
extern "C" {
    pub fn _PyInterpreterState_GetEvalFrameFunc(
        interp: *mut PyInterpreterState,
    ) -> _PyFrameEvalFunction;
}
extern "C" {
    pub fn _PyInterpreterState_SetEvalFrameFunc(
        interp: *mut PyInterpreterState,
        eval_frame: _PyFrameEvalFunction,
    );
}
extern "C" {
    pub fn _PyInterpreterState_GetConfig(interp: *mut PyInterpreterState) -> *const PyConfig;
}
extern "C" {
    #[doc = " Get the configuration of the currrent interpreter.\n The caller must hold the GIL."]
    pub fn _Py_GetConfig() -> *const PyConfig;
}
#[doc = " cross-interpreter data"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _xid {
    #[doc = " data is the cross-interpreter-safe derivation of a Python object\n (see _PyObject_GetCrossInterpreterData).  It will be NULL if the\n new_object func (below) encodes the data."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " obj is the Python object from which the data was derived.  This\n is non-NULL only if the data remains bound to the object in some\n way, such that the object must be \"released\" (via a decref) when\n the data is released.  In that case the code that sets the field,\n likely a registered \"crossinterpdatafunc\", is responsible for\n ensuring it owns the reference (i.e. incref)."]
    pub obj: *mut PyObject,
    #[doc = " interp is the ID of the owning interpreter of the original\n object.  It corresponds to the active interpreter when\n _PyObject_GetCrossInterpreterData() was called.  This should only\n be set by the cross-interpreter machinery.\n\n We use the ID rather than the PyInterpreterState to avoid issues\n with deleted interpreters.  Note that IDs are never re-used, so\n each one will always correspond to a specific interpreter\n (whether still alive or not)."]
    pub interp: i64,
    #[doc = " new_object is a function that returns a new object in the current\n interpreter given the data.  The resulting object (a new\n reference) will be equivalent to the original object.  This field\n is required."]
    pub new_object: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _xid) -> *mut PyObject>,
    #[doc = " free is called when the data is released.  If it is NULL then\n nothing will be done to free the data.  For some types this is\n okay (e.g. bytes) and for those types this field should be set\n to NULL.  However, for most the data was allocated just for\n cross-interpreter use, so it must be freed when\n _PyCrossInterpreterData_Release is called or the memory will\n leak.  In that case, at the very least this field should be set\n to PyMem_RawFree (the default if not explicitly set to NULL).\n The call will happen with the original interpreter activated."]
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout__xid() {
    const UNINIT: ::std::mem::MaybeUninit<_xid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xid>(),
        40usize,
        concat!("Size of: ", stringify!(_xid))
    );
    assert_eq!(
        ::std::mem::align_of::<_xid>(),
        8usize,
        concat!("Alignment of ", stringify!(_xid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xid),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_xid), "::", stringify!(obj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_xid),
            "::",
            stringify!(interp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xid),
            "::",
            stringify!(new_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_xid),
            "::",
            stringify!(free)
        )
    );
}
impl Default for _xid {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " _PyCrossInterpreterData is similar to Py_buffer as an effectively\n opaque struct that holds data outside the object machinery.  This\n is necessary to pass safely between interpreters in the same process."]
pub type _PyCrossInterpreterData = _xid;
extern "C" {
    pub fn _PyObject_GetCrossInterpreterData(
        arg1: *mut PyObject,
        arg2: *mut _PyCrossInterpreterData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyCrossInterpreterData_NewObject(arg1: *mut _PyCrossInterpreterData) -> *mut PyObject;
}
extern "C" {
    pub fn _PyCrossInterpreterData_Release(arg1: *mut _PyCrossInterpreterData);
}
extern "C" {
    pub fn _PyObject_CheckCrossInterpreterData(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
#[doc = " cross-interpreter data registry"]
pub type crossinterpdatafunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut _xid) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn _PyCrossInterpreterData_RegisterClass(
        arg1: *mut PyTypeObject,
        arg2: crossinterpdatafunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyCrossInterpreterData_Lookup(arg1: *mut PyObject) -> crossinterpdatafunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyGenObject {
    pub ob_base: PyObject,
    #[doc = " Note: gi_frame can be NULL if the generator is \"finished\""]
    pub gi_frame: *mut PyFrameObject,
    #[doc = " True if generator is being executed."]
    pub gi_running: ::std::os::raw::c_char,
    #[doc = " The code object backing the generator"]
    pub gi_code: *mut PyObject,
    #[doc = " List of weak reference."]
    pub gi_weakreflist: *mut PyObject,
    #[doc = " Name of the generator."]
    pub gi_name: *mut PyObject,
    #[doc = " Qualified name of the generator."]
    pub gi_qualname: *mut PyObject,
    pub gi_exc_state: _PyErr_StackItem,
}
#[test]
fn bindgen_test_layout_PyGenObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyGenObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyGenObject>(),
        96usize,
        concat!("Size of: ", stringify!(PyGenObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyGenObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyGenObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_running) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_code) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_weakreflist) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_qualname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_qualname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gi_exc_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGenObject),
            "::",
            stringify!(gi_exc_state)
        )
    );
}
impl Default for PyGenObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyGen_Type: PyTypeObject;
}
extern "C" {
    pub fn PyGen_New(arg1: *mut PyFrameObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyGen_NewWithQualName(
        arg1: *mut PyFrameObject,
        name: *mut PyObject,
        qualname: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyGen_SetStopIterationValue(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyGen_FetchStopIterationValue(arg1: *mut *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyGen_Send(arg1: *mut PyGenObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyGen_yf(arg1: *mut PyGenObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyGen_Finalize(self_: *mut PyObject);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCoroObject {
    pub ob_base: PyObject,
    #[doc = " Note: gi_frame can be NULL if the generator is \"finished\""]
    pub cr_frame: *mut PyFrameObject,
    #[doc = " True if generator is being executed."]
    pub cr_running: ::std::os::raw::c_char,
    #[doc = " The code object backing the generator"]
    pub cr_code: *mut PyObject,
    #[doc = " List of weak reference."]
    pub cr_weakreflist: *mut PyObject,
    #[doc = " Name of the generator."]
    pub cr_name: *mut PyObject,
    #[doc = " Qualified name of the generator."]
    pub cr_qualname: *mut PyObject,
    pub cr_exc_state: _PyErr_StackItem,
    pub cr_origin: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyCoroObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyCoroObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCoroObject>(),
        104usize,
        concat!("Size of: ", stringify!(PyCoroObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCoroObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyCoroObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_running) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_code) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_weakreflist) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_qualname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_qualname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_exc_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_exc_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_origin) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCoroObject),
            "::",
            stringify!(cr_origin)
        )
    );
}
impl Default for PyCoroObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyCoro_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyCoroWrapper_Type: PyTypeObject;
}
extern "C" {
    pub fn _PyCoro_GetAwaitableIter(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCoro_New(
        arg1: *mut PyFrameObject,
        name: *mut PyObject,
        qualname: *mut PyObject,
    ) -> *mut PyObject;
}
#[doc = " Asynchronous Generators"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyAsyncGenObject {
    pub ob_base: PyObject,
    #[doc = " Note: gi_frame can be NULL if the generator is \"finished\""]
    pub ag_frame: *mut PyFrameObject,
    #[doc = " True if generator is being executed."]
    pub ag_running: ::std::os::raw::c_char,
    #[doc = " The code object backing the generator"]
    pub ag_code: *mut PyObject,
    #[doc = " List of weak reference."]
    pub ag_weakreflist: *mut PyObject,
    #[doc = " Name of the generator."]
    pub ag_name: *mut PyObject,
    #[doc = " Qualified name of the generator."]
    pub ag_qualname: *mut PyObject,
    pub ag_exc_state: _PyErr_StackItem,
    pub ag_finalizer: *mut PyObject,
    #[doc = " Flag is set to 1 when hooks set up by sys.set_asyncgen_hooks\nwere called on the generator, to avoid calling them more\nthan once."]
    pub ag_hooks_inited: ::std::os::raw::c_int,
    #[doc = " Flag is set to 1 when aclose() is called for the first time, or\nwhen a StopAsyncIteration exception is raised."]
    pub ag_closed: ::std::os::raw::c_int,
    pub ag_running_async: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PyAsyncGenObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyAsyncGenObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyAsyncGenObject>(),
        120usize,
        concat!("Size of: ", stringify!(PyAsyncGenObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyAsyncGenObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyAsyncGenObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_running) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_code) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_weakreflist) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_weakreflist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_qualname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_qualname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_exc_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_exc_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_finalizer) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_finalizer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_hooks_inited) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_hooks_inited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_closed) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_closed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ag_running_async) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PyAsyncGenObject),
            "::",
            stringify!(ag_running_async)
        )
    );
}
impl Default for PyAsyncGenObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyAsyncGen_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyAsyncGenASend_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyAsyncGenWrappedValue_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyAsyncGenAThrow_Type: PyTypeObject;
}
extern "C" {
    pub fn PyAsyncGen_New(
        arg1: *mut PyFrameObject,
        name: *mut PyObject,
        qualname: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyAsyncGenValueWrapperNew(arg1: *mut PyObject) -> *mut PyObject;
}
pub type getter = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,
>;
pub type setter = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyGetSetDef {
    pub name: *const ::std::os::raw::c_char,
    pub get: getter,
    pub set: setter,
    pub doc: *const ::std::os::raw::c_char,
    pub closure: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PyGetSetDef() {
    const UNINIT: ::std::mem::MaybeUninit<PyGetSetDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyGetSetDef>(),
        40usize,
        concat!("Size of: ", stringify!(PyGetSetDef))
    );
    assert_eq!(
        ::std::mem::align_of::<PyGetSetDef>(),
        8usize,
        concat!("Alignment of ", stringify!(PyGetSetDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDef),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDef),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDef),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDef),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDef),
            "::",
            stringify!(closure)
        )
    );
}
impl Default for PyGetSetDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wrapperfunc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut PyObject,
        args: *mut PyObject,
        wrapped: *mut ::std::os::raw::c_void,
    ) -> *mut PyObject,
>;
pub type wrapperfunc_kwds = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut PyObject,
        args: *mut PyObject,
        wrapped: *mut ::std::os::raw::c_void,
        kwds: *mut PyObject,
    ) -> *mut PyObject,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct wrapperbase {
    pub name: *const ::std::os::raw::c_char,
    pub offset: ::std::os::raw::c_int,
    pub function: *mut ::std::os::raw::c_void,
    pub wrapper: wrapperfunc,
    pub doc: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_int,
    pub name_strobj: *mut PyObject,
}
#[test]
fn bindgen_test_layout_wrapperbase() {
    const UNINIT: ::std::mem::MaybeUninit<wrapperbase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wrapperbase>(),
        56usize,
        concat!("Size of: ", stringify!(wrapperbase))
    );
    assert_eq!(
        ::std::mem::align_of::<wrapperbase>(),
        8usize,
        concat!("Alignment of ", stringify!(wrapperbase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrapper) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(wrapper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_strobj) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wrapperbase),
            "::",
            stringify!(name_strobj)
        )
    );
}
impl Default for wrapperbase {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Various kinds of descriptor objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyDescrObject {
    pub ob_base: PyObject,
    pub d_type: *mut PyTypeObject,
    pub d_name: *mut PyObject,
    pub d_qualname: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyDescrObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyDescrObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyDescrObject>(),
        40usize,
        concat!("Size of: ", stringify!(PyDescrObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyDescrObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyDescrObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDescrObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDescrObject),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDescrObject),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_qualname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyDescrObject),
            "::",
            stringify!(d_qualname)
        )
    );
}
impl Default for PyDescrObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMethodDescrObject {
    pub d_common: PyDescrObject,
    pub d_method: *mut PyMethodDef,
    pub vectorcall: vectorcallfunc,
}
#[test]
fn bindgen_test_layout_PyMethodDescrObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyMethodDescrObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMethodDescrObject>(),
        56usize,
        concat!("Size of: ", stringify!(PyMethodDescrObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMethodDescrObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMethodDescrObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDescrObject),
            "::",
            stringify!(d_common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_method) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDescrObject),
            "::",
            stringify!(d_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectorcall) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMethodDescrObject),
            "::",
            stringify!(vectorcall)
        )
    );
}
impl Default for PyMethodDescrObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyMemberDescrObject {
    pub d_common: PyDescrObject,
    pub d_member: *mut PyMemberDef,
}
#[test]
fn bindgen_test_layout_PyMemberDescrObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyMemberDescrObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyMemberDescrObject>(),
        48usize,
        concat!("Size of: ", stringify!(PyMemberDescrObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyMemberDescrObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyMemberDescrObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemberDescrObject),
            "::",
            stringify!(d_common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_member) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyMemberDescrObject),
            "::",
            stringify!(d_member)
        )
    );
}
impl Default for PyMemberDescrObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyGetSetDescrObject {
    pub d_common: PyDescrObject,
    pub d_getset: *mut PyGetSetDef,
}
#[test]
fn bindgen_test_layout_PyGetSetDescrObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyGetSetDescrObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyGetSetDescrObject>(),
        48usize,
        concat!("Size of: ", stringify!(PyGetSetDescrObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyGetSetDescrObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyGetSetDescrObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDescrObject),
            "::",
            stringify!(d_common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_getset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyGetSetDescrObject),
            "::",
            stringify!(d_getset)
        )
    );
}
impl Default for PyGetSetDescrObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyWrapperDescrObject {
    pub d_common: PyDescrObject,
    pub d_base: *mut wrapperbase,
    #[doc = " This can be any function pointer"]
    pub d_wrapped: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PyWrapperDescrObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyWrapperDescrObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyWrapperDescrObject>(),
        56usize,
        concat!("Size of: ", stringify!(PyWrapperDescrObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyWrapperDescrObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyWrapperDescrObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyWrapperDescrObject),
            "::",
            stringify!(d_common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_base) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyWrapperDescrObject),
            "::",
            stringify!(d_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_wrapped) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyWrapperDescrObject),
            "::",
            stringify!(d_wrapped)
        )
    );
}
impl Default for PyWrapperDescrObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyClassMethodDescr_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyGetSetDescr_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyMemberDescr_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyMethodDescr_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyWrapperDescr_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyDictProxy_Type: PyTypeObject;
}
extern "C" {
    pub static mut _PyMethodWrapper_Type: PyTypeObject;
}
extern "C" {
    pub fn PyDescr_NewMethod(arg1: *mut PyTypeObject, arg2: *mut PyMethodDef) -> *mut PyObject;
}
extern "C" {
    pub fn PyDescr_NewClassMethod(arg1: *mut PyTypeObject, arg2: *mut PyMethodDef)
        -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PyMemberDef {
    _unused: [u8; 0],
}
extern "C" {
    pub fn PyDescr_NewMember(arg1: *mut PyTypeObject, arg2: *mut PyMemberDef) -> *mut PyObject;
}
extern "C" {
    pub fn PyDescr_NewGetSet(arg1: *mut PyTypeObject, arg2: *mut PyGetSetDef) -> *mut PyObject;
}
extern "C" {
    pub fn PyDescr_NewWrapper(
        arg1: *mut PyTypeObject,
        arg2: *mut wrapperbase,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyDictProxy_New(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyWrapper_New(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static mut PyProperty_Type: PyTypeObject;
}
extern "C" {
    pub fn Py_GenericAlias(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static mut Py_GenericAliasType: PyTypeObject;
}
extern "C" {
    pub fn _PyWarnings_Init() -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_WarnEx(
        category: *mut PyObject,
        message: *const ::std::os::raw::c_char,
        stack_level: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_WarnFormat(
        category: *mut PyObject,
        stack_level: Py_ssize_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Emit a ResourceWarning warning"]
    pub fn PyErr_ResourceWarning(
        source: *mut PyObject,
        stack_level: Py_ssize_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_WarnExplicitObject(
        category: *mut PyObject,
        message: *mut PyObject,
        filename: *mut PyObject,
        lineno: ::std::os::raw::c_int,
        module: *mut PyObject,
        registry: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_WarnExplicit(
        category: *mut PyObject,
        message: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        module: *const ::std::os::raw::c_char,
        registry: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_WarnExplicitFormat(
        category: *mut PyObject,
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        module: *const ::std::os::raw::c_char,
        registry: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyErr_WarnUnawaitedCoroutine(coro: *mut PyObject);
}
pub type PyWeakReference = _PyWeakReference;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyWeakReference {
    pub ob_base: PyObject,
    #[doc = " The object to which this is a weak reference, or Py_None if none.\n Note that this is a stealth reference:  wr_object's refcount is\n not incremented to reflect this pointer."]
    pub wr_object: *mut PyObject,
    #[doc = " A callable to invoke when wr_object dies, or NULL if none."]
    pub wr_callback: *mut PyObject,
    #[doc = " A cache for wr_object's hash code.  As usual for hashes, this is -1\n if the hash code isn't known yet."]
    pub hash: Py_hash_t,
    #[doc = " If wr_object is weakly referenced, wr_object has a doubly-linked NULL-\n terminated list of weak references to it.  These are the list pointers.\n If wr_object goes away, wr_object is set to Py_None, and these pointers\n have no meaning then."]
    pub wr_prev: *mut PyWeakReference,
    pub wr_next: *mut PyWeakReference,
}
#[test]
fn bindgen_test_layout__PyWeakReference() {
    const UNINIT: ::std::mem::MaybeUninit<_PyWeakReference> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyWeakReference>(),
        56usize,
        concat!("Size of: ", stringify!(_PyWeakReference))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyWeakReference>(),
        8usize,
        concat!("Alignment of ", stringify!(_PyWeakReference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyWeakReference),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wr_object) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyWeakReference),
            "::",
            stringify!(wr_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wr_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyWeakReference),
            "::",
            stringify!(wr_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyWeakReference),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wr_prev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyWeakReference),
            "::",
            stringify!(wr_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wr_next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyWeakReference),
            "::",
            stringify!(wr_next)
        )
    );
}
impl Default for _PyWeakReference {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _PyWeakref_RefType: PyTypeObject;
}
extern "C" {
    pub static mut _PyWeakref_ProxyType: PyTypeObject;
}
extern "C" {
    pub static mut _PyWeakref_CallableProxyType: PyTypeObject;
}
extern "C" {
    pub fn PyWeakref_NewRef(ob: *mut PyObject, callback: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyWeakref_NewProxy(ob: *mut PyObject, callback: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyWeakref_GetObject(ref_: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn _PyWeakref_GetWeakrefCount(head: *mut PyWeakReference) -> Py_ssize_t;
}
extern "C" {
    pub fn _PyWeakref_ClearRef(self_: *mut PyWeakReference);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyStructSequence_Field {
    pub name: *const ::std::os::raw::c_char,
    pub doc: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PyStructSequence_Field() {
    const UNINIT: ::std::mem::MaybeUninit<PyStructSequence_Field> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyStructSequence_Field>(),
        16usize,
        concat!("Size of: ", stringify!(PyStructSequence_Field))
    );
    assert_eq!(
        ::std::mem::align_of::<PyStructSequence_Field>(),
        8usize,
        concat!("Alignment of ", stringify!(PyStructSequence_Field))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStructSequence_Field),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStructSequence_Field),
            "::",
            stringify!(doc)
        )
    );
}
impl Default for PyStructSequence_Field {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyStructSequence_Desc {
    pub name: *const ::std::os::raw::c_char,
    pub doc: *const ::std::os::raw::c_char,
    pub fields: *mut PyStructSequence_Field,
    pub n_in_sequence: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PyStructSequence_Desc() {
    const UNINIT: ::std::mem::MaybeUninit<PyStructSequence_Desc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyStructSequence_Desc>(),
        32usize,
        concat!("Size of: ", stringify!(PyStructSequence_Desc))
    );
    assert_eq!(
        ::std::mem::align_of::<PyStructSequence_Desc>(),
        8usize,
        concat!("Alignment of ", stringify!(PyStructSequence_Desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStructSequence_Desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStructSequence_Desc),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStructSequence_Desc),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_in_sequence) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStructSequence_Desc),
            "::",
            stringify!(n_in_sequence)
        )
    );
}
impl Default for PyStructSequence_Desc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static PyStructSequence_UnnamedField: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyStructSequence_InitType(type_: *mut PyTypeObject, desc: *mut PyStructSequence_Desc);
}
extern "C" {
    pub fn PyStructSequence_InitType2(
        type_: *mut PyTypeObject,
        desc: *mut PyStructSequence_Desc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyStructSequence_NewType(desc: *mut PyStructSequence_Desc) -> *mut PyTypeObject;
}
extern "C" {
    pub fn PyStructSequence_New(type_: *mut PyTypeObject) -> *mut PyObject;
}
pub type PyStructSequence = PyTupleObject;
extern "C" {
    pub fn PyStructSequence_SetItem(arg1: *mut PyObject, arg2: Py_ssize_t, arg3: *mut PyObject);
}
extern "C" {
    pub fn PyStructSequence_GetItem(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    pub static mut _PyNamespace_Type: PyTypeObject;
}
extern "C" {
    pub fn _PyNamespace_New(kwds: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static mut PyPickleBuffer_Type: PyTypeObject;
}
extern "C" {
    #[doc = " Create a PickleBuffer redirecting to the given buffer-enabled object"]
    pub fn PyPickleBuffer_FromObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get the PickleBuffer's underlying view to the original object\n (NULL if released)"]
    pub fn PyPickleBuffer_GetBuffer(arg1: *mut PyObject) -> *const Py_buffer;
}
extern "C" {
    #[doc = " Release the PickleBuffer.  Returns 0 on success, -1 on error."]
    pub fn PyPickleBuffer_Release(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a new codec search function.\n\nAs side effect, this tries to load the encodings package, if not\nyet done, to make sure that it is always first in the list of\nsearch functions.\n\nThe search_function's refcount is incremented by this function."]
    pub fn PyCodec_Register(search_function: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyCodec_Lookup(encoding: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn _PyCodec_Forget(encoding: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Codec registry encoding check API.\n\nReturns 1/0 depending on whether there is a registered codec for\nthe given encoding."]
    pub fn PyCodec_KnownEncoding(encoding: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generic codec based encoding API.\n\nobject is passed through the encoder function found for the given\nencoding using the error handling method defined by errors. errors\nmay be NULL to use the default method defined for the codec.\n\nRaises a LookupError in case no encoder can be found.\n"]
    pub fn PyCodec_Encode(
        object: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Generic codec based decoding API.\n\nobject is passed through the decoder function found for the given\nencoding using the error handling method defined by errors. errors\nmay be NULL to use the default method defined for the codec.\n\nRaises a LookupError in case no encoder can be found.\n"]
    pub fn PyCodec_Decode(
        object: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Text codec specific encoding and decoding API.\n\nChecks the encoding against a list of codecs which do not\nimplement a str<->bytes encoding before attempting the\noperation.\n\nPlease note that these APIs are internal and should not\nbe used in Python C extensions.\n\nXXX (ncoghlan): should we make these, or something like them, public\nin Python 3.5+?\n"]
    pub fn _PyCodec_LookupTextEncoding(
        encoding: *const ::std::os::raw::c_char,
        alternate_command: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyCodec_EncodeText(
        object: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyCodec_DecodeText(
        object: *mut PyObject,
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " These two aren't actually text encoding specific, but _io.TextIOWrapper\n is the only current API consumer."]
    pub fn _PyCodecInfo_GetIncrementalDecoder(
        codec_info: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyCodecInfo_GetIncrementalEncoder(
        codec_info: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get an encoder function for the given encoding."]
    pub fn PyCodec_Encoder(encoding: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get a decoder function for the given encoding."]
    pub fn PyCodec_Decoder(encoding: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get an IncrementalEncoder object for the given encoding."]
    pub fn PyCodec_IncrementalEncoder(
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get an IncrementalDecoder object function for the given encoding."]
    pub fn PyCodec_IncrementalDecoder(
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get a StreamReader factory function for the given encoding."]
    pub fn PyCodec_StreamReader(
        encoding: *const ::std::os::raw::c_char,
        stream: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get a StreamWriter factory function for the given encoding."]
    pub fn PyCodec_StreamWriter(
        encoding: *const ::std::os::raw::c_char,
        stream: *mut PyObject,
        errors: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Register the error handling callback function error under the given\nname. This function will be called by the codec when it encounters\nunencodable characters/undecodable bytes and doesn't know the\ncallback name, when name is specified as the error parameter\nin the call to the encode/decode function.\nReturn 0 on success, -1 on error"]
    pub fn PyCodec_RegisterError(
        name: *const ::std::os::raw::c_char,
        error: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup the error handling callback function registered under the given\nname. As a special case NULL can be passed, in which case\nthe error handling callback for \"strict\" will be returned."]
    pub fn PyCodec_LookupError(name: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    #[doc = " raise exc as an exception"]
    pub fn PyCodec_StrictErrors(exc: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " ignore the unicode error, skipping the faulty input"]
    pub fn PyCodec_IgnoreErrors(exc: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " replace the unicode encode error with ? or U+FFFD"]
    pub fn PyCodec_ReplaceErrors(exc: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " replace the unicode encode error with XML character references"]
    pub fn PyCodec_XMLCharRefReplaceErrors(exc: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " replace the unicode encode error with backslash escapes (\\x, \\u and \\U)"]
    pub fn PyCodec_BackslashReplaceErrors(exc: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " replace the unicode encode error with backslash escapes (\\N, \\x, \\u and \\U)"]
    pub fn PyCodec_NameReplaceErrors(exc: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static mut Py_hexdigits: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Error handling definitions"]
    pub fn PyErr_SetNone(arg1: *mut PyObject);
}
extern "C" {
    pub fn PyErr_SetObject(arg1: *mut PyObject, arg2: *mut PyObject);
}
extern "C" {
    pub fn PyErr_SetString(exception: *mut PyObject, string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn PyErr_Occurred() -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_Clear();
}
extern "C" {
    pub fn PyErr_Fetch(
        arg1: *mut *mut PyObject,
        arg2: *mut *mut PyObject,
        arg3: *mut *mut PyObject,
    );
}
extern "C" {
    pub fn PyErr_Restore(arg1: *mut PyObject, arg2: *mut PyObject, arg3: *mut PyObject);
}
extern "C" {
    pub fn PyErr_GetExcInfo(
        arg1: *mut *mut PyObject,
        arg2: *mut *mut PyObject,
        arg3: *mut *mut PyObject,
    );
}
extern "C" {
    pub fn PyErr_SetExcInfo(arg1: *mut PyObject, arg2: *mut PyObject, arg3: *mut PyObject);
}
extern "C" {
    #[doc = " Defined in Python/pylifecycle.c\n\nThe Py_FatalError() function is replaced with a macro which logs\nautomatically the name of the current function, unless the Py_LIMITED_API\nmacro is defined."]
    pub fn Py_FatalError(message: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[doc = " Error testing and normalization"]
    pub fn PyErr_GivenExceptionMatches(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_ExceptionMatches(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_NormalizeException(
        arg1: *mut *mut PyObject,
        arg2: *mut *mut PyObject,
        arg3: *mut *mut PyObject,
    );
}
extern "C" {
    #[doc = " Traceback manipulation (PEP 3134)"]
    pub fn PyException_SetTraceback(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyException_GetTraceback(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Cause manipulation (PEP 3134)"]
    pub fn PyException_GetCause(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyException_SetCause(arg1: *mut PyObject, arg2: *mut PyObject);
}
extern "C" {
    #[doc = " Context manipulation (PEP 3134)"]
    pub fn PyException_GetContext(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyException_SetContext(arg1: *mut PyObject, arg2: *mut PyObject);
}
extern "C" {
    pub fn PyExceptionClass_Name(arg1: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Predefined exceptions"]
    pub static mut PyExc_BaseException: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_Exception: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_StopAsyncIteration: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_StopIteration: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_GeneratorExit: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ArithmeticError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_LookupError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_AssertionError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_AttributeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_BufferError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_EOFError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_FloatingPointError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_OSError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ImportError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ModuleNotFoundError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_IndexError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_KeyError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_KeyboardInterrupt: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_MemoryError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_NameError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_OverflowError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_RuntimeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_RecursionError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_NotImplementedError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_SyntaxError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_IndentationError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_TabError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ReferenceError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_SystemError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_SystemExit: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_TypeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UnboundLocalError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UnicodeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UnicodeEncodeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UnicodeDecodeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UnicodeTranslateError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ValueError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ZeroDivisionError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_BlockingIOError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_BrokenPipeError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ChildProcessError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ConnectionError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ConnectionAbortedError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ConnectionRefusedError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ConnectionResetError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_FileExistsError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_FileNotFoundError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_InterruptedError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_IsADirectoryError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_NotADirectoryError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_PermissionError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ProcessLookupError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_TimeoutError: *mut PyObject;
}
extern "C" {
    #[doc = " Compatibility aliases"]
    pub static mut PyExc_EnvironmentError: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_IOError: *mut PyObject;
}
extern "C" {
    #[doc = " Predefined warning categories"]
    pub static mut PyExc_Warning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UserWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_DeprecationWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_PendingDeprecationWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_SyntaxWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_RuntimeWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_FutureWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ImportWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_UnicodeWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_BytesWarning: *mut PyObject;
}
extern "C" {
    pub static mut PyExc_ResourceWarning: *mut PyObject;
}
extern "C" {
    #[doc = " Convenience functions"]
    pub fn PyErr_BadArgument() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_NoMemory() -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_SetFromErrno(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_SetFromErrnoWithFilenameObject(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_SetFromErrnoWithFilenameObjects(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_SetFromErrnoWithFilename(
        exc: *mut PyObject,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_Format(
        exception: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_FormatV(
        exception: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_SetImportErrorSubclass(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
        arg4: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_SetImportError(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Export the old function so that the existing API remains available:"]
    pub fn PyErr_BadInternalCall();
}
extern "C" {
    pub fn _PyErr_BadInternalCall(
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function to create a new exception"]
    pub fn PyErr_NewException(
        name: *const ::std::os::raw::c_char,
        base: *mut PyObject,
        dict: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_NewExceptionWithDoc(
        name: *const ::std::os::raw::c_char,
        doc: *const ::std::os::raw::c_char,
        base: *mut PyObject,
        dict: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyErr_WriteUnraisable(arg1: *mut PyObject);
}
extern "C" {
    #[doc = " In signalmodule.c"]
    pub fn PyErr_CheckSignals() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyErr_SetInterrupt();
}
extern "C" {
    #[doc = " Support for adding program text to SyntaxErrors"]
    pub fn PyErr_SyntaxLocation(
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PyErr_SyntaxLocationEx(
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        col_offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PyErr_ProgramText(
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " create a UnicodeDecodeError object"]
    pub fn PyUnicodeDecodeError_Create(
        encoding: *const ::std::os::raw::c_char,
        object: *const ::std::os::raw::c_char,
        length: Py_ssize_t,
        start: Py_ssize_t,
        end: Py_ssize_t,
        reason: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " get the encoding attribute"]
    pub fn PyUnicodeEncodeError_GetEncoding(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicodeDecodeError_GetEncoding(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " get the object attribute"]
    pub fn PyUnicodeEncodeError_GetObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicodeDecodeError_GetObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicodeTranslateError_GetObject(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " get the value of the start attribute (the int * may not be NULL)\nreturn 0 on success, -1 on failure"]
    pub fn PyUnicodeEncodeError_GetStart(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeDecodeError_GetStart(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeTranslateError_GetStart(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " assign a new value to the start attribute\nreturn 0 on success, -1 on failure"]
    pub fn PyUnicodeEncodeError_SetStart(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeDecodeError_SetStart(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeTranslateError_SetStart(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the value of the end attribute (the int *may not be NULL)\nreturn 0 on success, -1 on failure"]
    pub fn PyUnicodeEncodeError_GetEnd(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeDecodeError_GetEnd(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeTranslateError_GetEnd(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " assign a new value to the end attribute\nreturn 0 on success, -1 on failure"]
    pub fn PyUnicodeEncodeError_SetEnd(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeDecodeError_SetEnd(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeTranslateError_SetEnd(
        arg1: *mut PyObject,
        arg2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the value of the reason attribute"]
    pub fn PyUnicodeEncodeError_GetReason(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicodeDecodeError_GetReason(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyUnicodeTranslateError_GetReason(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " assign a new value to the reason attribute\nreturn 0 on success, -1 on failure"]
    pub fn PyUnicodeEncodeError_SetReason(
        exc: *mut PyObject,
        reason: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeDecodeError_SetReason(
        exc: *mut PyObject,
        reason: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyUnicodeTranslateError_SetReason(
        exc: *mut PyObject,
        reason: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyOS_snprintf(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyOS_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyBaseExceptionObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PyBaseExceptionObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyBaseExceptionObject> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyBaseExceptionObject>(),
        64usize,
        concat!("Size of: ", stringify!(PyBaseExceptionObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyBaseExceptionObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyBaseExceptionObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyBaseExceptionObject),
            "::",
            stringify!(suppress_context)
        )
    );
}
impl Default for PyBaseExceptionObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PySyntaxErrorObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
    pub msg: *mut PyObject,
    pub filename: *mut PyObject,
    pub lineno: *mut PyObject,
    pub offset: *mut PyObject,
    pub text: *mut PyObject,
    pub print_file_and_line: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PySyntaxErrorObject() {
    const UNINIT: ::std::mem::MaybeUninit<PySyntaxErrorObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PySyntaxErrorObject>(),
        112usize,
        concat!("Size of: ", stringify!(PySyntaxErrorObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PySyntaxErrorObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PySyntaxErrorObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(suppress_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).print_file_and_line) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PySyntaxErrorObject),
            "::",
            stringify!(print_file_and_line)
        )
    );
}
impl Default for PySyntaxErrorObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyImportErrorObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
    pub msg: *mut PyObject,
    pub name: *mut PyObject,
    pub path: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyImportErrorObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyImportErrorObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyImportErrorObject>(),
        88usize,
        concat!("Size of: ", stringify!(PyImportErrorObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyImportErrorObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyImportErrorObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(suppress_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyImportErrorObject),
            "::",
            stringify!(path)
        )
    );
}
impl Default for PyImportErrorObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyUnicodeErrorObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
    pub encoding: *mut PyObject,
    pub object: *mut PyObject,
    pub start: Py_ssize_t,
    pub end: Py_ssize_t,
    pub reason: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyUnicodeErrorObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyUnicodeErrorObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyUnicodeErrorObject>(),
        104usize,
        concat!("Size of: ", stringify!(PyUnicodeErrorObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyUnicodeErrorObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyUnicodeErrorObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(suppress_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyUnicodeErrorObject),
            "::",
            stringify!(reason)
        )
    );
}
impl Default for PyUnicodeErrorObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PySystemExitObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
    pub code: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PySystemExitObject() {
    const UNINIT: ::std::mem::MaybeUninit<PySystemExitObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PySystemExitObject>(),
        72usize,
        concat!("Size of: ", stringify!(PySystemExitObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PySystemExitObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PySystemExitObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(suppress_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PySystemExitObject),
            "::",
            stringify!(code)
        )
    );
}
impl Default for PySystemExitObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyOSErrorObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
    pub myerrno: *mut PyObject,
    pub strerror: *mut PyObject,
    pub filename: *mut PyObject,
    pub filename2: *mut PyObject,
    #[doc = " only for BlockingIOError, -1 otherwise"]
    pub written: Py_ssize_t,
}
#[test]
fn bindgen_test_layout_PyOSErrorObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyOSErrorObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyOSErrorObject>(),
        104usize,
        concat!("Size of: ", stringify!(PyOSErrorObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyOSErrorObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyOSErrorObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(suppress_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).myerrno) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(myerrno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strerror) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(strerror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename2) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(filename2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).written) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PyOSErrorObject),
            "::",
            stringify!(written)
        )
    );
}
impl Default for PyOSErrorObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyStopIterationObject {
    pub ob_base: PyObject,
    pub dict: *mut PyObject,
    pub args: *mut PyObject,
    pub traceback: *mut PyObject,
    pub context: *mut PyObject,
    pub cause: *mut PyObject,
    pub suppress_context: ::std::os::raw::c_char,
    pub value: *mut PyObject,
}
#[test]
fn bindgen_test_layout_PyStopIterationObject() {
    const UNINIT: ::std::mem::MaybeUninit<PyStopIterationObject> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyStopIterationObject>(),
        72usize,
        concat!("Size of: ", stringify!(PyStopIterationObject))
    );
    assert_eq!(
        ::std::mem::align_of::<PyStopIterationObject>(),
        8usize,
        concat!("Alignment of ", stringify!(PyStopIterationObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traceback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(traceback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(suppress_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PyStopIterationObject),
            "::",
            stringify!(value)
        )
    );
}
impl Default for PyStopIterationObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Compatibility typedefs"]
pub type PyEnvironmentErrorObject = PyOSErrorObject;
extern "C" {
    #[doc = " Error handling definitions"]
    pub fn _PyErr_SetKeyError(arg1: *mut PyObject);
}
extern "C" {
    pub fn _PyErr_GetTopmostException(tstate: *mut PyThreadState) -> *mut _PyErr_StackItem;
}
extern "C" {
    pub fn _PyErr_GetExcInfo(
        arg1: *mut PyThreadState,
        arg2: *mut *mut PyObject,
        arg3: *mut *mut PyObject,
        arg4: *mut *mut PyObject,
    );
}
extern "C" {
    #[doc = " Context manipulation (PEP 3134)"]
    pub fn _PyErr_ChainExceptions(arg1: *mut PyObject, arg2: *mut PyObject, arg3: *mut PyObject);
}
extern "C" {
    #[doc = " Like PyErr_Format(), but saves current exception as __context__ and\n__cause__."]
    pub fn _PyErr_FormatFromCause(
        exception: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " In signalmodule.c"]
    pub fn PySignal_SetWakeupFd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyErr_CheckSignals() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Support for adding program text to SyntaxErrors"]
    pub fn PyErr_SyntaxLocationObject(
        filename: *mut PyObject,
        lineno: ::std::os::raw::c_int,
        col_offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PyErr_ProgramTextObject(
        filename: *mut PyObject,
        lineno: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a UnicodeEncodeError object.\n\n TODO: This API will be removed in Python 3.11."]
    pub fn PyUnicodeEncodeError_Create(
        encoding: *const ::std::os::raw::c_char,
        object: *const Py_UNICODE,
        length: Py_ssize_t,
        start: Py_ssize_t,
        end: Py_ssize_t,
        reason: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Create a UnicodeTranslateError object.\n\n TODO: This API will be removed in Python 3.11."]
    pub fn PyUnicodeTranslateError_Create(
        object: *const Py_UNICODE,
        length: Py_ssize_t,
        start: Py_ssize_t,
        end: Py_ssize_t,
        reason: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyUnicodeTranslateError_Create(
        object: *mut PyObject,
        start: Py_ssize_t,
        end: Py_ssize_t,
        reason: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyErr_WriteUnraisableMsg(err_msg: *const ::std::os::raw::c_char, obj: *mut PyObject);
}
extern "C" {
    pub fn _Py_FatalErrorFunc(
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn _Py_FatalErrorFormat(
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub type PyThread_type_lock = *mut ::std::os::raw::c_void;
pub const PyLockStatus_PY_LOCK_FAILURE: PyLockStatus = 0;
pub const PyLockStatus_PY_LOCK_ACQUIRED: PyLockStatus = 1;
pub const PyLockStatus_PY_LOCK_INTR: PyLockStatus = 2;
#[doc = " Return status codes for Python lock acquisition.  Chosen for maximum\n backwards compatibility, ie failure -> 0, success -> 1."]
pub type PyLockStatus = ::std::os::raw::c_uint;
extern "C" {
    pub fn PyThread_init_thread();
}
extern "C" {
    pub fn PyThread_start_new_thread(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PyThread_exit_thread() -> !;
}
extern "C" {
    pub fn PyThread_get_thread_ident() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PyThread_get_thread_native_id() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PyThread_allocate_lock() -> PyThread_type_lock;
}
extern "C" {
    pub fn PyThread_free_lock(arg1: PyThread_type_lock);
}
extern "C" {
    pub fn PyThread_acquire_lock(
        arg1: PyThread_type_lock,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Private function to reinitialize a lock at fork in the child process.\nReset the lock to the unlocked state.\nReturn 0 on success, return -1 on error."]
    pub fn _PyThread_at_fork_reinit(lock: *mut PyThread_type_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If microseconds == 0, the call is non-blocking: it returns immediately\neven when the lock can't be acquired.\nIf microseconds > 0, the call waits up to the specified duration.\nIf microseconds < 0, the call waits until success (or abnormal failure)\n\nmicroseconds must be less than PY_TIMEOUT_MAX. Behaviour otherwise is\nundefined.\n\nIf intr_flag is true and the acquire is interrupted by a signal, then the\ncall will return PY_LOCK_INTR.  The caller may reattempt to acquire the\nlock."]
    pub fn PyThread_acquire_lock_timed(
        arg1: PyThread_type_lock,
        microseconds: ::std::os::raw::c_longlong,
        intr_flag: ::std::os::raw::c_int,
    ) -> PyLockStatus;
}
extern "C" {
    pub fn PyThread_release_lock(arg1: PyThread_type_lock);
}
extern "C" {
    pub fn PyThread_get_stacksize() -> usize;
}
extern "C" {
    pub fn PyThread_set_stacksize(arg1: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyThread_GetInfo() -> *mut PyObject;
}
extern "C" {
    #[doc = " Thread Local Storage (TLS) API\nTLS API is DEPRECATED.  Use Thread Specific Storage (TSS) API.\n\nThe existing TLS API has used int to represent TLS keys across all\nplatforms, but it is not POSIX-compliant.  Therefore, the new TSS API uses\nopaque data type to represent TSS keys to be compatible (see PEP 539)."]
    pub fn PyThread_create_key() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyThread_delete_key(key: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PyThread_set_key_value(
        key: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyThread_get_key_value(key: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PyThread_delete_key_value(key: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Cleanup after a fork"]
    pub fn PyThread_ReInitTLS();
}
#[doc = " New in 3.7 */\n/* Thread Specific Storage (TSS) API"]
pub type Py_tss_t = _Py_tss_t;
#[doc = " Data structure to describe a process' schedulability."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
#[doc = " Type for array elements in 'cpu_set_t'."]
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[doc = " Data structure to describe CPU mask."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    #[doc = " Set scheduling parameters for a process."]
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve scheduling parameters for a particular process."]
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling algorithm and/or parameters for a process."]
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve scheduling algorithm for a particular purpose."]
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Yield the processor."]
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get maximum priority value for a scheduler."]
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get minimum priority value for a scheduler."]
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[doc = " Calling environment, plus possibly a saved signal mask."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __jmp_buf_tag {
    #[doc = " Calling environment."]
    pub __jmpbuf: __jmp_buf,
    #[doc = " Saved the signal mask?"]
    pub __mask_was_saved: ::std::os::raw::c_int,
    #[doc = " Saved signal mask."]
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_6 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_6 = 1;
#[doc = " Detach state."]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_7 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_7 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_7 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_7 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_7 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_7 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_7 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_7 = 0;
#[doc = " Mutex types."]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_8 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_8 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_8 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_8 = 1;
#[doc = " Robust mutex or not flags."]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_9 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_9 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_9 = 2;
#[doc = " Mutex protocols."]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_10 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_10 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_10 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_10 = 0;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_11 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_11 = 1;
#[doc = " Scheduler inheritance."]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_12 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_12 = 1;
#[doc = " Scope handling."]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_13 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_13 = 1;
#[doc = " Process shared or private flag."]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[doc = " Cleanup buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _pthread_cleanup_buffer {
    #[doc = " Function to call."]
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Its argument."]
    pub __arg: *mut ::std::os::raw::c_void,
    #[doc = " Saved cancellation type."]
    pub __canceltype: ::std::os::raw::c_int,
    #[doc = " Chaining of cleanup functions."]
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_14 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_14 = 1;
#[doc = " Cancellation"]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_15 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_15 = 1;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new thread, starting with execution of START-ROUTINE\ngetting passed ARG.  Creation attributed come from ATTR.  The new\nhandle is stored in *NEWTHREAD."]
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Terminate calling thread.\n\nThe registered cleanup handlers are called via exception handling\nso we cannot mark this function with __THROW."]
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    #[doc = " Make calling thread wait for termination of the thread TH.  The\nexit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN\nis not NULL.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicate that the thread TH is never to be joined with PTHREAD_JOIN.\nThe resources of TH will therefore be freed immediately when it\nterminates, instead of waiting for another thread to perform PTHREAD_JOIN\non it."]
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain the identifier of the current thread."]
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    #[doc = " Compare two thread identifiers."]
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize thread attribute *ATTR with default attributes\n(detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,\nno user-provided stack)."]
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy thread attribute *ATTR."]
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get detach state attribute."]
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set detach state attribute."]
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the size of the guard area created for stack overflow protection."]
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the size of the guard area created for stack overflow protection."]
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *PARAM the scheduling parameters of *ATTR."]
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling parameters (priority, etc) in *ATTR according to PARAM."]
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *POLICY the scheduling policy of *ATTR."]
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling policy in *ATTR according to POLICY."]
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *INHERIT the scheduling inheritance mode of *ATTR."]
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling inheritance mode in *ATTR according to INHERIT."]
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *SCOPE the scheduling contention scope of *ATTR."]
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling contention scope in *ATTR according to SCOPE."]
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the previously set address for the stack."]
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the starting address of the stack of the thread to be created.\nDepending on whether the stack grows up or down the value must either\nbe higher or lower than all the address in the memory block.  The\nminimal size of the block must be PTHREAD_STACK_MIN."]
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the currently used minimal stack size."]
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add information about the minimum stack size needed for the thread\nto be started.  This size must never be less than PTHREAD_STACK_MIN\nand must also not exceed the system limits."]
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the previously set address for the stack."]
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The following two interfaces are intended to replace the last two.  They\nrequire setting the address as well as the size since only setting the\naddress will make the implementation on some architectures impossible."]
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the scheduling parameters for TARGET_THREAD according to POLICY\nand *PARAM."]
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD."]
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the scheduling priority for TARGET_THREAD."]
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Guarantee that the initialization function INIT_ROUTINE will be called\nonly once, even if pthread_once is executed several times with the\nsame ONCE_CONTROL argument. ONCE_CONTROL must point to a static or\nextern variable initialized to PTHREAD_ONCE_INIT.\n\nThe initialization functions might throw exception which is why\nthis function is not marked with __THROW."]
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set cancelability state of current thread to STATE, returning old\nstate in *OLDSTATE if OLDSTATE is not NULL."]
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set cancellation state of current thread to TYPE, returning the old\ntype in *OLDTYPE if OLDTYPE is not NULL."]
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancel THREAD immediately or at the next possibility."]
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test for pending cancellation for the current thread and terminate\nthe thread as per pthread_exit(PTHREAD_CANCELED) if it has been\ncancelled."]
    pub fn pthread_testcancel();
}
#[doc = " Cancellation handling with integration into exception handling."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure to hold the cleanup handler information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    #[doc = " Internal interface to initiate cleanup."]
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a mutex."]
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a mutex."]
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try locking a mutex."]
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lock a mutex."]
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unlock a mutex."]
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the priority ceiling of MUTEX."]
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the priority ceiling of MUTEX to PRIOCEILING, return old\npriority ceiling value in *OLD_CEILING."]
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Declare the state protected by MUTEX as consistent."]
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize mutex attribute object ATTR with default attributes\n(kind is PTHREAD_MUTEX_TIMED_NP)."]
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy mutex attribute object ATTR."]
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the process-shared flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process-shared flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *KIND the mutex kind attribute in *ATTR."]
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,\nPTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or\nPTHREAD_MUTEX_DEFAULT)."]
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *PROTOCOL the mutex protocol attribute in *ATTR."]
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the mutex protocol attribute in *ATTR to PROTOCOL (either\nPTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT)."]
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR."]
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the mutex prioceiling attribute in *ATTR to PRIOCEILING."]
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the robustness flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the robustness flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize read-write lock RWLOCK using attributes ATTR, or use\nthe default values if later is NULL."]
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy read-write lock RWLOCK."]
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Acquire read lock for RWLOCK."]
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to acquire read lock for RWLOCK."]
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Acquire write lock for RWLOCK."]
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to acquire write lock for RWLOCK."]
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unlock RWLOCK."]
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize attribute object ATTR with default values."]
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy attribute object ATTR."]
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current setting of process-shared attribute of ATTR in PSHARED."]
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set process-shared attribute of ATTR to PSHARED."]
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current setting of reader/writer preference."]
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set reader/write preference."]
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize condition variable COND using attributes ATTR, or use\nthe default values if later is NULL."]
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy condition variable COND."]
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wake up one thread waiting for condition variable COND."]
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wake up all threads waiting for condition variables COND."]
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for condition variable COND to be signaled or broadcast.\nMUTEX is assumed to be locked before.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize condition variable attribute ATTR."]
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy condition variable attribute ATTR."]
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the process-shared flag of the condition variable attribute ATTR."]
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process-shared flag of the condition variable attribute ATTR."]
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the clock selected for the condition variable attribute ATTR."]
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the clock selected for the condition variable attribute ATTR."]
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can\nbe shared between different processes."]
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy the spinlock LOCK."]
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait until spinlock LOCK is retrieved."]
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to lock spinlock LOCK."]
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release spinlock LOCK."]
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize BARRIER with the attributes in ATTR.  The barrier is\nopened when COUNT waiters arrived."]
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a previously dynamically initialized barrier BARRIER."]
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait on barrier BARRIER."]
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize barrier attribute ATTR."]
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy previously dynamically initialized barrier attribute ATTR."]
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the process-shared flag of the barrier attribute ATTR."]
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process-shared flag of the barrier attribute ATTR."]
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a key value identifying a location in the thread-specific\ndata area.  Each thread maintains a distinct thread-specific data\narea.  DESTR_FUNCTION, if non-NULL, is called with the value\nassociated to that key when the key is destroyed.\nDESTR_FUNCTION is not called if the value associated is NULL when\nthe key is destroyed."]
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy KEY."]
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current value of the thread-specific data slot identified by KEY."]
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Store POINTER in the thread-specific data slot identified by KEY."]
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get ID of CPU-time clock for thread THREAD_ID."]
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Install handlers to be called when a new process is created with FORK.\nThe PREPARE handler is called in the parent process just before performing\nFORK. The PARENT handler is called in the parent process just after FORK.\nThe CHILD handler is called in the child process.  Each of the three\nhandlers can be NULL, meaning that no handler needs to be called at that\npoint.\nPTHREAD_ATFORK can be called several times, in which case the PREPARE\nhandlers are called in LIFO order (last added with PTHREAD_ATFORK,\nfirst called before FORK), and the PARENT and CHILD handlers are called\nin FIFO (first added, first called)."]
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[doc = " When Py_LIMITED_API is not defined, the type layout of Py_tss_t is\nexposed to allow static allocation in the API clients.  Even in this case,\nyou must handle TSS keys through API functions due to compatibility."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Py_tss_t {
    pub _is_initialized: ::std::os::raw::c_int,
    pub _key: pthread_key_t,
}
#[test]
fn bindgen_test_layout__Py_tss_t() {
    const UNINIT: ::std::mem::MaybeUninit<_Py_tss_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Py_tss_t>(),
        8usize,
        concat!("Size of: ", stringify!(_Py_tss_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Py_tss_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_Py_tss_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_tss_t),
            "::",
            stringify!(_is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Py_tss_t),
            "::",
            stringify!(_key)
        )
    );
}
extern "C" {
    pub fn PyThread_tss_alloc() -> *mut Py_tss_t;
}
extern "C" {
    pub fn PyThread_tss_free(key: *mut Py_tss_t);
}
extern "C" {
    #[doc = " The parameter key must not be NULL."]
    pub fn PyThread_tss_is_created(key: *mut Py_tss_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyThread_tss_create(key: *mut Py_tss_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyThread_tss_delete(key: *mut Py_tss_t);
}
extern "C" {
    pub fn PyThread_tss_set(
        key: *mut Py_tss_t,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyThread_tss_get(key: *mut Py_tss_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut PyContext_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pycontextobject {
    _unused: [u8; 0],
}
pub type PyContext = _pycontextobject;
extern "C" {
    pub static mut PyContextVar_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pycontextvarobject {
    _unused: [u8; 0],
}
pub type PyContextVar = _pycontextvarobject;
extern "C" {
    pub static mut PyContextToken_Type: PyTypeObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pycontexttokenobject {
    _unused: [u8; 0],
}
pub type PyContextToken = _pycontexttokenobject;
extern "C" {
    pub fn PyContext_New() -> *mut PyObject;
}
extern "C" {
    pub fn PyContext_Copy(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyContext_CopyCurrent() -> *mut PyObject;
}
extern "C" {
    pub fn PyContext_Enter(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyContext_Exit(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new context variable.\n\ndefault_value can be NULL."]
    pub fn PyContextVar_New(
        name: *const ::std::os::raw::c_char,
        default_value: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get a value for the variable.\n\nReturns -1 if an error occurred during lookup.\n\nReturns 0 if value either was or was not found.\n\nIf value was found, *value will point to it.\nIf not, it will point to:\n\n- default_value, if not NULL;\n- the default value of \"var\", if not NULL;\n- NULL.\n\n'*value' will be a new ref, if not NULL."]
    pub fn PyContextVar_Get(
        var: *mut PyObject,
        default_value: *mut PyObject,
        value: *mut *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a new value for the variable.\nReturns NULL if an error occurs."]
    pub fn PyContextVar_Set(var: *mut PyObject, value: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Reset a variable to its previous value.\nReturns 0 on success, -1 on error."]
    pub fn PyContextVar_Reset(var: *mut PyObject, token: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This method is exposed only for CPython tests. Don not use it."]
    pub fn _PyContext_NewHamtForTests() -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _arena {
    _unused: [u8; 0],
}
pub type PyArena = _arena;
extern "C" {
    #[doc = " PyArena_New() and PyArena_Free() create a new arena and free it,\nrespectively.  Once an arena has been created, it can be used\nto allocate memory via PyArena_Malloc().  Pointers to PyObject can\nalso be registered with the arena via PyArena_AddPyObject(), and the\narena will ensure that the PyObjects stay alive at least until\nPyArena_Free() is called.  When an arena is freed, all the memory it\nallocated is freed, the arena releases internal references to registered\nPyObject*, and none of its pointers are valid.\nXXX (tim) What does \"none of its pointers are valid\" mean?  Does it\nXXX mean that pointers previously obtained via PyArena_Malloc() are\nXXX no longer valid?  (That's clearly true, but not sure that's what\nXXX the text is trying to say.)\n\nPyArena_New() returns an arena pointer.  On error, it\nreturns a negative number and sets an exception.\nXXX (tim):  Not true.  On error, PyArena_New() actually returns NULL,\nXXX and looks like it may or may not set an exception (e.g., if the\nXXX internal PyList_New(0) returns NULL, PyArena_New() passes that on\nXXX and an exception is set; OTOH, if the internal\nXXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but\nXXX an exception is not set in that case)."]
    pub fn PyArena_New() -> *mut PyArena;
}
extern "C" {
    pub fn PyArena_Free(arg1: *mut PyArena);
}
extern "C" {
    #[doc = " Mostly like malloc(), return the address of a block of memory spanning\n `size` bytes, or return NULL (without setting an exception) if enough\n new memory can't be obtained.  Unlike malloc(0), PyArena_Malloc() with\n size=0 does not guarantee to return a unique pointer (the pointer\n returned may equal one or more other pointers obtained from\n PyArena_Malloc()).\n Note that pointers obtained via PyArena_Malloc() must never be passed to\n the system free() or realloc(), or to any of Python's similar memory-\n management functions.  PyArena_Malloc()-obtained pointers remain valid\n until PyArena_Free(ar) is called, at which point all pointers obtained\n from the arena `ar` become invalid simultaneously."]
    pub fn PyArena_Malloc(arg1: *mut PyArena, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This routine isn't a proper arena allocation routine.  It takes\n a PyObject* and records it so that it can be DECREFed when the\n arena is freed."]
    pub fn PyArena_AddPyObject(arg1: *mut PyArena, arg2: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_VaBuildValue_SizeT(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _Py_VaBuildStack_SizeT(
        small_stack: *mut *mut PyObject,
        small_stack_len: Py_ssize_t,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
        p_nargs: *mut Py_ssize_t,
    ) -> *mut *mut PyObject;
}
extern "C" {
    pub fn PyArg_Parse(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyArg_ParseTuple(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyArg_ParseTupleAndKeywords(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyArg_VaParse(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyArg_VaParseTupleAndKeywords(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut *mut ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyArg_ValidateKeywordArguments(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyArg_UnpackTuple(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        arg3: Py_ssize_t,
        arg4: Py_ssize_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_BuildValue(arg1: *const ::std::os::raw::c_char, ...) -> *mut PyObject;
}
extern "C" {
    pub fn _Py_BuildValue_SizeT(arg1: *const ::std::os::raw::c_char, ...) -> *mut PyObject;
}
extern "C" {
    pub fn _PyArg_UnpackStack(
        args: *const *mut PyObject,
        nargs: Py_ssize_t,
        name: *const ::std::os::raw::c_char,
        min: Py_ssize_t,
        max: Py_ssize_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_NoKeywords(
        funcname: *const ::std::os::raw::c_char,
        kwargs: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_NoKwnames(
        funcname: *const ::std::os::raw::c_char,
        kwnames: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_NoPositional(
        funcname: *const ::std::os::raw::c_char,
        args: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_BadArgument(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut PyObject,
    );
}
extern "C" {
    pub fn _PyArg_CheckPositional(
        arg1: *const ::std::os::raw::c_char,
        arg2: Py_ssize_t,
        arg3: Py_ssize_t,
        arg4: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_VaBuildValue(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _Py_VaBuildStack(
        small_stack: *mut *mut PyObject,
        small_stack_len: Py_ssize_t,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
        p_nargs: *mut Py_ssize_t,
    ) -> *mut *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyArg_Parser {
    pub format: *const ::std::os::raw::c_char,
    pub keywords: *const *const ::std::os::raw::c_char,
    pub fname: *const ::std::os::raw::c_char,
    pub custom_msg: *const ::std::os::raw::c_char,
    #[doc = " number of positional-only arguments"]
    pub pos: ::std::os::raw::c_int,
    #[doc = " minimal number of arguments"]
    pub min: ::std::os::raw::c_int,
    #[doc = " maximal number of positional arguments"]
    pub max: ::std::os::raw::c_int,
    #[doc = " tuple of keyword parameter names"]
    pub kwtuple: *mut PyObject,
    pub next: *mut _PyArg_Parser,
}
#[test]
fn bindgen_test_layout__PyArg_Parser() {
    const UNINIT: ::std::mem::MaybeUninit<_PyArg_Parser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyArg_Parser>(),
        64usize,
        concat!("Size of: ", stringify!(_PyArg_Parser))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyArg_Parser>(),
        8usize,
        concat!("Alignment of ", stringify!(_PyArg_Parser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keywords) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(keywords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(fname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_msg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(custom_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kwtuple) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(kwtuple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyArg_Parser),
            "::",
            stringify!(next)
        )
    );
}
impl Default for _PyArg_Parser {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _PyArg_ParseTupleAndKeywordsFast(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut _PyArg_Parser,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_ParseStack(
        args: *const *mut PyObject,
        nargs: Py_ssize_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_ParseStackAndKeywords(
        args: *const *mut PyObject,
        nargs: Py_ssize_t,
        kwnames: *mut PyObject,
        arg1: *mut _PyArg_Parser,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_VaParseTupleAndKeywordsFast(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut _PyArg_Parser,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyArg_UnpackKeywords(
        args: *const *mut PyObject,
        nargs: Py_ssize_t,
        kwargs: *mut PyObject,
        kwnames: *mut PyObject,
        parser: *mut _PyArg_Parser,
        minpos: ::std::os::raw::c_int,
        maxpos: ::std::os::raw::c_int,
        minkw: ::std::os::raw::c_int,
        buf: *mut *mut PyObject,
    ) -> *const *mut PyObject;
}
extern "C" {
    pub fn _PyArg_Fini();
}
extern "C" {
    pub fn PyModule_AddObject(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyModule_AddIntConstant(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyModule_AddStringConstant(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " New in 3.9"]
    pub fn PyModule_AddType(
        module: *mut PyObject,
        type_: *mut PyTypeObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " New in 3.5"]
    pub fn PyModule_SetDocString(
        arg1: *mut PyObject,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyModule_AddFunctions(
        arg1: *mut PyObject,
        arg2: *mut PyMethodDef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyModule_ExecDef(module: *mut PyObject, def: *mut PyModuleDef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyModule_Create2(arg1: *mut PyModuleDef, apiver: ::std::os::raw::c_int)
        -> *mut PyObject;
}
extern "C" {
    pub fn _PyModule_CreateInitialized(
        arg1: *mut PyModuleDef,
        apiver: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " New in 3.5"]
    pub fn PyModule_FromDefAndSpec2(
        def: *mut PyModuleDef,
        spec: *mut PyObject,
        module_api_version: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub static mut _Py_PackageContext: *const ::std::os::raw::c_char;
}
#[doc = " Public interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _node {
    _unused: [u8; 0],
}
extern "C" {
    pub fn PyNode_Compile(
        arg1: *mut _node,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut PyCodeObject;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyCompilerFlags {
    #[doc = " bitmask of CO_xxx flags relevant to future"]
    pub cf_flags: ::std::os::raw::c_int,
    #[doc = " minor Python version (PyCF_ONLY_AST)"]
    pub cf_feature_version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PyCompilerFlags() {
    const UNINIT: ::std::mem::MaybeUninit<PyCompilerFlags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyCompilerFlags>(),
        8usize,
        concat!("Size of: ", stringify!(PyCompilerFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<PyCompilerFlags>(),
        4usize,
        concat!("Alignment of ", stringify!(PyCompilerFlags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cf_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCompilerFlags),
            "::",
            stringify!(cf_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cf_feature_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PyCompilerFlags),
            "::",
            stringify!(cf_feature_version)
        )
    );
}
#[doc = " Future feature support"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct PyFutureFeatures {
    #[doc = " flags set by future statements"]
    pub ff_features: ::std::os::raw::c_int,
    #[doc = " line number of last future statement"]
    pub ff_lineno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PyFutureFeatures() {
    const UNINIT: ::std::mem::MaybeUninit<PyFutureFeatures> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PyFutureFeatures>(),
        8usize,
        concat!("Size of: ", stringify!(PyFutureFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<PyFutureFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(PyFutureFeatures))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ff_features) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFutureFeatures),
            "::",
            stringify!(ff_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ff_lineno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PyFutureFeatures),
            "::",
            stringify!(ff_lineno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mod {
    _unused: [u8; 0],
}
extern "C" {
    pub fn PyAST_CompileEx(
        mod_: *mut _mod,
        filename: *const ::std::os::raw::c_char,
        flags: *mut PyCompilerFlags,
        optimize: ::std::os::raw::c_int,
        arena: *mut PyArena,
    ) -> *mut PyCodeObject;
}
extern "C" {
    pub fn PyAST_CompileObject(
        mod_: *mut _mod,
        filename: *mut PyObject,
        flags: *mut PyCompilerFlags,
        optimize: ::std::os::raw::c_int,
        arena: *mut PyArena,
    ) -> *mut PyCodeObject;
}
extern "C" {
    pub fn PyFuture_FromAST(
        mod_: *mut _mod,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut PyFutureFeatures;
}
extern "C" {
    pub fn PyFuture_FromASTObject(
        mod_: *mut _mod,
        filename: *mut PyObject,
    ) -> *mut PyFutureFeatures;
}
extern "C" {
    #[doc = " _Py_Mangle is defined in compile.c"]
    pub fn _Py_Mangle(p: *mut PyObject, name: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyCompile_OpcodeStackEffect(
        opcode: ::std::os::raw::c_int,
        oparg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyCompile_OpcodeStackEffectWithJump(
        opcode: ::std::os::raw::c_int,
        oparg: ::std::os::raw::c_int,
        jump: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _PyASTOptimizeState {
    pub optimize: ::std::os::raw::c_int,
    pub ff_features: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__PyASTOptimizeState() {
    const UNINIT: ::std::mem::MaybeUninit<_PyASTOptimizeState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PyASTOptimizeState>(),
        8usize,
        concat!("Size of: ", stringify!(_PyASTOptimizeState))
    );
    assert_eq!(
        ::std::mem::align_of::<_PyASTOptimizeState>(),
        4usize,
        concat!("Alignment of ", stringify!(_PyASTOptimizeState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optimize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyASTOptimizeState),
            "::",
            stringify!(optimize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ff_features) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PyASTOptimizeState),
            "::",
            stringify!(ff_features)
        )
    );
}
extern "C" {
    pub fn _PyAST_Optimize(
        arg1: *mut _mod,
        arena: *mut PyArena,
        state: *mut _PyASTOptimizeState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_SimpleStringFlags(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_AnyFileExFlags(
        fp: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        closeit: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_SimpleFileExFlags(
        fp: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        closeit: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_InteractiveOneFlags(
        fp: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        flags: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_InteractiveOneObject(
        fp: *mut FILE,
        filename: *mut PyObject,
        flags: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_InteractiveLoopFlags(
        fp: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        flags: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyParser_ASTFromString(
        s: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
        arena: *mut PyArena,
    ) -> *mut _mod;
}
extern "C" {
    pub fn PyParser_ASTFromStringObject(
        s: *const ::std::os::raw::c_char,
        filename: *mut PyObject,
        start: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
        arena: *mut PyArena,
    ) -> *mut _mod;
}
extern "C" {
    pub fn PyParser_ASTFromFile(
        fp: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        enc: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
        ps1: *const ::std::os::raw::c_char,
        ps2: *const ::std::os::raw::c_char,
        flags: *mut PyCompilerFlags,
        errcode: *mut ::std::os::raw::c_int,
        arena: *mut PyArena,
    ) -> *mut _mod;
}
extern "C" {
    pub fn PyParser_ASTFromFileObject(
        fp: *mut FILE,
        filename: *mut PyObject,
        enc: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
        ps1: *const ::std::os::raw::c_char,
        ps2: *const ::std::os::raw::c_char,
        flags: *mut PyCompilerFlags,
        errcode: *mut ::std::os::raw::c_int,
        arena: *mut PyArena,
    ) -> *mut _mod;
}
extern "C" {
    pub fn PyParser_SimpleParseStringFlags(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut _node;
}
extern "C" {
    pub fn PyParser_SimpleParseStringFlagsFilename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut _node;
}
extern "C" {
    pub fn PyParser_SimpleParseFileFlags(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut _node;
}
extern "C" {
    pub fn PyRun_StringFlags(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut PyObject,
        arg4: *mut PyObject,
        arg5: *mut PyCompilerFlags,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyRun_FileExFlags(
        fp: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
        globals: *mut PyObject,
        locals: *mut PyObject,
        closeit: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn Py_CompileStringExFlags(
        str_: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
        optimize: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn Py_CompileStringObject(
        str_: *const ::std::os::raw::c_char,
        filename: *mut PyObject,
        start: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
        optimize: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symtable {
    _unused: [u8; 0],
}
extern "C" {
    pub fn Py_SymtableString(
        str_: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
    ) -> *mut symtable;
}
extern "C" {
    pub fn _Py_SourceAsString(
        cmd: *mut PyObject,
        funcname: *const ::std::os::raw::c_char,
        what: *const ::std::os::raw::c_char,
        cf: *mut PyCompilerFlags,
        cmd_copy: *mut *mut PyObject,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Py_SymtableStringObject(
        str_: *const ::std::os::raw::c_char,
        filename: *mut PyObject,
        start: ::std::os::raw::c_int,
    ) -> *mut symtable;
}
extern "C" {
    pub fn _Py_SymtableStringObjectFlags(
        str_: *const ::std::os::raw::c_char,
        filename: *mut PyObject,
        start: ::std::os::raw::c_int,
        flags: *mut PyCompilerFlags,
    ) -> *mut symtable;
}
extern "C" {
    pub fn PyErr_Print();
}
extern "C" {
    pub fn PyErr_PrintEx(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PyErr_Display(arg1: *mut PyObject, arg2: *mut PyObject, arg3: *mut PyObject);
}
extern "C" {
    #[doc = " A function flavor is also exported by libpython. It is required when\nlibpython is accessed directly rather than using header files which defines\nmacros below. On Windows, for example, PyAPI_FUNC() uses dllexport to\nexport functions in pythonXX.dll."]
    pub fn PyRun_String(
        str_: *const ::std::os::raw::c_char,
        s: ::std::os::raw::c_int,
        g: *mut PyObject,
        l: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyRun_AnyFile(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_AnyFileEx(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        closeit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_AnyFileFlags(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut PyCompilerFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_SimpleString(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_SimpleFile(
        f: *mut FILE,
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_SimpleFileEx(
        f: *mut FILE,
        p: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_InteractiveOne(
        f: *mut FILE,
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_InteractiveLoop(
        f: *mut FILE,
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyRun_File(
        fp: *mut FILE,
        p: *const ::std::os::raw::c_char,
        s: ::std::os::raw::c_int,
        g: *mut PyObject,
        l: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyRun_FileEx(
        fp: *mut FILE,
        p: *const ::std::os::raw::c_char,
        s: ::std::os::raw::c_int,
        g: *mut PyObject,
        l: *mut PyObject,
        c: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyRun_FileFlags(
        fp: *mut FILE,
        p: *const ::std::os::raw::c_char,
        s: ::std::os::raw::c_int,
        g: *mut PyObject,
        l: *mut PyObject,
        flags: *mut PyCompilerFlags,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyOS_Readline(
        arg1: *mut FILE,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut PyOS_InputHook:
        ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
}
extern "C" {
    pub static mut PyOS_ReadlineFunctionPointer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut FILE,
            arg2: *mut FILE,
            arg3: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut _PyOS_ReadlineTState: *mut PyThreadState;
}
extern "C" {
    #[doc = " Initialization and finalization"]
    pub fn Py_Initialize();
}
extern "C" {
    pub fn Py_InitializeEx(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Py_Finalize();
}
extern "C" {
    pub fn Py_FinalizeEx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_IsInitialized() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Subinterpreter support"]
    pub fn Py_NewInterpreter() -> *mut PyThreadState;
}
extern "C" {
    pub fn Py_EndInterpreter(arg1: *mut PyThreadState);
}
extern "C" {
    #[doc = " Py_PyAtExit is for the atexit module, Py_AtExit is for low-level\n exit functions."]
    pub fn Py_AtExit(func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Bootstrap __main__ (defined in Modules/main.c)"]
    pub fn Py_Main(argc: ::std::os::raw::c_int, argv: *mut *mut wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_FrozenMain(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_BytesMain(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " In pathconfig.c"]
    pub fn Py_SetProgramName(arg1: *const wchar_t);
}
extern "C" {
    pub fn Py_GetProgramName() -> *mut wchar_t;
}
extern "C" {
    pub fn Py_SetPythonHome(arg1: *const wchar_t);
}
extern "C" {
    pub fn Py_GetPythonHome() -> *mut wchar_t;
}
extern "C" {
    pub fn Py_GetProgramFullPath() -> *mut wchar_t;
}
extern "C" {
    pub fn Py_GetPrefix() -> *mut wchar_t;
}
extern "C" {
    pub fn Py_GetExecPrefix() -> *mut wchar_t;
}
extern "C" {
    pub fn Py_GetPath() -> *mut wchar_t;
}
extern "C" {
    pub fn Py_SetPath(arg1: *const wchar_t);
}
extern "C" {
    #[doc = " In their own files"]
    pub fn IDP_GetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Py_GetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Py_GetPlatform() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Py_GetCopyright() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Py_GetCompiler() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Py_GetBuildInfo() -> *const ::std::os::raw::c_char;
}
#[doc = " Signals"]
pub type PyOS_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn PyOS_getsig(arg1: ::std::os::raw::c_int) -> PyOS_sighandler_t;
}
extern "C" {
    pub fn PyOS_setsig(arg1: ::std::os::raw::c_int, arg2: PyOS_sighandler_t) -> PyOS_sighandler_t;
}
extern "C" {
    #[doc = " Only used by applications that embed the interpreter and need to\n override the standard encoding determination mechanism"]
    pub fn Py_SetStandardStreamEncoding(
        encoding: *const ::std::os::raw::c_char,
        errors: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " PEP 432 Multi-phase initialization API (Private while provisional!)"]
    pub fn Py_PreInitialize(src_config: *const PyPreConfig) -> PyStatus;
}
extern "C" {
    pub fn Py_PreInitializeFromBytesArgs(
        src_config: *const PyPreConfig,
        argc: Py_ssize_t,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> PyStatus;
}
extern "C" {
    pub fn Py_PreInitializeFromArgs(
        src_config: *const PyPreConfig,
        argc: Py_ssize_t,
        argv: *mut *mut wchar_t,
    ) -> PyStatus;
}
extern "C" {
    pub fn _Py_IsCoreInitialized() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialization and finalization"]
    pub fn Py_InitializeFromConfig(config: *const PyConfig) -> PyStatus;
}
extern "C" {
    pub fn _Py_InitializeMain() -> PyStatus;
}
extern "C" {
    pub fn Py_RunMain() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_ExitStatusException(err: PyStatus) -> !;
}
extern "C" {
    #[doc = " Py_PyAtExit is for the atexit module, Py_AtExit is for low-level\n exit functions."]
    pub fn _Py_PyAtExit(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut PyObject)>,
        arg1: *mut PyObject,
    );
}
extern "C" {
    #[doc = " Restore signals that the interpreter has called SIG_IGN on to SIG_DFL."]
    pub fn _Py_RestoreSignals();
}
extern "C" {
    pub fn Py_FdIsInteractive(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_SetProgramFullPath(arg1: *const wchar_t);
}
extern "C" {
    pub fn _Py_gitidentifier() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _Py_gitversion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _Py_IsFinalizing() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Random"]
    pub fn _PyOS_URandom(
        buffer: *mut ::std::os::raw::c_void,
        size: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyOS_URandomNonblock(
        buffer: *mut ::std::os::raw::c_void,
        size: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Legacy locale support"]
    pub fn _Py_CoerceLegacyLocale(warn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_LegacyLocaleDetected(warn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_SetLocaleFromEnv(category: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _Py_NewInterpreter(isolated_subinterpreter: ::std::os::raw::c_int)
        -> *mut PyThreadState;
}
extern "C" {
    #[doc = " PyEval_CallObjectWithKeywords(), PyEval_CallObject(), PyEval_CallFunction\n and PyEval_CallMethod are deprecated. Since they are officially part of the\n stable ABI (PEP 384), they must be kept for backward compatibility.\n PyObject_Call(), PyObject_CallFunction() and PyObject_CallMethod() are\n recommended to call a callable object."]
    pub fn PyEval_CallObjectWithKeywords(
        callable: *mut PyObject,
        args: *mut PyObject,
        kwargs: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_CallFunction(
        callable: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_CallMethod(
        obj: *mut PyObject,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_GetBuiltins() -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_GetGlobals() -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_GetLocals() -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_GetFrame() -> *mut PyFrameObject;
}
extern "C" {
    pub fn Py_AddPendingCall(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_MakePendingCalls() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Protection against deeply nested recursive calls\n\nIn Python 3.0, this protection has two levels:\n normal anti-recursion protection is triggered when the recursion level\nexceeds the current recursion limit. It raises a RecursionError, and sets\nthe \"overflowed\" flag in the thread state structure. This flag\ntemporarily *disables* the normal protection; this allows cleanup code\nto potentially outgrow the recursion limit while processing the\nRecursionError.\n \"last chance\" anti-recursion protection is triggered when the recursion\nlevel exceeds \"current recursion limit + 50\". By construction, this\nprotection can only be triggered when the \"overflowed\" flag is set. It\nmeans the cleanup code has itself gone into an infinite loop, or the\nRecursionError has been mistakingly ignored. When this protection is\ntriggered, the interpreter aborts with a Fatal Error.\n\nIn addition, the \"overflowed\" flag is automatically reset when the\nrecursion level drops below \"current recursion limit - 50\". This heuristic\nis meant to ensure that the normal anti-recursion protection doesn't get\ndisabled too long.\n\nPlease note: this scheme has its own limitations. See:\nhttp://mail.python.org/pipermail/python-dev/2008-August/082106.html\nfor some observations."]
    pub fn Py_SetRecursionLimit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Py_GetRecursionLimit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_EnterRecursiveCall(where_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_LeaveRecursiveCall();
}
extern "C" {
    pub fn PyEval_GetFuncName(arg1: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyEval_GetFuncDesc(arg1: *mut PyObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyEval_EvalFrame(arg1: *mut PyFrameObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_EvalFrameEx(f: *mut PyFrameObject, exc: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    #[doc = " Interface for threads.\n\nA module that plans to do a blocking system call (or something else\nthat lasts a long time and doesn't touch Python data) can allow other\nthreads to run as follows:\n\n...preparations here...\nPy_BEGIN_ALLOW_THREADS\n...blocking system call here...\nPy_END_ALLOW_THREADS\n...interpret result here...\n\nThe Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a\n{}-surrounded block.\nTo leave the block in the middle (e.g., with return), you must insert\na line containing Py_BLOCK_THREADS before the return, e.g.\n\nif (...premature_exit...) {\nPy_BLOCK_THREADS\nPyErr_SetFromErrno(PyExc_OSError);\nreturn NULL;\n}\n\nAn alternative is:\n\nPy_BLOCK_THREADS\nif (...premature_exit...) {\nPyErr_SetFromErrno(PyExc_OSError);\nreturn NULL;\n}\nPy_UNBLOCK_THREADS\n\nFor convenience, that the value of 'errno' is restored across\nPy_END_ALLOW_THREADS and Py_BLOCK_THREADS.\n\nWARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND\nPy_END_ALLOW_THREADS!!!\n\nNote that not yet all candidates have been converted to use this\nmechanism!"]
    pub fn PyEval_SaveThread() -> *mut PyThreadState;
}
extern "C" {
    pub fn PyEval_RestoreThread(arg1: *mut PyThreadState);
}
extern "C" {
    pub fn PyEval_ThreadsInitialized() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyEval_InitThreads();
}
extern "C" {
    #[doc = " PyEval_AcquireLock() and PyEval_ReleaseLock() are part of stable ABI.\n They will be removed from this header file in the future version.\n But they will be remained in ABI until Python 4.0."]
    pub fn PyEval_AcquireLock();
}
extern "C" {
    pub fn PyEval_ReleaseLock();
}
extern "C" {
    pub fn PyEval_AcquireThread(tstate: *mut PyThreadState);
}
extern "C" {
    pub fn PyEval_ReleaseThread(tstate: *mut PyThreadState);
}
extern "C" {
    pub fn PyEval_SetProfile(arg1: Py_tracefunc, arg2: *mut PyObject);
}
extern "C" {
    pub fn _PyEval_SetProfile(
        tstate: *mut PyThreadState,
        func: Py_tracefunc,
        arg: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyEval_SetTrace(arg1: Py_tracefunc, arg2: *mut PyObject);
}
extern "C" {
    pub fn _PyEval_SetTrace(
        tstate: *mut PyThreadState,
        func: Py_tracefunc,
        arg: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyEval_GetCoroutineOriginTrackingDepth() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyEval_SetAsyncGenFirstiter(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyEval_GetAsyncGenFirstiter() -> *mut PyObject;
}
extern "C" {
    pub fn _PyEval_SetAsyncGenFinalizer(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyEval_GetAsyncGenFinalizer() -> *mut PyObject;
}
extern "C" {
    #[doc = " Helper to look up a builtin object"]
    pub fn _PyEval_GetBuiltinId(arg1: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    #[doc = " Look at the current frame's (if any) code's co_flags, and turn on\nthe corresponding compiler flags in cf->cf_flags.  Return 1 if any\nflag was set, else return 0."]
    pub fn PyEval_MergeCompilerFlags(cf: *mut PyCompilerFlags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyEval_EvalFrameDefault(
        tstate: *mut PyThreadState,
        f: *mut PyFrameObject,
        exc: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyEval_SetSwitchInterval(microseconds: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _PyEval_GetSwitchInterval() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _PyEval_RequestCodeExtraIndex(arg1: freefunc) -> Py_ssize_t;
}
extern "C" {
    pub fn _PyEval_SliceIndex(arg1: *mut PyObject, arg2: *mut Py_ssize_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyEval_SliceIndexNotNone(
        arg1: *mut PyObject,
        arg2: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySys_GetObject(arg1: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PySys_SetObject(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySys_SetArgv(arg1: ::std::os::raw::c_int, arg2: *mut *mut wchar_t);
}
extern "C" {
    pub fn PySys_SetArgvEx(
        arg1: ::std::os::raw::c_int,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PySys_SetPath(arg1: *const wchar_t);
}
extern "C" {
    pub fn PySys_WriteStdout(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn PySys_WriteStderr(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn PySys_FormatStdout(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn PySys_FormatStderr(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn PySys_ResetWarnOptions();
}
extern "C" {
    pub fn PySys_AddWarnOption(arg1: *const wchar_t);
}
extern "C" {
    pub fn PySys_AddWarnOptionUnicode(arg1: *mut PyObject);
}
extern "C" {
    pub fn PySys_HasWarnOptions() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySys_AddXOption(arg1: *const wchar_t);
}
extern "C" {
    pub fn PySys_GetXOptions() -> *mut PyObject;
}
extern "C" {
    pub fn _PySys_GetObjectId(key: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    pub fn _PySys_SetObjectId(
        key: *mut _Py_Identifier,
        arg1: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PySys_GetSizeOf(arg1: *mut PyObject) -> usize;
}
pub type Py_AuditHookFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut PyObject,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn PySys_Audit(
        event: *const ::std::os::raw::c_char,
        argFormat: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PySys_AddAuditHook(
        arg1: Py_AuditHookFunction,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyOS_FSPath(path: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyOS_InterruptOccurred() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyOS_InitInterrupts();
}
extern "C" {
    pub fn PyOS_BeforeFork();
}
extern "C" {
    pub fn PyOS_AfterFork_Parent();
}
extern "C" {
    pub fn PyOS_AfterFork_Child();
}
extern "C" {
    #[doc = " Deprecated, please use PyOS_AfterFork_Child() instead"]
    pub fn PyOS_AfterFork();
}
extern "C" {
    pub fn _PyOS_IsMainThread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PySignal_AfterFork();
}
extern "C" {
    pub fn PyImport_GetMagicNumber() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn PyImport_GetMagicTag() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyImport_ExecCodeModule(
        name: *const ::std::os::raw::c_char,
        co: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ExecCodeModuleEx(
        name: *const ::std::os::raw::c_char,
        co: *mut PyObject,
        pathname: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ExecCodeModuleWithPathnames(
        name: *const ::std::os::raw::c_char,
        co: *mut PyObject,
        pathname: *const ::std::os::raw::c_char,
        cpathname: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ExecCodeModuleObject(
        name: *mut PyObject,
        co: *mut PyObject,
        pathname: *mut PyObject,
        cpathname: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_GetModuleDict() -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_GetModule(name: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_AddModuleObject(name: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_AddModule(name: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ImportModule(name: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ImportModuleNoBlock(name: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ImportModuleLevel(
        name: *const ::std::os::raw::c_char,
        globals: *mut PyObject,
        locals: *mut PyObject,
        fromlist: *mut PyObject,
        level: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ImportModuleLevelObject(
        name: *mut PyObject,
        globals: *mut PyObject,
        locals: *mut PyObject,
        fromlist: *mut PyObject,
        level: ::std::os::raw::c_int,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_GetImporter(path: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_Import(name: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ReloadModule(m: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn PyImport_ImportFrozenModuleObject(name: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyImport_ImportFrozenModule(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyImport_AppendInittab(
        name: *const ::std::os::raw::c_char,
        initfunc: ::std::option::Option<unsafe extern "C" fn() -> *mut PyObject>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyInit__imp() -> *mut PyObject;
}
extern "C" {
    pub fn _PyImport_IsInitialized(arg1: *mut PyInterpreterState) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyImport_GetModuleId(name: *mut _Py_Identifier) -> *mut PyObject;
}
extern "C" {
    pub fn _PyImport_SetModule(name: *mut PyObject, module: *mut PyObject)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyImport_SetModuleString(
        name: *const ::std::os::raw::c_char,
        module: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyImport_AcquireLock();
}
extern "C" {
    pub fn _PyImport_ReleaseLock() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyImport_FindExtensionObject(arg1: *mut PyObject, arg2: *mut PyObject)
        -> *mut PyObject;
}
extern "C" {
    pub fn _PyImport_FixupBuiltin(
        mod_: *mut PyObject,
        name: *const ::std::os::raw::c_char,
        modules: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyImport_FixupExtensionObject(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
        arg4: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _inittab {
    #[doc = " ASCII encoded string"]
    pub name: *const ::std::os::raw::c_char,
    pub initfunc: ::std::option::Option<unsafe extern "C" fn() -> *mut PyObject>,
}
#[test]
fn bindgen_test_layout__inittab() {
    const UNINIT: ::std::mem::MaybeUninit<_inittab> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_inittab>(),
        16usize,
        concat!("Size of: ", stringify!(_inittab))
    );
    assert_eq!(
        ::std::mem::align_of::<_inittab>(),
        8usize,
        concat!("Alignment of ", stringify!(_inittab))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_inittab),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initfunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_inittab),
            "::",
            stringify!(initfunc)
        )
    );
}
impl Default for _inittab {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut PyImport_Inittab: *mut _inittab;
}
extern "C" {
    pub fn PyImport_ExtendInittab(newtab: *mut _inittab) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _frozen {
    #[doc = " ASCII encoded string"]
    pub name: *const ::std::os::raw::c_char,
    pub code: *const ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__frozen() {
    const UNINIT: ::std::mem::MaybeUninit<_frozen> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_frozen>(),
        24usize,
        concat!("Size of: ", stringify!(_frozen))
    );
    assert_eq!(
        ::std::mem::align_of::<_frozen>(),
        8usize,
        concat!("Alignment of ", stringify!(_frozen))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_frozen),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_frozen),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_frozen),
            "::",
            stringify!(size)
        )
    );
}
impl Default for _frozen {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Embedding apps may change this pointer to point to their favorite\ncollection of frozen modules:"]
    pub static mut PyImport_FrozenModules: *const _frozen;
}
extern "C" {
    #[doc = " Call a callable Python object without any arguments"]
    pub fn PyObject_CallNoArgs(func: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call a callable Python object 'callable' with arguments given by the\ntuple 'args' and keywords arguments given by the dictionary 'kwargs'.\n\n'args' must not be NULL, use an empty tuple if no arguments are\nneeded. If no named arguments are needed, 'kwargs' can be NULL.\n\nThis is the equivalent of the Python expression:\ncallable(*args, **kwargs)."]
    pub fn PyObject_Call(
        callable: *mut PyObject,
        args: *mut PyObject,
        kwargs: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call a callable Python object 'callable', with arguments given by the\ntuple 'args'.  If no arguments are needed, then 'args' can be NULL.\n\nReturns the result of the call on success, or NULL on failure.\n\nThis is the equivalent of the Python expression:\ncallable(*args)."]
    pub fn PyObject_CallObject(callable: *mut PyObject, args: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call a callable Python object, callable, with a variable number of C\narguments. The C arguments are described using a mkvalue-style format\nstring.\n\nThe format may be NULL, indicating that no arguments are provided.\n\nReturns the result of the call on success, or NULL on failure.\n\nThis is the equivalent of the Python expression:\ncallable(arg1, arg2, ...)."]
    pub fn PyObject_CallFunction(
        callable: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call the method named 'name' of object 'obj' with a variable number of\nC arguments.  The C arguments are described by a mkvalue format string.\n\nThe format can be NULL, indicating that no arguments are provided.\n\nReturns the result of the call on success, or NULL on failure.\n\nThis is the equivalent of the Python expression:\nobj.name(arg1, arg2, ...)."]
    pub fn PyObject_CallMethod(
        obj: *mut PyObject,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_CallFunction_SizeT(
        callable: *mut PyObject,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_CallMethod_SizeT(
        obj: *mut PyObject,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call a callable Python object 'callable' with a variable number of C\narguments. The C arguments are provided as PyObject* values, terminated\nby a NULL.\n\nReturns the result of the call on success, or NULL on failure.\n\nThis is the equivalent of the Python expression:\ncallable(arg1, arg2, ...)."]
    pub fn PyObject_CallFunctionObjArgs(callable: *mut PyObject, ...) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call the method named 'name' of object 'obj' with a variable number of\nC arguments.  The C arguments are provided as PyObject* values, terminated\nby NULL.\n\nReturns the result of the call on success, or NULL on failure.\n\nThis is the equivalent of the Python expression: obj.name(*args)."]
    pub fn PyObject_CallMethodObjArgs(
        obj: *mut PyObject,
        name: *mut PyObject,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Get the type of an object.\n\nOn success, returns a type object corresponding to the object type of object\n'o'. On failure, returns NULL.\n\nThis is equivalent to the Python expression: type(o)"]
    pub fn PyObject_Type(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return the size of object 'o'.  If the object 'o' provides both sequence and\nmapping protocols, the sequence size is returned.\n\nOn error, -1 is returned.\n\nThis is the equivalent to the Python expression: len(o)"]
    pub fn PyObject_Size(o: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyObject_Length(o: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Return element of 'o' corresponding to the object 'key'. Return NULL\non failure.\n\nThis is the equivalent of the Python expression: o[key]"]
    pub fn PyObject_GetItem(o: *mut PyObject, key: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Map the object 'key' to the value 'v' into 'o'.\n\nRaise an exception and return -1 on failure; return 0 on success.\n\nThis is the equivalent of the Python statement: o[key]=v."]
    pub fn PyObject_SetItem(
        o: *mut PyObject,
        key: *mut PyObject,
        v: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the mapping for the string 'key' from the object 'o'.\nReturns -1 on failure.\n\nThis is equivalent to the Python statement: del o[key]."]
    pub fn PyObject_DelItemString(
        o: *mut PyObject,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete the mapping for the object 'key' from the object 'o'.\nReturns -1 on failure.\n\nThis is the equivalent of the Python statement: del o[key]."]
    pub fn PyObject_DelItem(o: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes an arbitrary object which must support the (character, single segment)\nbuffer interface and returns a pointer to a read-only memory location\nusable as character based input for subsequent processing.\n\nReturn 0 on success.  buffer and buffer_len are only set in case no error\noccurs. Otherwise, -1 is returned and an exception set."]
    pub fn PyObject_AsCharBuffer(
        obj: *mut PyObject,
        buffer: *mut *const ::std::os::raw::c_char,
        buffer_len: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether an arbitrary object supports the (character, single segment)\nbuffer interface.\n\nReturns 1 on success, 0 on failure."]
    pub fn PyObject_CheckReadBuffer(obj: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as PyObject_AsCharBuffer() except that this API expects (readable,\nsingle segment) buffer interface and returns a pointer to a read-only memory\nlocation which can contain arbitrary data.\n\n0 is returned on success.  buffer and buffer_len are only set in case no\nerror occurs.  Otherwise, -1 is returned and an exception set."]
    pub fn PyObject_AsReadBuffer(
        obj: *mut PyObject,
        buffer: *mut *const ::std::os::raw::c_void,
        buffer_len: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes an arbitrary object which must support the (writable, single segment)\nbuffer interface and returns a pointer to a writable memory location in\nbuffer of size 'buffer_len'.\n\nReturn 0 on success.  buffer and buffer_len are only set in case no error\noccurs. Otherwise, -1 is returned and an exception set."]
    pub fn PyObject_AsWriteBuffer(
        obj: *mut PyObject,
        buffer: *mut *mut ::std::os::raw::c_void,
        buffer_len: *mut Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes an arbitrary object and returns the result of calling\nobj.__format__(format_spec)."]
    pub fn PyObject_Format(obj: *mut PyObject, format_spec: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Takes an object and returns an iterator for it.\nThis is typically a new iterator but if the argument is an iterator, this\nreturns itself."]
    pub fn PyObject_GetIter(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns 1 if the object 'obj' provides iterator protocols, and 0 otherwise.\n\nThis function always succeeds."]
    pub fn PyIter_Check(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes an iterator object and calls its tp_iternext slot,\nreturning the next value.\n\nIf the iterator is exhausted, this returns NULL without setting an\nexception.\n\nNULL with an exception means an error occurred."]
    pub fn PyIter_Next(arg1: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.\n\nThis function always succeeds."]
    pub fn PyNumber_Check(o: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the result of adding o1 and o2, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 + o2."]
    pub fn PyNumber_Add(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of subtracting o2 from o1, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 - o2."]
    pub fn PyNumber_Subtract(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of multiplying o1 and o2, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 * o2."]
    pub fn PyNumber_Multiply(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " This is the equivalent of the Python expression: o1 @ o2."]
    pub fn PyNumber_MatrixMultiply(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of dividing o1 by o2 giving an integral result,\nor NULL on failure.\n\nThis is the equivalent of the Python expression: o1 // o2."]
    pub fn PyNumber_FloorDivide(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of dividing o1 by o2 giving a float result, or NULL on\nfailure.\n\nThis is the equivalent of the Python expression: o1 / o2."]
    pub fn PyNumber_TrueDivide(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the remainder of dividing o1 by o2, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 % o2."]
    pub fn PyNumber_Remainder(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " See the built-in function divmod.\n\nReturns NULL on failure.\n\nThis is the equivalent of the Python expression: divmod(o1, o2)."]
    pub fn PyNumber_Divmod(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " See the built-in function pow. Returns NULL on failure.\n\nThis is the equivalent of the Python expression: pow(o1, o2, o3),\nwhere o3 is optional."]
    pub fn PyNumber_Power(o1: *mut PyObject, o2: *mut PyObject, o3: *mut PyObject)
        -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the negation of o on success, or NULL on failure.\n\nThis is the equivalent of the Python expression: -o."]
    pub fn PyNumber_Negative(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the positive of o on success, or NULL on failure.\n\nThis is the equivalent of the Python expression: +o."]
    pub fn PyNumber_Positive(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the absolute value of 'o', or NULL on failure.\n\nThis is the equivalent of the Python expression: abs(o)."]
    pub fn PyNumber_Absolute(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the bitwise negation of 'o' on success, or NULL on failure.\n\nThis is the equivalent of the Python expression: ~o."]
    pub fn PyNumber_Invert(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of left shifting o1 by o2 on success, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 << o2."]
    pub fn PyNumber_Lshift(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of right shifting o1 by o2 on success, or NULL on\nfailure.\n\nThis is the equivalent of the Python expression: o1 >> o2."]
    pub fn PyNumber_Rshift(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of bitwise and of o1 and o2 on success, or NULL on\nfailure.\n\nThis is the equivalent of the Python expression: o1 & o2."]
    pub fn PyNumber_And(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 ^ o2."]
    pub fn PyNumber_Xor(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of bitwise or on o1 and o2 on success, or NULL on\nfailure.\n\nThis is the equivalent of the Python expression: o1 | o2."]
    pub fn PyNumber_Or(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns 1 if obj is an index integer (has the nb_index slot of the\ntp_as_number structure filled in), and 0 otherwise."]
    pub fn PyIndex_Check(arg1: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the object 'o' converted to a Python int, or NULL with an exception\nraised on failure."]
    pub fn PyNumber_Index(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the object 'o' converted to Py_ssize_t by going through\nPyNumber_Index() first.\n\nIf an overflow error occurs while converting the int to Py_ssize_t, then the\nsecond argument 'exc' is the error-type to return.  If it is NULL, then the\noverflow error is cleared and the value is clipped."]
    pub fn PyNumber_AsSsize_t(o: *mut PyObject, exc: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Returns the object 'o' converted to an integer object on success, or NULL\non failure.\n\nThis is the equivalent of the Python expression: int(o)."]
    pub fn PyNumber_Long(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the object 'o' converted to a float object on success, or NULL\non failure.\n\nThis is the equivalent of the Python expression: float(o)."]
    pub fn PyNumber_Float(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of adding o2 to o1, possibly in-place, or NULL\non failure.\n\nThis is the equivalent of the Python expression: o1 += o2."]
    pub fn PyNumber_InPlaceAdd(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of subtracting o2 from o1, possibly in-place or\nNULL on failure.\n\nThis is the equivalent of the Python expression: o1 -= o2."]
    pub fn PyNumber_InPlaceSubtract(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of multiplying o1 by o2, possibly in-place, or NULL on\nfailure.\n\nThis is the equivalent of the Python expression: o1 *= o2."]
    pub fn PyNumber_InPlaceMultiply(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " This is the equivalent of the Python expression: o1 @= o2."]
    pub fn PyNumber_InPlaceMatrixMultiply(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of dividing o1 by o2 giving an integral result, possibly\nin-place, or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 /= o2."]
    pub fn PyNumber_InPlaceFloorDivide(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of dividing o1 by o2 giving a float result, possibly\nin-place, or null on failure.\n\nThis is the equivalent of the Python expression: o1 /= o2."]
    pub fn PyNumber_InPlaceTrueDivide(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on\nfailure.\n\nThis is the equivalent of the Python expression: o1 %= o2."]
    pub fn PyNumber_InPlaceRemainder(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of raising o1 to the power of o2, possibly in-place,\nor NULL on failure.\n\nThis is the equivalent of the Python expression: o1 **= o2,\nor o1 = pow(o1, o2, o3) if o3 is present."]
    pub fn PyNumber_InPlacePower(
        o1: *mut PyObject,
        o2: *mut PyObject,
        o3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of left shifting o1 by o2, possibly in-place, or NULL\non failure.\n\nThis is the equivalent of the Python expression: o1 <<= o2."]
    pub fn PyNumber_InPlaceLshift(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of right shifting o1 by o2, possibly in-place or NULL\non failure.\n\nThis is the equivalent of the Python expression: o1 >>= o2."]
    pub fn PyNumber_InPlaceRshift(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL\non failure.\n\nThis is the equivalent of the Python expression: o1 &= o2."]
    pub fn PyNumber_InPlaceAnd(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL\non failure.\n\nThis is the equivalent of the Python expression: o1 ^= o2."]
    pub fn PyNumber_InPlaceXor(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the result of bitwise or of o1 and o2, possibly in-place,\nor NULL on failure.\n\nThis is the equivalent of the Python expression: o1 |= o2."]
    pub fn PyNumber_InPlaceOr(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the integer n converted to a string with a base, with a base\nmarker of 0b, 0o or 0x prefixed if applicable.\n\nIf n is not an int object, it is converted with PyNumber_Index first."]
    pub fn PyNumber_ToBase(n: *mut PyObject, base: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return 1 if the object provides sequence protocol, and zero\notherwise.\n\nThis function always succeeds."]
    pub fn PySequence_Check(o: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the size of sequence object o, or -1 on failure."]
    pub fn PySequence_Size(o: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PySequence_Length(o: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Return the concatenation of o1 and o2 on success, and NULL on failure.\n\nThis is the equivalent of the Python expression: o1 + o2."]
    pub fn PySequence_Concat(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return the result of repeating sequence object 'o' 'count' times,\nor NULL on failure.\n\nThis is the equivalent of the Python expression: o * count."]
    pub fn PySequence_Repeat(o: *mut PyObject, count: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return the ith element of o, or NULL on failure.\n\nThis is the equivalent of the Python expression: o[i]."]
    pub fn PySequence_GetItem(o: *mut PyObject, i: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return the slice of sequence object o between i1 and i2, or NULL on failure.\n\nThis is the equivalent of the Python expression: o[i1:i2]."]
    pub fn PySequence_GetSlice(o: *mut PyObject, i1: Py_ssize_t, i2: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Assign object 'v' to the ith element of the sequence 'o'. Raise an exception\nand return -1 on failure; return 0 on success.\n\nThis is the equivalent of the Python statement o[i] = v."]
    pub fn PySequence_SetItem(
        o: *mut PyObject,
        i: Py_ssize_t,
        v: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.\n\nThis is the equivalent of the Python statement: del o[i]."]
    pub fn PySequence_DelItem(o: *mut PyObject, i: Py_ssize_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Assign the sequence object 'v' to the slice in sequence object 'o',\nfrom 'i1' to 'i2'. Returns -1 on failure.\n\nThis is the equivalent of the Python statement: o[i1:i2] = v."]
    pub fn PySequence_SetSlice(
        o: *mut PyObject,
        i1: Py_ssize_t,
        i2: Py_ssize_t,
        v: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete the slice in sequence object 'o' from 'i1' to 'i2'.\nReturns -1 on failure.\n\nThis is the equivalent of the Python statement: del o[i1:i2]."]
    pub fn PySequence_DelSlice(
        o: *mut PyObject,
        i1: Py_ssize_t,
        i2: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the sequence 'o' as a tuple on success, and NULL on failure.\n\nThis is equivalent to the Python expression: tuple(o)."]
    pub fn PySequence_Tuple(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Returns the sequence 'o' as a list on success, and NULL on failure.\nThis is equivalent to the Python expression: list(o)"]
    pub fn PySequence_List(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return the sequence 'o' as a list, unless it's already a tuple or list.\n\nUse PySequence_Fast_GET_ITEM to access the members of this list, and\nPySequence_Fast_GET_SIZE to get its length.\n\nReturns NULL on failure.  If the object does not support iteration, raises a\nTypeError exception with 'm' as the message text."]
    pub fn PySequence_Fast(o: *mut PyObject, m: *const ::std::os::raw::c_char) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return the number of occurrences on value on 'o', that is, return\nthe number of keys for which o[key] == value.\n\nOn failure, return -1.  This is equivalent to the Python expression:\no.count(value)."]
    pub fn PySequence_Count(o: *mut PyObject, value: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence\n'seq'; -1 on error.\n\nUse __contains__ if possible, else _PySequence_IterSearch()."]
    pub fn PySequence_Contains(seq: *mut PyObject, ob: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal\nto 'value', return 1, otherwise return 0. On error, return -1.\n\nThis is equivalent to the Python expression: value in o."]
    pub fn PySequence_In(o: *mut PyObject, value: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the first index for which o[i] == value.\nOn error, return -1.\n\nThis is equivalent to the Python expression: o.index(value)."]
    pub fn PySequence_Index(o: *mut PyObject, value: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Append sequence 'o2' to sequence 'o1', in-place when possible. Return the\nresulting object, which could be 'o1', or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 += o2."]
    pub fn PySequence_InPlaceConcat(o1: *mut PyObject, o2: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Repeat sequence 'o' by 'count', in-place when possible. Return the resulting\nobject, which could be 'o', or NULL on failure.\n\nThis is the equivalent of the Python expression: o1 *= count."]
    pub fn PySequence_InPlaceRepeat(o: *mut PyObject, count: Py_ssize_t) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return 1 if the object provides mapping protocol, and 0 otherwise.\n\nThis function always succeeds."]
    pub fn PyMapping_Check(o: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of keys in mapping object 'o' on success, and -1 on\nfailure. This is equivalent to the Python expression: len(o)."]
    pub fn PyMapping_Size(o: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    pub fn PyMapping_Length(o: *mut PyObject) -> Py_ssize_t;
}
extern "C" {
    #[doc = " On success, return 1 if the mapping object 'o' has the key 'key',\nand 0 otherwise.\n\nThis is equivalent to the Python expression: key in o.\n\nThis function always succeeds."]
    pub fn PyMapping_HasKeyString(
        o: *mut PyObject,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return 1 if the mapping object has the key 'key', and 0 otherwise.\n\nThis is equivalent to the Python expression: key in o.\n\nThis function always succeeds."]
    pub fn PyMapping_HasKey(o: *mut PyObject, key: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " On success, return a list or tuple of the keys in mapping object 'o'.\nOn failure, return NULL."]
    pub fn PyMapping_Keys(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " On success, return a list or tuple of the values in mapping object 'o'.\nOn failure, return NULL."]
    pub fn PyMapping_Values(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " On success, return a list or tuple of the items in mapping object 'o',\nwhere each item is a tuple containing a key-value pair. On failure, return\nNULL."]
    pub fn PyMapping_Items(o: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    #[doc = " Return element of 'o' corresponding to the string 'key' or NULL on failure.\n\nThis is the equivalent of the Python expression: o[key]."]
    pub fn PyMapping_GetItemString(
        o: *mut PyObject,
        key: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Map the string 'key' to the value 'v' in the mapping 'o'.\nReturns -1 on failure.\n\nThis is the equivalent of the Python statement: o[key]=v."]
    pub fn PyMapping_SetItemString(
        o: *mut PyObject,
        key: *const ::std::os::raw::c_char,
        value: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " isinstance(object, typeorclass)"]
    pub fn PyObject_IsInstance(
        object: *mut PyObject,
        typeorclass: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " issubclass(object, typeorclass)"]
    pub fn PyObject_IsSubclass(
        object: *mut PyObject,
        typeorclass: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert keyword arguments from the FASTCALL (stack: C array, kwnames: tuple)\nformat to a Python dictionary (\"kwargs\" dict).\n\nThe type of kwnames keys is not checked. The final function getting\narguments is responsible to check if all keys are strings, for example using\nPyArg_ParseTupleAndKeywords() or PyArg_ValidateKeywordArguments().\n\nDuplicate keys are merged using the last value. If duplicate keys must raise\nan exception, the caller is responsible to implement an explicit keys on\nkwnames."]
    pub fn _PyStack_AsDict(values: *const *mut PyObject, kwnames: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub fn _Py_CheckFunctionResult(
        tstate: *mut PyThreadState,
        callable: *mut PyObject,
        result: *mut PyObject,
        where_: *const ::std::os::raw::c_char,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call callable using tp_call. Arguments are like PyObject_Vectorcall()\nor PyObject_FastCallDict() (both forms are supported),\nexcept that nargs is plainly the number of arguments without flags."]
    pub fn _PyObject_MakeTpCall(
        tstate: *mut PyThreadState,
        callable: *mut PyObject,
        args: *const *mut PyObject,
        nargs: Py_ssize_t,
        keywords: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Same as PyObject_Vectorcall except that keyword arguments are passed as\ndict, which may be NULL if there are no keyword arguments."]
    pub fn PyObject_VectorcallDict(
        callable: *mut PyObject,
        args: *const *mut PyObject,
        nargsf: usize,
        kwargs: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Call \"callable\" (which must support vectorcall) with positional arguments\n\"tuple\" and keyword arguments \"dict\". \"dict\" may also be NULL"]
    pub fn PyVectorcall_Call(
        callable: *mut PyObject,
        tuple: *mut PyObject,
        dict: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyObject_VectorcallMethod(
        name: *mut PyObject,
        args: *const *mut PyObject,
        nargsf: usize,
        kwnames: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    #[doc = " Like PyObject_CallMethod(), but expect a _Py_Identifier*\nas the method name."]
    pub fn _PyObject_CallMethodId(
        obj: *mut PyObject,
        name: *mut _Py_Identifier,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_CallMethodId_SizeT(
        obj: *mut PyObject,
        name: *mut _Py_Identifier,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_CallMethodIdObjArgs(
        obj: *mut PyObject,
        name: *mut _Py_Identifier,
        ...
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyObject_HasLen(o: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Guess the size of object 'o' using len(o) or o.__length_hint__().\nIf neither of those return a non-negative value, then return the default\nvalue.  If one of the calls fails, this function returns -1."]
    pub fn PyObject_LengthHint(o: *mut PyObject, arg1: Py_ssize_t) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Return 1 if the getbuffer function is available, otherwise return 0."]
    pub fn PyObject_CheckBuffer(obj: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This is a C-API version of the getbuffer function call.  It checks\nto make sure object has the required function pointer and issues the\ncall.\n\nReturns -1 and raises an error on failure and returns 0 on success."]
    pub fn PyObject_GetBuffer(
        obj: *mut PyObject,
        view: *mut Py_buffer,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the memory area pointed to by the indices for the buffer given.\nNote that view->ndim is the assumed size of indices."]
    pub fn PyBuffer_GetPointer(
        view: *mut Py_buffer,
        indices: *mut Py_ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Return the implied itemsize of the data-format area from a\nstruct-style description."]
    pub fn PyBuffer_SizeFromFormat(format: *const ::std::os::raw::c_char) -> Py_ssize_t;
}
extern "C" {
    #[doc = " Implementation in memoryobject.c"]
    pub fn PyBuffer_ToContiguous(
        buf: *mut ::std::os::raw::c_void,
        view: *mut Py_buffer,
        len: Py_ssize_t,
        order: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyBuffer_FromContiguous(
        view: *mut Py_buffer,
        buf: *mut ::std::os::raw::c_void,
        len: Py_ssize_t,
        order: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy len bytes of data from the contiguous chunk of memory\npointed to by buf into the buffer exported by obj.  Return\n0 on success and return -1 and raise a PyBuffer_Error on\nerror (i.e. the object does not have a buffer interface or\nit is not working).\n\nIf fort is 'F', then if the object is multi-dimensional,\nthen the data will be copied into the array in\nFortran-style (first dimension varies the fastest).  If\nfort is 'C', then the data will be copied into the array\nin C-style (last dimension varies the fastest).  If fort\nis 'A', then it does not matter and the copy will be made\nin whatever way is more efficient."]
    pub fn PyObject_CopyData(dest: *mut PyObject, src: *mut PyObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the data from the src buffer to the buffer of destination."]
    pub fn PyBuffer_IsContiguous(
        view: *const Py_buffer,
        fort: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Fill the strides array with byte-strides of a contiguous\n(Fortran-style if fort is 'F' or C-style otherwise)\narray of the given shape with the given number of bytes\nper element."]
    pub fn PyBuffer_FillContiguousStrides(
        ndims: ::std::os::raw::c_int,
        shape: *mut Py_ssize_t,
        strides: *mut Py_ssize_t,
        itemsize: ::std::os::raw::c_int,
        fort: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Fills in a buffer-info structure correctly for an exporter\nthat can only share a contiguous chunk of memory of\n\"unsigned bytes\" of the given length.\n\nReturns 0 on success and -1 (with raising an error) on error."]
    pub fn PyBuffer_FillInfo(
        view: *mut Py_buffer,
        o: *mut PyObject,
        buf: *mut ::std::os::raw::c_void,
        len: Py_ssize_t,
        readonly: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Releases a Py_buffer obtained from getbuffer ParseTuple's \"s*\"."]
    pub fn PyBuffer_Release(view: *mut Py_buffer);
}
extern "C" {
    #[doc = " Iterate over seq.\n\nResult depends on the operation:\n\nPY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if\nerror.\nPY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of\nobj in seq; set ValueError and return -1 if none found;\nalso return -1 on error.\nPY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on\nerror."]
    pub fn _PySequence_IterSearch(
        seq: *mut PyObject,
        obj: *mut PyObject,
        operation: ::std::os::raw::c_int,
    ) -> Py_ssize_t;
}
extern "C" {
    #[doc = " === Mapping protocol ================================================="]
    pub fn _PyObject_RealIsInstance(
        inst: *mut PyObject,
        cls: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PyObject_RealIsSubclass(
        derived: *mut PyObject,
        cls: *mut PyObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _PySequence_BytesToCharpArray(
        self_: *mut PyObject,
    ) -> *const *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _Py_FreeCharPArray(array: *const *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " For internal use by buffer API functions"]
    pub fn _Py_add_one_to_index_F(
        nd: ::std::os::raw::c_int,
        index: *mut Py_ssize_t,
        shape: *const Py_ssize_t,
    );
}
extern "C" {
    pub fn _Py_add_one_to_index_C(
        nd: ::std::os::raw::c_int,
        index: *mut Py_ssize_t,
        shape: *const Py_ssize_t,
    );
}
extern "C" {
    #[doc = " Convert Python int to Py_ssize_t. Do nothing if the argument is None."]
    pub fn _Py_convert_optional_to_ssize_t(
        arg1: *mut PyObject,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PyFilter_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyMap_Type: PyTypeObject;
}
extern "C" {
    pub static mut PyZip_Type: PyTypeObject;
}
extern "C" {
    pub fn PyEval_EvalCode(
        arg1: *mut PyObject,
        arg2: *mut PyObject,
        arg3: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn PyEval_EvalCodeEx(
        co: *mut PyObject,
        globals: *mut PyObject,
        locals: *mut PyObject,
        args: *const *mut PyObject,
        argc: ::std::os::raw::c_int,
        kwds: *const *mut PyObject,
        kwdc: ::std::os::raw::c_int,
        defs: *const *mut PyObject,
        defc: ::std::os::raw::c_int,
        kwdefs: *mut PyObject,
        closure: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyEval_EvalCodeWithName(
        co: *mut PyObject,
        globals: *mut PyObject,
        locals: *mut PyObject,
        args: *const *mut PyObject,
        argcount: Py_ssize_t,
        kwnames: *const *mut PyObject,
        kwargs: *const *mut PyObject,
        kwcount: Py_ssize_t,
        kwstep: ::std::os::raw::c_int,
        defs: *const *mut PyObject,
        defcount: Py_ssize_t,
        kwdefs: *mut PyObject,
        closure: *mut PyObject,
        name: *mut PyObject,
        qualname: *mut PyObject,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _PyEval_CallTracing(func: *mut PyObject, args: *mut PyObject) -> *mut PyObject;
}
extern "C" {
    pub static _Py_ctype_table: [::std::os::raw::c_uint; 256usize];
}
extern "C" {
    pub static _Py_ctype_tolower: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    pub static _Py_ctype_toupper: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    pub fn PyOS_string_to_double(
        str_: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        overflow_exception: *mut PyObject,
    ) -> f64;
}
extern "C" {
    #[doc = " The caller is responsible for calling PyMem_Free to free the buffer\nthat's is returned."]
    pub fn PyOS_double_to_string(
        val: f64,
        format_code: ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _Py_string_to_number_with_underscores(
        str_: *const ::std::os::raw::c_char,
        len: Py_ssize_t,
        what: *const ::std::os::raw::c_char,
        obj: *mut PyObject,
        arg: *mut ::std::os::raw::c_void,
        innerfunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: Py_ssize_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> *mut PyObject,
        >,
    ) -> *mut PyObject;
}
extern "C" {
    pub fn _Py_parse_inf_or_nan(
        p: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn PyOS_mystrnicmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: Py_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PyOS_mystricmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Py_DecodeLocale(arg: *const ::std::os::raw::c_char, size: *mut usize) -> *mut wchar_t;
}
extern "C" {
    pub fn Py_EncodeLocale(
        text: *const wchar_t,
        error_pos: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _Py_EncodeLocaleRaw(
        text: *const wchar_t,
        error_pos: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
pub const _Py_error_handler__Py_ERROR_UNKNOWN: _Py_error_handler = 0;
pub const _Py_error_handler__Py_ERROR_STRICT: _Py_error_handler = 1;
pub const _Py_error_handler__Py_ERROR_SURROGATEESCAPE: _Py_error_handler = 2;
pub const _Py_error_handler__Py_ERROR_REPLACE: _Py_error_handler = 3;
pub const _Py_error_handler__Py_ERROR_IGNORE: _Py_error_handler = 4;
pub const _Py_error_handler__Py_ERROR_BACKSLASHREPLACE: _Py_error_handler = 5;
pub const _Py_error_handler__Py_ERROR_SURROGATEPASS: _Py_error_handler = 6;
pub const _Py_error_handler__Py_ERROR_XMLCHARREFREPLACE: _Py_error_handler = 7;
pub const _Py_error_handler__Py_ERROR_OTHER: _Py_error_handler = 8;
pub type _Py_error_handler = ::std::os::raw::c_uint;
extern "C" {
    pub fn _Py_GetErrorHandler(errors: *const ::std::os::raw::c_char) -> _Py_error_handler;
}
extern "C" {
    pub fn _Py_DecodeLocaleEx(
        arg: *const ::std::os::raw::c_char,
        wstr: *mut *mut wchar_t,
        wlen: *mut usize,
        reason: *mut *const ::std::os::raw::c_char,
        current_locale: ::std::os::raw::c_int,
        errors: _Py_error_handler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_EncodeLocaleEx(
        text: *const wchar_t,
        str_: *mut *mut ::std::os::raw::c_char,
        error_pos: *mut usize,
        reason: *mut *const ::std::os::raw::c_char,
        current_locale: ::std::os::raw::c_int,
        errors: _Py_error_handler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_device_encoding(arg1: ::std::os::raw::c_int) -> *mut PyObject;
}
extern "C" {
    pub fn _Py_fstat(fd: ::std::os::raw::c_int, status: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_fstat_noraise(fd: ::std::os::raw::c_int, status: *mut stat)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_stat(path: *mut PyObject, status: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_open_noraise(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_wfopen(path: *const wchar_t, mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _Py_fopen(
        pathname: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _Py_fopen_obj(path: *mut PyObject, mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _Py_read(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> Py_ssize_t;
}
extern "C" {
    pub fn _Py_write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: usize,
    ) -> Py_ssize_t;
}
extern "C" {
    pub fn _Py_write_noraise(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: usize,
    ) -> Py_ssize_t;
}
extern "C" {
    pub fn _Py_wreadlink(
        path: *const wchar_t,
        buf: *mut wchar_t,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_wrealpath(
        path: *const wchar_t,
        resolved_path: *mut wchar_t,
        resolved_path_len: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _Py_isabs(path: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_abspath(path: *const wchar_t, abspath_p: *mut *mut wchar_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_wgetcwd(buf: *mut wchar_t, buflen: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _Py_get_inheritable(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_set_inheritable(
        fd: ::std::os::raw::c_int,
        inheritable: ::std::os::raw::c_int,
        atomic_flag_works: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_set_inheritable_async_safe(
        fd: ::std::os::raw::c_int,
        inheritable: ::std::os::raw::c_int,
        atomic_flag_works: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_dup(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_get_blocking(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Py_set_blocking(
        fd: ::std::os::raw::c_int,
        blocking: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Track an allocated memory block in the tracemalloc module.\nReturn 0 on success, return -1 on error (failed to allocate memory to store\nthe trace).\n\nReturn -2 if tracemalloc is disabled.\n\nIf memory block is already tracked, update the existing trace."]
    pub fn PyTraceMalloc_Track(
        domain: ::std::os::raw::c_uint,
        ptr: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Untrack an allocated memory block in the tracemalloc module.\nDo nothing if the block was not tracked.\n\nReturn -2 if tracemalloc is disabled, otherwise return 0."]
    pub fn PyTraceMalloc_Untrack(
        domain: ::std::os::raw::c_uint,
        ptr: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the traceback where a memory block was allocated.\n\nReturn a tuple of (filename: str, lineno: int) tuples.\n\nReturn None if the tracemalloc module is disabled or if the memory block\nis not tracked by tracemalloc.\n\nRaise an exception and return NULL on error."]
    pub fn _PyTraceMalloc_GetTraceback(domain: ::std::os::raw::c_uint, ptr: usize)
        -> *mut PyObject;
}
pub type socket_t = ::std::os::raw::c_int;
pub type int8 = ::std::os::raw::c_schar;
pub type uint8 = ::std::os::raw::c_uchar;
pub type int16 = ::std::os::raw::c_short;
pub type uint16 = ::std::os::raw::c_ushort;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type uint64 = ::std::os::raw::c_ulonglong;
pub type int64 = ::std::os::raw::c_longlong;
extern "C" {
    #[doc = " If init_local is defined, always declare it exported.\nFIXME: This doesn't really belong here - but where? It must be in a file\nthat is included everywhere init_local is defined."]
    pub fn init_local();
}
#[doc = " <add-type id=\"tuple_int_string_t def\">\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tuple_int_string_t {
    pub integer: ::std::os::raw::c_int,
    pub string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tuple_int_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<tuple_int_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tuple_int_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(tuple_int_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tuple_int_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tuple_int_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tuple_int_string_t),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tuple_int_string_t),
            "::",
            stringify!(string)
        )
    );
}
impl Default for tuple_int_string_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " obsolete type; please use either buffer_t or bytes_t instead"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct byte_string_t {
    pub len: usize,
    pub str_: *mut uint8,
}
#[test]
fn bindgen_test_layout_byte_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<byte_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<byte_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(byte_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<byte_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(byte_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(byte_string_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(byte_string_t),
            "::",
            stringify!(str_)
        )
    );
}
impl Default for byte_string_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"buffer_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct buffer_t {
    pub data: *mut uint8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_buffer_t() {
    const UNINIT: ::std::mem::MaybeUninit<buffer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<buffer_t>(),
        16usize,
        concat!("Size of: ", stringify!(buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(buffer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_t),
            "::",
            stringify!(len)
        )
    );
}
impl Default for buffer_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"bytes_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bytes_t {
    pub data: *const uint8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_bytes_t() {
    const UNINIT: ::std::mem::MaybeUninit<bytes_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bytes_t>(),
        16usize,
        concat!("Size of: ", stringify!(bytes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bytes_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bytes_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bytes_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bytes_t),
            "::",
            stringify!(len)
        )
    );
}
impl Default for bytes_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct atomic_counter_t {
    pub c: uint32,
}
#[test]
fn bindgen_test_layout_atomic_counter_t() {
    const UNINIT: ::std::mem::MaybeUninit<atomic_counter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<atomic_counter_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_counter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_counter_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_counter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_counter_t),
            "::",
            stringify!(c)
        )
    );
}
#[doc = " <add-type id=\"logical_address_t\">\n</add-type>"]
pub type logical_address_t = uint64;
#[doc = " <add-type id=\"physical_address_t\">\n</add-type>"]
pub type physical_address_t = uint64;
#[doc = " <add-type id=\"generic_address_t\">\n</add-type>"]
pub type generic_address_t = uint64;
#[doc = " <add-type id=\"linear_address_t\">\n</add-type>"]
pub type linear_address_t = uint64;
#[doc = " <add-type id=\"lang_void def\"></add-type>"]
pub type lang_void = ::std::os::raw::c_void;
#[doc = " <add-type id=\"conf conf_object_t\"></add-type>"]
pub type conf_object_t = conf_object;
extern "C" {
    pub fn SIM_flush_all_caches();
}
extern "C" {
    pub fn SIM_flush_cell_caches(obj: *mut conf_object_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profile_area {
    _unused: [u8; 0],
}
pub type profile_area_t = profile_area;
extern "C" {
    pub fn SIM_add_profiling_area(
        name: *const ::std::os::raw::c_char,
        start: usize,
        end: usize,
    ) -> *mut profile_area_t;
}
extern "C" {
    pub fn SIM_remove_profiling_area(handle: *mut profile_area_t);
}
extern "C" {
    pub fn pr_err(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn pr_err_vararg(str_: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
extern "C" {
    pub fn SIM_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_version_base() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_version_major() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_vmxmon_version() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_copyright() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_register_copyright(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_license();
}
extern "C" {
    pub fn SIM_license_file(format: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_deprecate(
        depr_build_id: ::std::os::raw::c_int,
        warn_msg: *const ::std::os::raw::c_char,
        ref_msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn OLD_copyright();
}
#[doc = " <add-type id=\"api_function_t def\"></add-type>"]
pub type api_function_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn SIM_get_api_function(function: *const ::std::os::raw::c_char) -> api_function_t;
}
#[doc = " Please do not access the members of this struct directly;\nuse the accessor functions defined in this file.\nInvariants:\n- .s[.len] == '\\0'\n- If .size == 0, then .len == 0 and .s points to a static null byte\n- If .size > 0, then 0 <= .len < .size\nand .s points to an allocation of .size bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct strbuf_t {
    #[doc = " string, always 0-terminated"]
    pub s: *mut ::std::os::raw::c_char,
    #[doc = " size of allocated buffer"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " current length"]
    pub len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_strbuf_t() {
    const UNINIT: ::std::mem::MaybeUninit<strbuf_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<strbuf_t>(),
        16usize,
        concat!("Size of: ", stringify!(strbuf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<strbuf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(strbuf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strbuf_t),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strbuf_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(strbuf_t),
            "::",
            stringify!(len)
        )
    );
}
impl Default for strbuf_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn sb_new(s: *const ::std::os::raw::c_char) -> strbuf_t;
}
extern "C" {
    pub fn sb_newf(format: *const ::std::os::raw::c_char, ...) -> strbuf_t;
}
extern "C" {
    pub fn sb_free(sb: *mut strbuf_t);
}
extern "C" {
    pub fn sb_detach(sb: *mut strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sb_realloc(sb: *mut strbuf_t, minlen: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn sb_write(sb: *const strbuf_t, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sb_readline(sb: *mut strbuf_t, f: *mut FILE) -> bool;
}
extern "C" {
    pub fn sb_vaddfmt(
        sb: *mut strbuf_t,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn sb_addfmt(sb: *mut strbuf_t, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sb_vfmt(
        sb: *mut strbuf_t,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn sb_fmt(sb: *mut strbuf_t, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sb_addesc(sb: *mut strbuf_t, c: ::std::os::raw::c_char, delim: ::std::os::raw::c_char);
}
extern "C" {
    pub fn assert_error(
        line: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        mod_date: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn null_arg_error(
        func: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn fatal_error(fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    pub fn mm_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mm_malloc(
        size: usize,
        typesize: usize,
        type_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mm_malloc_low(
        size: usize,
        typesize: usize,
        type_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mm_zalloc(
        size: usize,
        typesize: usize,
        type_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mm_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        typesize: usize,
        type_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mm_strdup(
        str_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn init_vtmem();
}
#[doc = " <add id=\"attr_value_t DOC\">\n<name>attr_value_t</name>\n<ndx>attr_value_t</ndx>\n<doc>\n<doc-item name=\"NAME\">attr_value_t</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThe <type>attr_value_t</type> is the type used for all values in the\nconfiguration system. It is a tagged union.\n\nThe following table shows the different types of values, the type of their\npayload in C, and the corresponding Python types:\n\n<center>\n<table border=\"true\" long=\"false\">\n<tr>\n<td><b>Kind</b></td> <td><b>C payload</b></td> <td><b>Python type</b></td>\n</tr>\n<tr><td>Invalid</td> <td>-</td> <td>raises exception</td></tr>\n<tr><td>String</td><td>const char *</td> <td>str or unicode</td></tr>\n<tr><td>Integer</td> <td>int64 or uint64</td> <td>int or long</td></tr>\n<tr><td>Boolean</td> <td>bool</td> <td>bool</td></tr>\n<tr><td>Floating</td><td>double</td> <td>float</td></tr>\n<tr><td>Object</td>\n<td>conf_object_t *</td> <td>simics.conf_object_t</td></tr>\n<tr><td>List</td>\n<td>array of attr_value_t</td> <td>list</td></tr>\n<tr><td>Dict</td>\n<td>array of pairs of attr_value_t</td> <td>dict</td></tr>\n<tr><td>Data</td>\n<td>array of bytes</td> <td>tuple of small integers</td></tr>\n<tr><td>Nil</td>     <td>-</td>           <td>None</td></tr>\n</table>\n</center>\n\nThe members inside <type>attr_value_t</type> should not be accessed\ndirectly. Instead, use the corresponding functions for each type:\n\n<table>\n<tr>\n<td>Constructor</td> <td><fun>SIM_make_attr_<var>TYPE</var></fun></td>\n</tr>\n<tr><td>Destructor</td><td><fun>SIM_attr_free</fun></td></tr>\n<tr>\n<td>Type predicate</td> <td><fun>SIM_attr_is_<var>TYPE</var></fun></td>\n</tr>\n<tr><td>Access</td><td><fun>SIM_attr_<var>TYPE</var></fun></td></tr>\n</table>\n\nValues of type List and Dict can be modified using\n<fun>SIM_attr_<var>TYPE</var>_set_item</fun> and\n<fun>SIM_attr_<var>TYPE</var>_resize</fun>.\n\nNone of these functions are available or needed in Python. The\n<type>attr_value_t</type> values are translated to the ordinary Python\nvalues as shown in the table above.\n\nSome values may have data in separate heap allocations. These are normally\nmanaged by the respective constructor and destructor methods, but careless\ncopying of values may introduce aliasing errors. Use\n<fun>SIM_attr_copy</fun> to duplicate values. Again, this is of no concern\nin Python.\n\n</doc-item>\n<doc-item name=\"SEE ALSO\">\n<fun>SIM_make_attr_int64</fun>, <fun>SIM_attr_is_integer</fun>,\n<fun>SIM_attr_integer</fun>, <fun>SIM_attr_free</fun>,\n<fun>SIM_attr_list_resize</fun>, <fun>SIM_attr_list_set_item</fun>,\n<fun>SIM_attr_dict_resize</fun>, <fun>SIM_attr_dict_set_item</fun>,\n<fun>SIM_attr_copy</fun>\n</doc-item>\n</doc>\n</add>"]
pub type attr_value_t = attr_value;
pub const attr_kind_t_Sim_Val_Invalid: attr_kind_t = 0;
pub const attr_kind_t_Sim_Val_String: attr_kind_t = 1;
pub const attr_kind_t_Sim_Val_Integer: attr_kind_t = 2;
pub const attr_kind_t_Sim_Val_Floating: attr_kind_t = 3;
pub const attr_kind_t_Sim_Val_List: attr_kind_t = 4;
pub const attr_kind_t_Sim_Val_Data: attr_kind_t = 5;
pub const attr_kind_t_Sim_Val_Nil: attr_kind_t = 6;
pub const attr_kind_t_Sim_Val_Object: attr_kind_t = 7;
pub const attr_kind_t_Sim_Val_Dict: attr_kind_t = 8;
pub const attr_kind_t_Sim_Val_Boolean: attr_kind_t = 9;
#[doc = " Internal use only"]
pub const attr_kind_t_Sim_Val_Py_Object: attr_kind_t = 10;
#[doc = " Internal use only"]
pub const attr_kind_t_Sim_Val_Unresolved_Object: attr_kind_t = 11;
pub type attr_kind_t = ::std::os::raw::c_uint;
pub type attr_dict_pair_t = attr_dict_pair;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attr_value {
    pub private_kind: attr_kind_t,
    #[doc = " For List, Dict and Data: the number of items.\nFor Integer: 0 for unsigned, 1 for signed."]
    pub private_size: ::std::os::raw::c_uint,
    pub private_u: attr_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union attr_value__bindgen_ty_1 {
    #[doc = " Sim_Val_String"]
    pub string: *mut ::std::os::raw::c_char,
    #[doc = " Sim_Val_Integer"]
    pub integer: int64,
    #[doc = " Sim_Val_Boolean"]
    pub boolean: bool,
    #[doc = " Sim_Val_Floating"]
    pub floating: f64,
    #[doc = " [size]"]
    pub list: *mut attr_value,
    #[doc = " [size]"]
    pub dict: *mut attr_dict_pair,
    #[doc = " [size]"]
    pub data: *mut uint8,
    #[doc = " Sim_Val_Object"]
    pub object: *mut conf_object,
    #[doc = " A Python object, currently only pre_conf_object"]
    pub py_object: *mut _object,
    #[doc = " Sim_Val_Unresolved_Object (internal use only)"]
    pub uobject: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_attr_value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<attr_value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attr_value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(attr_value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<attr_value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(attr_value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).floating) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(floating)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).py_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(py_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uobject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value__bindgen_ty_1),
            "::",
            stringify!(uobject)
        )
    );
}
impl Default for attr_value__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_attr_value() {
    const UNINIT: ::std::mem::MaybeUninit<attr_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attr_value>(),
        16usize,
        concat!("Size of: ", stringify!(attr_value))
    );
    assert_eq!(
        ::std::mem::align_of::<attr_value>(),
        8usize,
        concat!("Alignment of ", stringify!(attr_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value),
            "::",
            stringify!(private_kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value),
            "::",
            stringify!(private_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_value),
            "::",
            stringify!(private_u)
        )
    );
}
impl Default for attr_value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attr_dict_pair {
    pub key: attr_value,
    pub value: attr_value,
}
#[test]
fn bindgen_test_layout_attr_dict_pair() {
    const UNINIT: ::std::mem::MaybeUninit<attr_dict_pair> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attr_dict_pair>(),
        32usize,
        concat!("Size of: ", stringify!(attr_dict_pair))
    );
    assert_eq!(
        ::std::mem::align_of::<attr_dict_pair>(),
        8usize,
        concat!("Alignment of ", stringify!(attr_dict_pair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_dict_pair),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attr_dict_pair),
            "::",
            stringify!(value)
        )
    );
}
impl Default for attr_dict_pair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " attr_value_t accessors and constructors"]
    pub fn VT_bad_attr_type(
        function: *const ::std::os::raw::c_char,
        wanted: attr_kind_t,
        actual: attr_value_t,
    ) -> !;
}
extern "C" {
    pub fn VT_report_bad_attr_type(
        function: *const ::std::os::raw::c_char,
        wanted: attr_kind_t,
        actual: attr_value_t,
    );
}
extern "C" {
    pub fn SIM_make_attr_list_vararg(
        length: ::std::os::raw::c_uint,
        va: *mut __va_list_tag,
    ) -> attr_value_t;
}
extern "C" {
    pub fn SIM_make_attr_list(length: ::std::os::raw::c_uint, ...) -> attr_value_t;
}
extern "C" {
    pub fn SIM_alloc_attr_list(length: ::std::os::raw::c_uint) -> attr_value_t;
}
extern "C" {
    pub fn SIM_make_attr_string(str_: *const ::std::os::raw::c_char) -> attr_value_t;
}
extern "C" {
    pub fn SIM_make_attr_data(size: usize, data: *const ::std::os::raw::c_void) -> attr_value_t;
}
extern "C" {
    pub fn SIM_alloc_attr_dict(length: ::std::os::raw::c_uint) -> attr_value_t;
}
extern "C" {
    pub fn SIM_attr_list_set_item(
        attr: *mut attr_value_t,
        index: ::std::os::raw::c_uint,
        elem: attr_value_t,
    );
}
extern "C" {
    pub fn SIM_attr_list_resize(attr: *mut attr_value_t, newsize: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SIM_attr_dict_set_item(
        attr: *mut attr_value_t,
        index: ::std::os::raw::c_uint,
        key: attr_value_t,
        value: attr_value_t,
    );
}
extern "C" {
    pub fn SIM_attr_dict_resize(attr: *mut attr_value_t, newsize: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SIM_attr_copy(val: attr_value_t) -> attr_value_t;
}
extern "C" {
    pub fn SIM_attr_scanf(list: *mut attr_value_t, fmt: *const ::std::os::raw::c_char, ...)
        -> bool;
}
extern "C" {
    pub fn SIM_ascanf(list: *mut attr_value_t, fmt: *const ::std::os::raw::c_char, ...) -> bool;
}
extern "C" {
    pub fn VT_make_attr(fmt: *const ::std::os::raw::c_char, ...) -> attr_value_t;
}
extern "C" {
    pub fn SIM_attr_free(value: *mut attr_value_t);
}
extern "C" {
    pub fn SIM_free_attribute(value: attr_value_t);
}
extern "C" {
    pub fn VT_attr_values_equal(a1: attr_value_t, a2: attr_value_t) -> bool;
}
extern "C" {
    pub fn SIM_source_python(file: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_source_python_in_module(
        file: *const ::std::os::raw::c_char,
        module: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_run_python(line: *const ::std::os::raw::c_char) -> attr_value_t;
}
extern "C" {
    pub fn SIM_call_python_function(
        func: *const ::std::os::raw::c_char,
        args: *mut attr_value_t,
    ) -> attr_value_t;
}
extern "C" {
    pub fn VT_call_python_module_function(
        module: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        args: *mut attr_value_t,
    ) -> attr_value_t;
}
extern "C" {
    pub fn SIM_get_python_interface_type(name: *const ::std::os::raw::c_char) -> *mut _object;
}
extern "C" {
    pub fn VT_python_decref(o: *mut _object);
}
extern "C" {
    pub fn VT_unregister_thread();
}
extern "C" {
    pub fn VT_register_thread();
}
extern "C" {
    pub fn VT_register_oec_thread();
}
extern "C" {
    pub fn VT_is_oec_thread() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pre_conf_object_set_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SIM_read_configuration(file: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_set_configuration(conf: attr_value_t);
}
extern "C" {
    pub fn SIM_add_configuration(
        object_list: *mut pre_conf_object_set_t,
        file: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_current_checkpoint_dir() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_add_objects(set: *mut pre_conf_object_set_t) -> attr_value_t;
}
#[doc = " old-style save without creating directory"]
pub const save_flags_t_Sim_Save_Nobundle: save_flags_t = 1;
#[doc = " use RLE for data values"]
pub const save_flags_t_Sim_Save_RLE_Data: save_flags_t = 2;
#[doc = " create gzipped config file"]
pub const save_flags_t_Sim_Save_Gzip_Config: save_flags_t = 4;
pub type save_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn SIM_write_configuration_to_file(
        file: *const ::std::os::raw::c_char,
        flags: save_flags_t,
    );
}
extern "C" {
    pub fn VT_get_configuration(file: *const ::std::os::raw::c_char) -> *mut pre_conf_object_set_t;
}
#[doc = " Please do not access the members of this struct directly"]
pub type sobject_t = sobject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sclass {
    _unused: [u8; 0],
}
pub type sclass_t = sclass;
#[doc = " Please do not access the members of this struct directly"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sobject {
    pub isa: *mut sclass_t,
    pub props: *mut proplist,
}
#[test]
fn bindgen_test_layout_sobject() {
    const UNINIT: ::std::mem::MaybeUninit<sobject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sobject>(),
        16usize,
        concat!("Size of: ", stringify!(sobject))
    );
    assert_eq!(
        ::std::mem::align_of::<sobject>(),
        8usize,
        concat!("Alignment of ", stringify!(sobject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sobject),
            "::",
            stringify!(isa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sobject),
            "::",
            stringify!(props)
        )
    );
}
impl Default for sobject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const attr_attr_t_Sim_Attr_Required: attr_attr_t = 0;
pub const attr_attr_t_Sim_Attr_Optional: attr_attr_t = 1;
pub const attr_attr_t_Sim_Attr_Session: attr_attr_t = 3;
pub const attr_attr_t_Sim_Attr_Pseudo: attr_attr_t = 4;
pub const attr_attr_t_Sim_Attr_Integer_Indexed: attr_attr_t = 4096;
pub const attr_attr_t_Sim_Attr_String_Indexed: attr_attr_t = 8192;
pub const attr_attr_t_Sim_Attr_List_Indexed: attr_attr_t = 16384;
pub const attr_attr_t_Sim_Attr_Persistent: attr_attr_t = 131072;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Attr_Flag_Mask: attr_attr_t = 255;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Init_Phase_Shift: attr_attr_t = 8;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Init_Phase_0: attr_attr_t = 0;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Init_Phase_1: attr_attr_t = 256;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Init_Phase_Bits: attr_attr_t = 2;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Init_Phase_Mask: attr_attr_t = 3;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Init_Phase_Pre1: attr_attr_t = 768;
#[doc = " The members below are for internal use only."]
pub const attr_attr_t_Sim_Attr_Class: attr_attr_t = 32768;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_Internal: attr_attr_t = 65536;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_Doc: attr_attr_t = 1048576;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_CB_Data: attr_attr_t = 2097152;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_Legacy: attr_attr_t = 4194304;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_Weak_Ref: attr_attr_t = 8388608;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_Read_Only: attr_attr_t = 262144;
#[doc = " To prevent attribute from being visible in documentation,\nuse Sim_Attr_Internal."]
pub const attr_attr_t_Sim_Attr_Write_Only: attr_attr_t = 524288;
pub type attr_attr_t = ::std::os::raw::c_uint;
pub const set_error_t_Sim_Set_Ok: set_error_t = 0;
pub const set_error_t_Sim_Set_Object_Not_Found: set_error_t = 1;
pub const set_error_t_Sim_Set_Interface_Not_Found: set_error_t = 2;
pub const set_error_t_Sim_Set_Illegal_Value: set_error_t = 3;
pub const set_error_t_Sim_Set_Illegal_Type: set_error_t = 4;
pub const set_error_t_Sim_Set_Illegal_Index: set_error_t = 5;
pub const set_error_t_Sim_Set_Attribute_Not_Found: set_error_t = 6;
pub const set_error_t_Sim_Set_Not_Writable: set_error_t = 7;
#[doc = " number of error types"]
pub const set_error_t_Sim_Set_Error_Types: set_error_t = 8;
#[doc = " <add-type id=\"conf set_error_t\"></add-type>"]
pub type set_error_t = ::std::os::raw::c_uint;
#[doc = " object is saved at checkpoints"]
pub const class_kind_t_Sim_Class_Kind_Vanilla: class_kind_t = 0;
#[doc = " object is saved as part of a\n session only"]
pub const class_kind_t_Sim_Class_Kind_Session: class_kind_t = 1;
#[doc = " object is never saved"]
pub const class_kind_t_Sim_Class_Kind_Pseudo: class_kind_t = 2;
#[doc = " extension class (see SIM_extend_class)"]
pub const class_kind_t_Sim_Class_Kind_Extension: class_kind_t = 3;
#[doc = " <add-type id=\"conf class_info_t\">\n</add-type>"]
pub type class_kind_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_class {
    _unused: [u8; 0],
}
pub type conf_class_t = conf_class;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct class_data {
    pub alloc_object:
        ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void) -> *mut conf_object_t>,
    pub init_object: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void) -> *mut lang_void,
    >,
    pub finalize_instance: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub pre_delete_instance: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub delete_instance: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub description: *const ::std::os::raw::c_char,
    pub class_desc: *const ::std::os::raw::c_char,
    pub kind: class_kind_t,
}
#[test]
fn bindgen_test_layout_class_data() {
    const UNINIT: ::std::mem::MaybeUninit<class_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<class_data>(),
        64usize,
        concat!("Size of: ", stringify!(class_data))
    );
    assert_eq!(
        ::std::mem::align_of::<class_data>(),
        8usize,
        concat!("Alignment of ", stringify!(class_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(alloc_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_object) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(init_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize_instance) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(finalize_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_delete_instance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(pre_delete_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_instance) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(delete_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_desc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(class_desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(class_data),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for class_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_data_t = class_data;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct class_info {
    pub alloc:
        ::std::option::Option<unsafe extern "C" fn(cls: *mut conf_class_t) -> *mut conf_object_t>,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut lang_void>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub objects_finalized: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub dealloc: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub description: *const ::std::os::raw::c_char,
    pub short_desc: *const ::std::os::raw::c_char,
    pub kind: class_kind_t,
}
#[test]
fn bindgen_test_layout_class_info() {
    const UNINIT: ::std::mem::MaybeUninit<class_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<class_info>(),
        72usize,
        concat!("Size of: ", stringify!(class_info))
    );
    assert_eq!(
        ::std::mem::align_of::<class_info>(),
        8usize,
        concat!("Alignment of ", stringify!(class_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objects_finalized) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(objects_finalized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dealloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(dealloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_desc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(short_desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(class_info),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for class_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_info_t = class_info;
#[doc = " Opaque struct - do not access members directly!"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct conf_object {
    pub sobj: sobject_t,
    pub instance_data: *mut ::std::os::raw::c_void,
    pub log: *mut log_info,
    pub conf: *mut confdata,
    pub extension_data: *mut extension_data,
    pub thread_domain: *mut thread_domain,
    pub reserved: [*mut ::std::os::raw::c_void; 3usize],
}
#[test]
fn bindgen_test_layout_conf_object() {
    const UNINIT: ::std::mem::MaybeUninit<conf_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conf_object>(),
        80usize,
        concat!("Size of: ", stringify!(conf_object))
    );
    assert_eq!(
        ::std::mem::align_of::<conf_object>(),
        8usize,
        concat!("Alignment of ", stringify!(conf_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sobj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(sobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(instance_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extension_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(extension_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_domain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(thread_domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_object),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for conf_object {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Register new class. Returns NULL on failure."]
    pub fn SIM_register_class(
        name: *const ::std::os::raw::c_char,
        class_data: *const class_data_t,
    ) -> *mut conf_class_t;
}
extern "C" {
    pub fn SIM_register_class_alias(
        alias: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_create_class(
        name: *const ::std::os::raw::c_char,
        class_info: *const class_info_t,
    ) -> *mut conf_class_t;
}
extern "C" {
    pub fn SIM_extend_class(cls: *mut conf_class_t, ext: *mut conf_class_t);
}
extern "C" {
    pub fn SIM_copy_class(
        name: *const ::std::os::raw::c_char,
        src_cls: *const conf_class_t,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut conf_class_t;
}
extern "C" {
    pub fn SIM_get_class_name(class_data: *const conf_class_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_set_constructor_data(cls: *mut conf_class_t, data: *mut lang_void);
}
extern "C" {
    pub fn SIM_set_class_data(cls: *mut conf_class_t, data: *mut lang_void);
}
extern "C" {
    pub fn SIM_get_class_data(cls: *mut conf_class_t) -> *mut lang_void;
}
extern "C" {
    pub fn SIM_require_object(obj: *mut conf_object_t);
}
extern "C" {
    pub fn SIM_object_name(obj: *const conf_object_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_object_id(obj: *const conf_object_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_object_is_configured(obj: *const conf_object_t) -> bool;
}
extern "C" {
    pub fn SIM_set_object_configured(obj: *mut conf_object_t);
}
extern "C" {
    pub fn SIM_object_data(obj: *mut conf_object_t) -> *mut lang_void;
}
extern "C" {
    pub fn SIM_extension_data(obj: *mut conf_object_t, cls: *mut conf_class_t) -> *mut lang_void;
}
extern "C" {
    pub fn SIM_port_object_parent(obj: *mut conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_object_parent(obj: *mut conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_object_descendant(
        obj: *mut conf_object_t,
        relname: *const ::std::os::raw::c_char,
    ) -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_object_iterator(obj: *mut conf_object_t) -> *mut _object;
}
extern "C" {
    pub fn VT_shallow_object_iterator(obj: *mut conf_object_t, expand_arrays: bool)
        -> *mut _object;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct object_iter_t {
    #[doc = " Opaque fields. Do not access directly."]
    pub node: *mut conf_object_t,
    pub depth: ::std::os::raw::c_uint,
    pub kind: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_object_iter_t() {
    const UNINIT: ::std::mem::MaybeUninit<object_iter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<object_iter_t>(),
        16usize,
        concat!("Size of: ", stringify!(object_iter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<object_iter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(object_iter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(object_iter_t),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(object_iter_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(object_iter_t),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for object_iter_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SIM_object_iterator(obj: *mut conf_object_t) -> object_iter_t;
}
extern "C" {
    pub fn SIM_shallow_object_iterator(obj: *mut conf_object_t) -> object_iter_t;
}
extern "C" {
    pub fn SIM_object_iterator_next(iter: *mut object_iter_t) -> *mut conf_object_t;
}
#[doc = " <add-type id=\"conf get_attr_t\">\n</add-type>"]
pub type get_attr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut lang_void,
        obj: *mut conf_object_t,
        idx: *mut attr_value_t,
    ) -> attr_value_t,
>;
#[doc = " <add-type id=\"conf get_class_attr_t\">\n</add-type>"]
pub type get_class_attr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut lang_void,
        c: *mut conf_class_t,
        idx: *mut attr_value_t,
    ) -> attr_value_t,
>;
#[doc = " <add-type id=\"conf set_attr_t\">  </add-type>"]
pub type set_attr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut lang_void,
        obj: *mut conf_object_t,
        val: *mut attr_value_t,
        idx: *mut attr_value_t,
    ) -> set_error_t,
>;
#[doc = " <add-type id=\"conf set_class_attr_t\">\n</add-type>"]
pub type set_class_attr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut lang_void,
        c: *mut conf_class_t,
        val: *mut attr_value_t,
        idx: *mut attr_value_t,
    ) -> set_error_t,
>;
extern "C" {
    #[doc = " Register a typed attribute (with an optionally typed index)."]
    pub fn SIM_register_typed_attribute(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        get_attr: get_attr_t,
        user_data_get: *mut lang_void,
        set_attr: set_attr_t,
        user_data_set: *mut lang_void,
        attr: attr_attr_t,
        type_: *const ::std::os::raw::c_char,
        idx_type: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_register_typed_class_attribute(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        get_attr: get_class_attr_t,
        user_data_get: *mut lang_void,
        set_attr: set_class_attr_t,
        user_data_set: *mut lang_void,
        attr: attr_attr_t,
        type_: *const ::std::os::raw::c_char,
        idx_type: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_register_attribute(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        get_attr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut conf_object_t) -> attr_value_t,
        >,
        set_attr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut conf_object_t, arg2: *mut attr_value_t) -> set_error_t,
        >,
        attr: attr_attr_t,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_register_class_attribute(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        get_attr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut conf_class_t) -> attr_value_t,
        >,
        set_attr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut conf_class_t, arg2: *mut attr_value_t) -> set_error_t,
        >,
        attr: attr_attr_t,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_register_attribute_with_user_data(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        get_attr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut conf_object_t, arg2: *mut lang_void) -> attr_value_t,
        >,
        user_data_get: *mut lang_void,
        set_attr: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut conf_object_t,
                arg2: *mut attr_value_t,
                arg3: *mut lang_void,
            ) -> set_error_t,
        >,
        user_data_set: *mut lang_void,
        attr: attr_attr_t,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_register_class_attribute_with_user_data(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        get_attr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut conf_class_t, arg2: *mut lang_void) -> attr_value_t,
        >,
        user_data_get: *mut lang_void,
        set_attr: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut conf_class_t,
                arg2: *mut attr_value_t,
                arg3: *mut lang_void,
            ) -> set_error_t,
        >,
        user_data_set: *mut lang_void,
        attr: attr_attr_t,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_ensure_partial_attr_order(
        cls: *mut conf_class_t,
        attr1: *const ::std::os::raw::c_char,
        attr2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_attribute_error(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_c_attribute_error(msg: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VT_set_cpu_offset(arg: *const ::std::os::raw::c_void, add: bool);
}
pub type interface_t = ::std::os::raw::c_void;
pub type class_interface_t = ::std::os::raw::c_void;
extern "C" {
    #[doc = " Return error code on failure (0 == ok)."]
    pub fn SIM_register_interface(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        iface: *const interface_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_register_port_interface(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        iface: *const interface_t,
        portname: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_register_compatible_interfaces(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_register_port(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        port_cls: *mut conf_class_t,
        desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_register_simple_port(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut conf_class_t;
}
extern "C" {
    #[doc = " Get interface from object (returns NULL if interface not\nimplemented by object)."]
    pub fn SIM_get_interface(
        obj: *const conf_object_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const interface_t;
}
extern "C" {
    pub fn SIM_c_get_interface(
        obj: *const conf_object_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const interface_t;
}
extern "C" {
    pub fn SIM_get_class_interface(
        cls: *const conf_class_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const class_interface_t;
}
extern "C" {
    pub fn SIM_c_get_class_interface(
        cls: *const conf_class_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const class_interface_t;
}
extern "C" {
    pub fn SIM_get_port_interface(
        obj: *const conf_object_t,
        name: *const ::std::os::raw::c_char,
        portname: *const ::std::os::raw::c_char,
    ) -> *const interface_t;
}
extern "C" {
    pub fn SIM_c_get_port_interface(
        obj: *const conf_object_t,
        name: *const ::std::os::raw::c_char,
        portname: *const ::std::os::raw::c_char,
    ) -> *const interface_t;
}
extern "C" {
    pub fn SIM_get_class_port_interface(
        cls: *const conf_class_t,
        name: *const ::std::os::raw::c_char,
        portname: *const ::std::os::raw::c_char,
    ) -> *const class_interface_t;
}
extern "C" {
    pub fn SIM_c_get_class_port_interface(
        cls: *const conf_class_t,
        name: *const ::std::os::raw::c_char,
        portname: *const ::std::os::raw::c_char,
    ) -> *const class_interface_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interface_array_t {
    pub size: ::std::os::raw::c_int,
    pub used: ::std::os::raw::c_int,
    pub elements: *mut *const interface_t,
}
#[test]
fn bindgen_test_layout_interface_array_t() {
    const UNINIT: ::std::mem::MaybeUninit<interface_array_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interface_array_t>(),
        16usize,
        concat!("Size of: ", stringify!(interface_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<interface_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(interface_array_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interface_array_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(interface_array_t),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interface_array_t),
            "::",
            stringify!(elements)
        )
    );
}
impl Default for interface_array_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VT_register_port_array_interface(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        iface_list: *const interface_array_t,
        portname: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_marked_for_deletion(obj: *const conf_object_t) -> bool;
}
#[doc = " <add-type id=\"simtime_t def\"></add-type>"]
pub type simtime_t = int64;
#[doc = " <add-type id=\"cycles_t def\"></add-type>"]
pub type cycles_t = simtime_t;
#[doc = " <add-type id=\"nano_secs_t def\"></add-type>"]
pub type nano_secs_t = int64;
extern "C" {
    pub fn SIM_cycle_count(obj: *mut conf_object_t) -> cycles_t;
}
extern "C" {
    pub fn SIM_time(obj: *mut conf_object_t) -> f64;
}
extern "C" {
    pub fn SIM_stall_cycle(obj: *mut conf_object_t, cycles: cycles_t);
}
extern "C" {
    pub fn SIM_stall(obj: *mut conf_object_t, seconds: f64);
}
extern "C" {
    pub fn SIM_stalled_until(obj: *mut conf_object_t) -> cycles_t;
}
extern "C" {
    pub fn SIM_stall_count(obj: *mut conf_object_t) -> cycles_t;
}
extern "C" {
    pub fn SIM_object_clock(obj: *const conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_picosecond_clock(obj: *mut conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_set_object_clock(obj: *mut conf_object_t, clock: *mut conf_object_t);
}
extern "C" {
    pub fn VT_object_ps_clock(obj: *mut conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_cycles_to_quantum_end(obj: *mut conf_object_t) -> cycles_t;
}
pub const event_class_flag_t_Sim_EC_No_Flags: event_class_flag_t = 0;
#[doc = " event not saved in configurations"]
pub const event_class_flag_t_Sim_EC_Notsaved: event_class_flag_t = 1;
#[doc = " event should run before events not marked\nwith this flag"]
pub const event_class_flag_t_Sim_EC_Slot_Early: event_class_flag_t = 2;
#[doc = " event should run after events not marked\nwith this flag"]
pub const event_class_flag_t_Sim_EC_Slot_Late: event_class_flag_t = 4;
#[doc = " synchronize machine on event"]
pub const event_class_flag_t_Sim_EC_Machine_Sync: event_class_flag_t = 8;
#[doc = " can execute in parallel with execution"]
pub const event_class_flag_t_Sim_EC_No_Serialize: event_class_flag_t = 16;
pub type event_class_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct event_class {
    #[doc = " identifier, unique within the conf_class (malloced)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " conf class this event class belongs to; posting object must\nbelong to this class."]
    pub conf_class: *mut conf_class_t,
    pub flags: event_class_flag_t,
    #[doc = " function called when event expires"]
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void)>,
    #[doc = " function called when the event is removed without expiry.\nMay be null.\nMust not access the Simics configuration in any way!"]
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void)>,
    #[doc = " convert event data to an attribute value.\nMay be null if flags has Sim_EC_Notsaved set.\nEvent should not be saved if return value is invalid."]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void) -> attr_value_t,
    >,
    #[doc = " convert attribute value to event data.\nMay be null if flags has Sim_EC_Notsaved set."]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: attr_value_t) -> *mut lang_void,
    >,
    #[doc = " human-readable event description. The returned string must be\nmalloced; it will be freed by the caller."]
    pub describe: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            data: *mut lang_void,
        ) -> *mut ::std::os::raw::c_char,
    >,
    #[doc = " internal - absolute priority for event"]
    pub slot: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_event_class() {
    const UNINIT: ::std::mem::MaybeUninit<event_class> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_class>(),
        72usize,
        concat!("Size of: ", stringify!(event_class))
    );
    assert_eq!(
        ::std::mem::align_of::<event_class>(),
        8usize,
        concat!("Alignment of ", stringify!(event_class))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conf_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(conf_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).describe) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(describe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(event_class),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for event_class {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type event_class_t = event_class;
extern "C" {
    pub fn SIM_register_event(
        name: *const ::std::os::raw::c_char,
        cl: *mut conf_class_t,
        flags: event_class_flag_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void),
        >,
        destroy: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void),
        >,
        get_value: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut lang_void) -> attr_value_t,
        >,
        set_value: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, value: attr_value_t) -> *mut lang_void,
        >,
        describe: ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut conf_object_t,
                data: *mut lang_void,
            ) -> *mut ::std::os::raw::c_char,
        >,
    ) -> *mut event_class_t;
}
extern "C" {
    pub fn SIM_event_post_time(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        seconds: f64,
        user_data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_event_post_cycle(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        cycles: cycles_t,
        user_data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_event_cancel_time(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        pred: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut lang_void,
                match_data: *mut lang_void,
            ) -> ::std::os::raw::c_int,
        >,
        match_data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_event_find_next_cycle(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        pred: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut lang_void,
                match_data: *mut lang_void,
            ) -> ::std::os::raw::c_int,
        >,
        match_data: *mut lang_void,
    ) -> cycles_t;
}
extern "C" {
    pub fn SIM_event_find_next_time(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        pred: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut lang_void,
                match_data: *mut lang_void,
            ) -> ::std::os::raw::c_int,
        >,
        match_data: *mut lang_void,
    ) -> f64;
}
extern "C" {
    pub fn VT_get_event_class(
        cl: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut event_class_t;
}
extern "C" {
    pub fn VT_stacked_post(
        obj: *mut conf_object_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, param: *mut lang_void),
        >,
        user_data: *mut lang_void,
    );
}
pub type pico_secs_t = int64;
#[doc = " <add-type id=\"pc_step_t def\"></add-type>"]
pub type pc_step_t = simtime_t;
extern "C" {
    pub fn SIM_event_post_step(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        steps: pc_step_t,
        user_data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_event_cancel_step(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        pred: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut lang_void,
                match_data: *mut lang_void,
            ) -> ::std::os::raw::c_int,
        >,
        match_data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_event_find_next_step(
        clock: *mut conf_object_t,
        evclass: *mut event_class_t,
        obj: *mut conf_object_t,
        pred: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut lang_void,
                match_data: *mut lang_void,
            ) -> ::std::os::raw::c_int,
        >,
        match_data: *mut lang_void,
    ) -> pc_step_t;
}
extern "C" {
    pub fn SIM_step_count(obj: *mut conf_object_t) -> pc_step_t;
}
extern "C" {
    pub fn VT_clock_frequency_about_to_change(obj: *mut conf_object_t);
}
extern "C" {
    pub fn VT_clock_frequency_change(obj: *mut conf_object_t, cycles_per_second: uint64);
}
extern "C" {
    #[doc = " Make sure that Simics is not running when this function is called, and take\nthe necessary steps depending on the situation"]
    pub fn VT_assert_outside_execution_context(
        func: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return true if VT_assert_outside_execution_context() would warn or assert in\nthe current situation. This function is meant to be used before calling\nVT_assert_outside_execution_context() to print specific warnings before\nasserting."]
    pub fn VT_outside_execution_context_violation() -> bool;
}
extern "C" {
    pub fn SIM_continue(steps: int64) -> pc_step_t;
}
extern "C" {
    pub fn SIM_simics_is_running() -> bool;
}
extern "C" {
    pub fn SIM_break_simulation(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_break_message(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_get_break_message() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_shutdown();
}
extern "C" {
    pub fn SIM_quit(exit_code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn VT_wait_for_simulator_init();
}
extern "C" {
    pub fn SIM_break_cycle(obj: *mut conf_object_t, cycles: int64);
}
extern "C" {
    pub fn SIM_break_step(obj: *mut conf_object_t, steps: int64);
}
extern "C" {
    pub fn VT_user_interrupt(
        msg: *const ::std::os::raw::c_char,
        break_script: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VT_inside_instruction() -> bool;
}
extern "C" {
    pub fn VT_thread_cell_association_begin(obj: *mut conf_object_t);
}
extern "C" {
    pub fn VT_thread_cell_association_end(obj: *mut conf_object_t);
}
extern "C" {
    pub fn VT_in_main_branch() -> bool;
}
extern "C" {
    pub fn VT_set_frontend_server(obj: *mut conf_object_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_send_startup_complete_message();
}
extern "C" {
    pub fn VT_remote_control() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_process_work(done: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type frontend_server_interface_t = frontend_server_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct frontend_server_interface {
    pub init_control_pipes: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, s: *const ::std::os::raw::c_char),
    >,
    pub have_mi_frontend: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub notify_break_on_breakpoint:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, break_id: int64)>,
    pub send_control_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            val: *mut attr_value_t,
            propagate_exception: bool,
        ),
    >,
    pub send_checkpoint_progress_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            msg: *const ::std::os::raw::c_char,
            caller: *mut conf_object_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_frontend_server_interface() {
    const UNINIT: ::std::mem::MaybeUninit<frontend_server_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frontend_server_interface>(),
        40usize,
        concat!("Size of: ", stringify!(frontend_server_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<frontend_server_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(frontend_server_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_control_pipes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frontend_server_interface),
            "::",
            stringify!(init_control_pipes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_mi_frontend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frontend_server_interface),
            "::",
            stringify!(have_mi_frontend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_break_on_breakpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frontend_server_interface),
            "::",
            stringify!(notify_break_on_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_control_message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frontend_server_interface),
            "::",
            stringify!(send_control_message)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).send_checkpoint_progress_message) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frontend_server_interface),
            "::",
            stringify!(send_checkpoint_progress_message)
        )
    );
}
pub type tcf_channel_interface_t = tcf_channel_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcf_channel_interface {
    pub start_channel: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            url: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_tcf_channel_interface() {
    const UNINIT: ::std::mem::MaybeUninit<tcf_channel_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcf_channel_interface>(),
        8usize,
        concat!("Size of: ", stringify!(tcf_channel_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<tcf_channel_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_channel_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_channel_interface),
            "::",
            stringify!(start_channel)
        )
    );
}
extern "C" {
    pub fn VT_get_stop_reasons() -> attr_value_t;
}
pub const stop_type_t_Sim_Stop_Stopped: stop_type_t = 0;
pub const stop_type_t_Sim_Stop_Aborted: stop_type_t = 1;
pub type stop_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn VT_get_stop_type() -> stop_type_t;
}
extern "C" {
    pub fn VT_stop_message(obj: *mut conf_object_t, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_stop_error(obj: *mut conf_object_t, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_stop_user(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_stop_finished(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_abort_error(obj: *mut conf_object_t, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_abort_user(msg: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct execute_environ {
    _unused: [u8; 0],
}
pub type execute_environ_t = execute_environ;
extern "C" {
    pub fn VT_create_execute_environ() -> *mut execute_environ_t;
}
extern "C" {
    pub fn VT_free_execute_environ(env: *mut execute_environ_t);
}
extern "C" {
    pub fn VT_set_execute_environ(obj: *mut conf_object_t, env: *mut execute_environ_t);
}
extern "C" {
    pub fn VT_stop_execution(env: *mut execute_environ_t);
}
extern "C" {
    pub fn VT_activate_executor(ec: *mut execute_environ_t, obj: *mut conf_object_t);
}
extern "C" {
    pub fn VT_execute(ec: *mut execute_environ_t) -> bool;
}
pub const gui_mode_t_GUI_Mode_None: gui_mode_t = 0;
pub const gui_mode_t_GUI_Mode_Mixed: gui_mode_t = 1;
pub const gui_mode_t_GUI_Mode_Only: gui_mode_t = 2;
pub const gui_mode_t_GUI_Mode_Default: gui_mode_t = 3;
#[doc = " <add-type id=\"gui_mode_t def\">\n</add-type>"]
pub type gui_mode_t = ::std::os::raw::c_uint;
#[doc = " internal, do not use"]
pub const cpu_variant_t_Cpu_None: cpu_variant_t = 0;
pub const cpu_variant_t_Cpu_Any: cpu_variant_t = 1;
pub const cpu_variant_t_Cpu_Fast: cpu_variant_t = 2;
pub const cpu_variant_t_Cpu_Stall: cpu_variant_t = 3;
#[doc = " <add-type id=\"cpu_variant_t def\">\n</add-type>"]
pub type cpu_variant_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"init_prefs_t def\">\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct init_prefs_t {
    pub batch_mode: bool,
    pub quiet: bool,
    pub verbose: bool,
    pub python_verbose: bool,
    pub disable_istc: bool,
    pub disable_dstc: bool,
    pub module_cache_enable: bool,
    pub rdp: bool,
    pub sign_module: bool,
    pub log_file: *const ::std::os::raw::c_char,
    #[doc = " NULL to use saved prefs value"]
    pub project: *const ::std::os::raw::c_char,
    #[doc = " Deprecated, do not use"]
    pub workspace: *const ::std::os::raw::c_char,
    #[doc = " GUI_Mode_Default to use saved prefs value"]
    pub gui_mode: gui_mode_t,
    #[doc = " CPU_Any to use saved prefs value"]
    pub cpu_mode: cpu_variant_t,
    #[doc = " internal, do not use"]
    pub package_list: *const ::std::os::raw::c_char,
    #[doc = " NULL to use saved prefs value"]
    pub license_file: *const ::std::os::raw::c_char,
    pub expire_time: *const ::std::os::raw::c_char,
    pub no_windows: bool,
    pub fail_on_warnings: bool,
    #[doc = " see sim->warn_deprecated"]
    pub deprecation_level: *const ::std::os::raw::c_char,
    #[doc = " same as deprecation_level == 2"]
    pub warn_deprecated: bool,
    #[doc = " same as deprecation_level == 0"]
    pub no_warn_deprecated: bool,
    #[doc = " deprecated and ignored (bug 21597)"]
    pub warn_multithread: bool,
    pub check_ifaces: bool,
    #[doc = " do not read preferences and recent-files"]
    pub no_global_settings: bool,
    #[doc = " internal - for test usage"]
    pub alt_settings_dir: *const ::std::os::raw::c_char,
    #[doc = " the following should be -1 if not set by command line options\nto tell SIM_init_simulator() to use the saved preference value"]
    pub log_enable: ::std::os::raw::c_int,
    #[doc = " internal, do not use"]
    pub allow_license_gui: bool,
    #[doc = " internal, do not use"]
    pub eclipse_params: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_init_prefs_t() {
    const UNINIT: ::std::mem::MaybeUninit<init_prefs_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<init_prefs_t>(),
        120usize,
        concat!("Size of: ", stringify!(init_prefs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<init_prefs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(init_prefs_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(batch_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quiet) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(quiet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).python_verbose) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(python_verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_istc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(disable_istc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_dstc) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(disable_dstc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_cache_enable) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(module_cache_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign_module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(sign_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(log_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).project) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workspace) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(workspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(gui_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_mode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(cpu_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).package_list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(package_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).license_file) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(license_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expire_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(expire_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_windows) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(no_windows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fail_on_warnings) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(fail_on_warnings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecation_level) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(deprecation_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warn_deprecated) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(warn_deprecated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_warn_deprecated) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(no_warn_deprecated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warn_multithread) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(warn_multithread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_ifaces) as usize - ptr as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(check_ifaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_global_settings) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(no_global_settings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_settings_dir) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(alt_settings_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_enable) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(log_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_license_gui) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(allow_license_gui)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eclipse_params) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(init_prefs_t),
            "::",
            stringify!(eclipse_params)
        )
    );
}
impl Default for init_prefs_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SIM_init_environment(
        argv: *mut *mut ::std::os::raw::c_char,
        handle_signals: bool,
        allow_core_dumps: bool,
    );
}
#[doc = " <add-type id=\"init_arg_t def\"></add-type>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct init_arg_t {
    pub name: *const ::std::os::raw::c_char,
    pub boolean: bool,
    pub u: init_arg_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union init_arg_t__bindgen_ty_1 {
    pub string: *const ::std::os::raw::c_char,
    pub enabled: bool,
}
#[test]
fn bindgen_test_layout_init_arg_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<init_arg_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<init_arg_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(init_arg_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<init_arg_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(init_arg_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_arg_t__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_arg_t__bindgen_ty_1),
            "::",
            stringify!(enabled)
        )
    );
}
impl Default for init_arg_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_init_arg_t() {
    const UNINIT: ::std::mem::MaybeUninit<init_arg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<init_arg_t>(),
        24usize,
        concat!("Size of: ", stringify!(init_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<init_arg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(init_arg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_arg_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolean) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(init_arg_t),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(init_arg_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for init_arg_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SIM_init_simulator2(init_args: *mut init_arg_t);
}
extern "C" {
    pub fn SIM_set_frontend_context(context: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn VT_init_package_list(package_list: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_get_init_arg_string(
        name: *const ::std::os::raw::c_char,
        default_value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_get_init_arg_boolean(
        name: *const ::std::os::raw::c_char,
        default_value: bool,
    ) -> bool;
}
extern "C" {
    pub fn SIM_init_command_line();
}
extern "C" {
    pub fn SIM_main_loop();
}
extern "C" {
    pub fn VT_check_package_updates();
}
extern "C" {
    #[doc = " Get registered class (returns NULL if class not found)."]
    pub fn SIM_get_class(name: *const ::std::os::raw::c_char) -> *mut conf_class_t;
}
#[doc = " <add-type id=\"addr_prof_iter_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct addr_prof_iter {
    pub next: ::std::option::Option<unsafe extern "C" fn(i: *mut addr_prof_iter) -> uint64>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(i: *mut addr_prof_iter)>,
    pub addr: generic_address_t,
}
#[test]
fn bindgen_test_layout_addr_prof_iter() {
    const UNINIT: ::std::mem::MaybeUninit<addr_prof_iter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addr_prof_iter>(),
        24usize,
        concat!("Size of: ", stringify!(addr_prof_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<addr_prof_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(addr_prof_iter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_prof_iter),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_prof_iter),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_prof_iter),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " <add-type id=\"addr_prof_iter_t def\"></add-type>"]
pub type addr_prof_iter_t = addr_prof_iter;
pub const branch_arc_type_t_Branch_Arc_Branch: branch_arc_type_t = 0;
pub const branch_arc_type_t_Branch_Arc_Exception: branch_arc_type_t = 1;
pub const branch_arc_type_t_Branch_Arc_Exception_Return: branch_arc_type_t = 2;
pub const branch_arc_type_t_Branch_Arc_Max: branch_arc_type_t = 3;
#[doc = "<add-type id=\"branch_arc_type_t def\"></add-type>"]
pub type branch_arc_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct branch_arc_t {
    pub addr_from: uint64,
    pub addr_to: uint64,
    pub count: int64,
    pub type_: branch_arc_type_t,
}
#[test]
fn bindgen_test_layout_branch_arc_t() {
    const UNINIT: ::std::mem::MaybeUninit<branch_arc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<branch_arc_t>(),
        32usize,
        concat!("Size of: ", stringify!(branch_arc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<branch_arc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(branch_arc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_from) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_t),
            "::",
            stringify!(addr_from)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_to) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_t),
            "::",
            stringify!(addr_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_t),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for branch_arc_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct branch_arc_iter {
    pub next:
        ::std::option::Option<unsafe extern "C" fn(i: *mut branch_arc_iter) -> *mut branch_arc_t>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(i: *mut branch_arc_iter)>,
}
#[test]
fn bindgen_test_layout_branch_arc_iter() {
    const UNINIT: ::std::mem::MaybeUninit<branch_arc_iter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<branch_arc_iter>(),
        16usize,
        concat!("Size of: ", stringify!(branch_arc_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<branch_arc_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(branch_arc_iter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_iter),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_iter),
            "::",
            stringify!(destroy)
        )
    );
}
pub type branch_arc_iter_t = branch_arc_iter;
pub const branch_recorder_direction_t_BR_Direction_From: branch_recorder_direction_t = 0;
pub const branch_recorder_direction_t_BR_Direction_To: branch_recorder_direction_t = 1;
#[doc = "<add-type id=\"branch_recorder_direction_t def\"></add-type>"]
pub type branch_recorder_direction_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct branch_recorder {
    _unused: [u8; 0],
}
pub type branch_recorder_t = branch_recorder;
pub type iter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        br: *mut branch_recorder_t,
        start: generic_address_t,
        stop: generic_address_t,
    ) -> *mut addr_prof_iter_t,
>;
pub type branch_recorder_handler_interface_t = branch_recorder_handler_interface;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct branch_recorder_handler_interface {
    #[doc = " Attach/detach returns zero on error."]
    pub attach_branch_recorder: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            brec: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub detach_branch_recorder: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            brec: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_cpu_branch_recorder:
        ::std::option::Option<unsafe extern "C" fn(br: *mut branch_recorder_t)>,
    pub destroy_cpu_branch_recorder:
        ::std::option::Option<unsafe extern "C" fn(br: *mut branch_recorder_t)>,
    pub delete_arcs: ::std::option::Option<unsafe extern "C" fn(br: *mut branch_recorder_t)>,
    pub num_branches: ::std::option::Option<
        unsafe extern "C" fn(br: *mut branch_recorder_t) -> ::std::os::raw::c_int,
    >,
    pub get_branches:
        ::std::option::Option<unsafe extern "C" fn(br: *mut branch_recorder_t) -> attr_value_t>,
    pub iter: *mut iter_func_t,
    pub iter_branch_arc: ::std::option::Option<
        unsafe extern "C" fn(
            br: *mut branch_recorder_t,
            start: generic_address_t,
            stop: generic_address_t,
            dir: branch_recorder_direction_t,
        ) -> *mut branch_arc_iter_t,
    >,
    pub eec_interrupt_instruction: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            extype: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub granularity_log2: ::std::os::raw::c_uint,
    pub view_descriptions: *mut *const ::std::os::raw::c_char,
    pub num_views: ::std::os::raw::c_int,
    pub pa_bits: ::std::os::raw::c_int,
    pub va_bits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_branch_recorder_handler_interface() {
    const UNINIT: ::std::mem::MaybeUninit<branch_recorder_handler_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<branch_recorder_handler_interface>(),
        112usize,
        concat!("Size of: ", stringify!(branch_recorder_handler_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<branch_recorder_handler_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(branch_recorder_handler_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach_branch_recorder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(attach_branch_recorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detach_branch_recorder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(detach_branch_recorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_cpu_branch_recorder) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(create_cpu_branch_recorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy_cpu_branch_recorder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(destroy_cpu_branch_recorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_arcs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(delete_arcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_branches) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(num_branches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_branches) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(get_branches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iter) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iter_branch_arc) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(iter_branch_arc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eec_interrupt_instruction) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(eec_interrupt_instruction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granularity_log2) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(granularity_log2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_descriptions) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(view_descriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_views) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(num_views)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pa_bits) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(pa_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_bits) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_recorder_handler_interface),
            "::",
            stringify!(va_bits)
        )
    );
}
impl Default for branch_recorder_handler_interface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const addr_type_t_Addr_Type_Invalid: addr_type_t = 0;
pub const addr_type_t_Addr_Type_Physical: addr_type_t = 1;
pub const addr_type_t_Addr_Type_Virtual: addr_type_t = 2;
pub type addr_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn SIM_run_command(line: *const ::std::os::raw::c_char) -> attr_value_t;
}
extern "C" {
    pub fn SIM_run_command_file(file: *const ::std::os::raw::c_char, local: bool);
}
extern "C" {
    pub fn SIM_run_command_file_params(
        file: *const ::std::os::raw::c_char,
        local: bool,
        params: attr_value_t,
    );
}
extern "C" {
    pub fn SIM_load_target(
        target: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
        presets: attr_value_t,
        cmdline_args: attr_value_t,
    );
}
extern "C" {
    pub fn VT_load_target_preset_yml(
        target: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
        preset_yml: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_get_batch_mode() -> bool;
}
extern "C" {
    pub fn VT_interrupt_script(user: bool);
}
extern "C" {
    pub fn SIM_get_all_modules() -> attr_value_t;
}
extern "C" {
    pub fn SIM_get_all_failed_modules() -> attr_value_t;
}
extern "C" {
    pub fn SIM_add_module_dir(path: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_module_list_refresh();
}
extern "C" {
    pub fn SIM_load_module(module: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_read_phys_memory(
        cpu: *mut conf_object_t,
        paddr: physical_address_t,
        length: ::std::os::raw::c_int,
    ) -> uint64;
}
extern "C" {
    pub fn SIM_write_phys_memory(
        cpu: *mut conf_object_t,
        paddr: physical_address_t,
        value: uint64,
        length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SIM_read_byte(obj: *mut conf_object_t, paddr: generic_address_t) -> uint8;
}
extern "C" {
    pub fn SIM_write_byte(obj: *mut conf_object_t, paddr: generic_address_t, value: uint8);
}
extern "C" {
    pub fn SIM_read_phys_memory_tags(
        mem_space: *mut conf_object_t,
        paddr: physical_address_t,
        ntags: ::std::os::raw::c_uint,
    ) -> uint64;
}
extern "C" {
    pub fn SIM_write_phys_memory_tags(
        mem_space: *mut conf_object_t,
        paddr: physical_address_t,
        tag_bits: uint64,
        ntags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SIM_load_binary(
        obj: *mut conf_object_t,
        file: *const ::std::os::raw::c_char,
        offset: physical_address_t,
        use_pa: bool,
        verbose: bool,
    ) -> physical_address_t;
}
extern "C" {
    pub fn SIM_load_file(
        obj: *mut conf_object_t,
        file: *const ::std::os::raw::c_char,
        paddr: physical_address_t,
        verbose: bool,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct completion {
    _unused: [u8; 0],
}
pub type completion_t = completion;
extern "C" {
    pub fn VT_new_completion() -> *mut completion_t;
}
extern "C" {
    pub fn VT_free_completion(c: *mut completion_t);
}
extern "C" {
    pub fn VT_wait_for_completion(c: *mut completion_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_set_completion(c: *mut completion_t, status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn VT_async_stall_usecs(usecs: uint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_handler {
    _unused: [u8; 0],
}
pub type wait_handler_t = wait_handler;
extern "C" {
    pub fn VT_create_wait_handler(
        wait: ::std::option::Option<
            unsafe extern "C" fn(
                ret_thread_id: *mut *mut ::std::os::raw::c_void,
                usr: *mut ::std::os::raw::c_void,
            ),
        >,
        resume: ::std::option::Option<
            unsafe extern "C" fn(
                thread_id: *mut ::std::os::raw::c_void,
                usr: *mut ::std::os::raw::c_void,
            ),
        >,
        usr: *mut ::std::os::raw::c_void,
    ) -> *mut wait_handler_t;
}
extern "C" {
    pub fn VT_free_wait_handler(h: *mut wait_handler_t);
}
extern "C" {
    pub fn VT_set_wait_handler(h: *mut wait_handler_t) -> *mut wait_handler_t;
}
extern "C" {
    pub fn VT_start_execution_fiber(
        obj: *mut conf_object_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, param: *mut lang_void),
        >,
        param: *mut lang_void,
    );
}
extern "C" {
    pub fn VT_abort_execution_fiber() -> !;
}
extern "C" {
    pub fn SIM_get_debugger() -> *mut conf_object_t;
}
pub const data_or_instr_t_Sim_DI_Instruction: data_or_instr_t = 0;
pub const data_or_instr_t_Sim_DI_Data: data_or_instr_t = 1;
#[doc = " <add-type id=\"data_or_instr_t def\">\n</add-type>"]
pub type data_or_instr_t = ::std::os::raw::c_uint;
pub const access_t_Sim_Access_Read: access_t = 1;
pub const access_t_Sim_Access_Write: access_t = 2;
pub const access_t_Sim_Access_Execute: access_t = 4;
#[doc = " All combinations are allowed (logical or)\n<add id=\"access_t\">\n<ndx>access_t</ndx>\n<insert-upto text=\";\"/>\n</add>"]
pub type access_t = ::std::os::raw::c_uint;
pub const processor_mode_t_Sim_CPU_Mode_User: processor_mode_t = 0;
pub const processor_mode_t_Sim_CPU_Mode_Supervisor: processor_mode_t = 1;
pub const processor_mode_t_Sim_CPU_Mode_Hypervisor: processor_mode_t = 2;
#[doc = " <add id=\"processor_mode_t DOC\">\n<ndx>processor_mode_t</ndx>\n<doc>\n<doc-item name=\"NAME\">processor_mode_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"processor_mode_t def\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\nThe <type>processor_mode_t</type> data type is used to specify if a\nCPU is running in user mode or in a privileged mode (often called\nsupervisor mode). For processor architectures with several\nprivilege levels, the non-user levels are all identified as\n<const>Sim_CPU_Mode_Supervisor</const>.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"processor_mode_t def\"></add-type>"]
pub type processor_mode_t = ::std::os::raw::c_uint;
pub const cpu_endian_t_Sim_Endian_Little: cpu_endian_t = 0;
pub const cpu_endian_t_Sim_Endian_Big: cpu_endian_t = 1;
pub type cpu_endian_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct physical_block_t {
    pub valid: ::std::os::raw::c_int,
    pub address: physical_address_t,
    pub block_start: physical_address_t,
    pub block_end: physical_address_t,
}
#[test]
fn bindgen_test_layout_physical_block_t() {
    const UNINIT: ::std::mem::MaybeUninit<physical_block_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<physical_block_t>(),
        32usize,
        concat!("Size of: ", stringify!(physical_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<physical_block_t>(),
        8usize,
        concat!("Alignment of ", stringify!(physical_block_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(physical_block_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(physical_block_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(physical_block_t),
            "::",
            stringify!(block_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(physical_block_t),
            "::",
            stringify!(block_end)
        )
    );
}
pub const breakpoint_kind_t_Sim_Break_Physical: breakpoint_kind_t = 0;
pub const breakpoint_kind_t_Sim_Break_Virtual: breakpoint_kind_t = 1;
#[doc = " x86 only"]
pub const breakpoint_kind_t_Sim_Break_Linear: breakpoint_kind_t = 2;
#[doc = " <add id=\"breakpoint_kind_t\">\n<ndx>breakpoint_kind_t</ndx>\n<insert-upto text=\";\"/>\n</add>"]
pub type breakpoint_kind_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"breakpoint_id_t\"><ndx>breakpoint_id_t</ndx></add-type>"]
pub type breakpoint_id_t = ::std::os::raw::c_int;
pub type breakpoint_handle_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_info_t {
    pub handle: breakpoint_handle_t,
    pub read_write_execute: access_t,
    pub start: generic_address_t,
    pub end: generic_address_t,
}
#[test]
fn bindgen_test_layout_breakpoint_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(breakpoint_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_info_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_write_execute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_info_t),
            "::",
            stringify!(read_write_execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_info_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_info_t),
            "::",
            stringify!(end)
        )
    );
}
impl Default for breakpoint_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_set_t {
    pub num_breakpoints: ::std::os::raw::c_int,
    pub breakpoints: *mut breakpoint_info_t,
}
#[test]
fn bindgen_test_layout_breakpoint_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_set_t>(),
        16usize,
        concat!("Size of: ", stringify!(breakpoint_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_breakpoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_set_t),
            "::",
            stringify!(num_breakpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).breakpoints) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_set_t),
            "::",
            stringify!(breakpoints)
        )
    );
}
impl Default for breakpoint_set_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const breakpoint_flag_Sim_Breakpoint_Temporary: breakpoint_flag = 1;
pub const breakpoint_flag_Sim_Breakpoint_Simulation: breakpoint_flag = 2;
pub const breakpoint_flag_Sim_Breakpoint_Private: breakpoint_flag = 4;
#[doc = " <add-type id=\"enum breakpoint_flag\"></add-type>"]
pub type breakpoint_flag = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"enum breakpoint_flag\"></add-type>"]
pub use self::breakpoint_flag as breakpoint_flag_t;
extern "C" {
    pub fn SIM_breakpoint(
        obj: *mut conf_object_t,
        type_: breakpoint_kind_t,
        access: access_t,
        address: uint64,
        length: uint64,
        flags: breakpoint_flag_t,
    ) -> breakpoint_id_t;
}
extern "C" {
    pub fn SIM_delete_breakpoint(id: breakpoint_id_t);
}
extern "C" {
    pub fn SIM_enable_breakpoint(id: breakpoint_id_t);
}
extern "C" {
    pub fn SIM_disable_breakpoint(id: breakpoint_id_t);
}
extern "C" {
    pub fn SIM_breakpoint_remove(
        id: breakpoint_id_t,
        access: access_t,
        address: generic_address_t,
        length: generic_address_t,
    );
}
extern "C" {
    pub fn SIM_object_is_processor(obj: *mut conf_object_t) -> bool;
}
extern "C" {
    pub fn SIM_number_processors() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_reset_processor(cpu: *mut conf_object_t, hard_reset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SIM_get_all_processors() -> attr_value_t;
}
extern "C" {
    pub fn SIM_get_processor(proc_no: ::std::os::raw::c_int) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_get_processor_number(cpu: *const conf_object_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_current_processor() -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_get_current_processor() -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_get_current_processor_old() -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_processor_privilege_level(cpu: *mut conf_object_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_disassemble_address(
        cpu: *mut conf_object_t,
        address: generic_address_t,
        logical: ::std::os::raw::c_int,
        sub: ::std::os::raw::c_int,
    ) -> tuple_int_string_t;
}
extern "C" {
    pub fn VT_first_clock() -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_current_clock() -> *mut conf_object_t;
}
#[doc = " <add-type id=\"cbdata def\"></add-type>"]
pub type cbdata_t = cbdata;
#[doc = " <add-type id=\"cbdata_reg def\"></add-type>"]
pub type cbdata_register_t = cbdata_t;
#[doc = " <add-type id=\"cbdata_reg def\"></add-type>"]
pub type cbdata_call_t = cbdata_t;
#[doc = " <add-type id=\"cbdata_type def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cbdata_type_t {
    pub name: *const ::std::os::raw::c_char,
    pub dealloc: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_cbdata_type_t() {
    const UNINIT: ::std::mem::MaybeUninit<cbdata_type_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbdata_type_t>(),
        16usize,
        concat!("Size of: ", stringify!(cbdata_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cbdata_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cbdata_type_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbdata_type_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dealloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbdata_type_t),
            "::",
            stringify!(dealloc)
        )
    );
}
impl Default for cbdata_type_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cbdata {
    pub type_: *const cbdata_type_t,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cbdata() {
    const UNINIT: ::std::mem::MaybeUninit<cbdata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbdata>(),
        16usize,
        concat!("Size of: ", stringify!(cbdata))
    );
    assert_eq!(
        ::std::mem::align_of::<cbdata>(),
        8usize,
        concat!("Alignment of ", stringify!(cbdata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbdata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbdata),
            "::",
            stringify!(data)
        )
    );
}
impl Default for cbdata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VT_make_python_cbdata(cbd: cbdata_t) -> *mut _object;
}
extern "C" {
    pub fn VT_make_cbdata_from_python(pyobj: *mut _object) -> cbdata_t;
}
extern "C" {
    pub fn VT_revexec_available() -> bool;
}
extern "C" {
    pub fn VT_revexec_active() -> bool;
}
extern "C" {
    pub fn VT_in_the_past() -> bool;
}
pub const revexec_pos_t_Sim_Reverse_Limit: revexec_pos_t = 0;
pub const revexec_pos_t_Sim_End_Of_Future: revexec_pos_t = 1;
pub type revexec_pos_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn VT_revexec_steps(cpu: *mut conf_object_t, where_: revexec_pos_t) -> pc_step_t;
}
extern "C" {
    pub fn VT_revexec_cycles(cpu: *mut conf_object_t, where_: revexec_pos_t) -> cycles_t;
}
extern "C" {
    pub fn VT_get_rewind_overhead(cpu: *mut conf_object_t, abscount: pc_step_t) -> pc_step_t;
}
extern "C" {
    pub fn VT_reverse(count: pc_step_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_reverse_cpu(clock: *mut conf_object_t, count: pc_step_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_skipto_step(clock: *mut conf_object_t, count: pc_step_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_skipto_cycle(clock: *mut conf_object_t, count: cycles_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_skipto_bookmark(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_rewind(cpu: *mut conf_object_t, abscount: pc_step_t) -> ::std::os::raw::c_int;
}
#[doc = " micro checkpoint id"]
pub const micro_checkpoint_flags_t_Sim_MC_ID_User: micro_checkpoint_flags_t = 0;
#[doc = " micro checkpoint id"]
pub const micro_checkpoint_flags_t_Sim_MC_ID_Breakpoint: micro_checkpoint_flags_t = 1;
#[doc = " micro checkpoint id"]
pub const micro_checkpoint_flags_t_Sim_MC_ID_Tmp: micro_checkpoint_flags_t = 2;
#[doc = " micro checkpoint id"]
pub const micro_checkpoint_flags_t_Sim_MC_ID_N_States: micro_checkpoint_flags_t = 3;
#[doc = " micro checkpoint id"]
pub const micro_checkpoint_flags_t_Sim_MC_ID_Last_States: micro_checkpoint_flags_t = 4;
#[doc = " micro checkpoint id"]
pub const micro_checkpoint_flags_t_Sim_MC_ID_Mask: micro_checkpoint_flags_t = 255;
#[doc = " type of micro checkpoint"]
pub const micro_checkpoint_flags_t_Sim_MC_Persistent: micro_checkpoint_flags_t = 256;
#[doc = " may be deleted automatically"]
pub const micro_checkpoint_flags_t_Sim_MC_Automatic: micro_checkpoint_flags_t = 512;
pub type micro_checkpoint_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn VT_save_micro_checkpoint(
        name: *const ::std::os::raw::c_char,
        flags: micro_checkpoint_flags_t,
    );
}
extern "C" {
    pub fn VT_restore_micro_checkpoint(index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn VT_delete_micro_checkpoint(index: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " VT_in_time_order() is used to handle events (e.g. breakpoint haps) in\nstrict time order. This is particularly useful when simics reverses since\nthere is absolutely no guarantee that haps are invoked in reverse time\norder.\n\nVT_c_in_time_order() is similar to VT_in_time_order(), except the buffer\npointed to by the data argument is copied and later passed to the callback.\nThe callback should not release the data or cache pointers to it since\nthe space will be reused automatically.\n\nThe callback may raise an exception, e.g. by calling SIM_break_simulation,\nto signal that the simulation should be stopped."]
    pub fn VT_in_time_order(
        handler: ::std::option::Option<unsafe extern "C" fn(data: cbdata_call_t)>,
        data: cbdata_register_t,
    );
}
pub type time_ordered_handler_t = ::std::option::Option<
    unsafe extern "C" fn(obj: *mut conf_object_t, param: int64, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn VT_c_in_time_order(
        obj: *mut conf_object_t,
        handler: time_ordered_handler_t,
        param: int64,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    );
}
extern "C" {
    #[doc = " used to prevent reverse execution from touching certain classes/attributes"]
    pub fn VT_revexec_ignore_class(class_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " prevent reversal past this point in time"]
    pub fn VT_revexec_barrier();
}
extern "C" {
    #[doc = " Get attribute attribute."]
    pub fn SIM_get_attribute_attributes(
        cls: *mut conf_class_t,
        attr: *const ::std::os::raw::c_char,
    ) -> attr_attr_t;
}
extern "C" {
    #[doc = " return 1 if the class has an attribute with name attr"]
    pub fn SIM_class_has_attribute(
        cls: *mut conf_class_t,
        attr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SIM_class_port(
        cls: *const conf_class_t,
        portname: *const ::std::os::raw::c_char,
    ) -> *mut conf_class_t;
}
extern "C" {
    pub fn VT_get_port_classes(cls: *mut conf_class_t) -> attr_value_t;
}
extern "C" {
    pub fn VT_get_port_obj_desc(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_get_class_description(cls: *const conf_class_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_get_class_short_desc(cls: *const conf_class_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_get_class_kind(cls: *const conf_class_t) -> class_kind_t;
}
extern "C" {
    #[doc = " Get object (returns NULL if object not found)."]
    pub fn SIM_get_object(name: *const ::std::os::raw::c_char) -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_get_object_by_name(name: *const ::std::os::raw::c_char) -> *mut conf_object_t;
}
extern "C" {
    #[doc = " Delete object."]
    pub fn SIM_delete_object(obj: *mut conf_object_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_delete_objects(object_list: attr_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get attribute from object."]
    pub fn SIM_get_attribute(
        obj: *mut conf_object_t,
        name: *const ::std::os::raw::c_char,
    ) -> attr_value_t;
}
extern "C" {
    pub fn SIM_get_attribute_idx(
        obj: *mut conf_object_t,
        name: *const ::std::os::raw::c_char,
        index: *mut attr_value_t,
    ) -> attr_value_t;
}
extern "C" {
    #[doc = " Get attribute from class."]
    pub fn SIM_get_class_attribute(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
    ) -> attr_value_t;
}
extern "C" {
    pub fn SIM_get_class_attribute_idx(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        index: *mut attr_value_t,
    ) -> attr_value_t;
}
extern "C" {
    #[doc = " Set attribute in object. Returns error code on failure (0 == ok)."]
    pub fn SIM_set_attribute(
        obj: *mut conf_object_t,
        name: *const ::std::os::raw::c_char,
        value: *mut attr_value_t,
    ) -> set_error_t;
}
extern "C" {
    pub fn SIM_set_attribute_idx(
        obj: *mut conf_object_t,
        name: *const ::std::os::raw::c_char,
        index: *mut attr_value_t,
        value: *mut attr_value_t,
    ) -> set_error_t;
}
extern "C" {
    pub fn SIM_set_attribute_default(
        obj: *mut conf_object_t,
        name: *const ::std::os::raw::c_char,
        value: attr_value_t,
    ) -> set_error_t;
}
extern "C" {
    #[doc = " Set attribute in class. Returns error code on failure (0 == ok)."]
    pub fn SIM_set_class_attribute(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        value: *mut attr_value_t,
    ) -> set_error_t;
}
extern "C" {
    pub fn SIM_set_class_attribute_idx(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        index: *mut attr_value_t,
        value: *mut attr_value_t,
    ) -> set_error_t;
}
extern "C" {
    pub fn VT_get_attributes(cls: *mut conf_class_t) -> attr_value_t;
}
extern "C" {
    pub fn VT_get_interfaces(cls: *mut conf_class_t) -> attr_value_t;
}
extern "C" {
    pub fn VT_get_port_interfaces(cls: *mut conf_class_t) -> attr_value_t;
}
extern "C" {
    pub fn VT_get_class_extensions(cls: *mut conf_class_t) -> attr_value_t;
}
extern "C" {
    pub fn VT_get_attribute_type(
        cls: *mut conf_class_t,
        attr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_rename_object(obj: *mut conf_object_t, newname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_set_object_checkpointable(obj: *mut conf_object_t, checkpointable: bool);
}
extern "C" {
    pub fn VT_object_checkpointable(obj: *mut conf_object_t) -> bool;
}
extern "C" {
    pub fn VT_set_delete_protection(obj: *mut conf_object_t, on: bool);
}
extern "C" {
    pub fn VT_add_permanent_object(obj: *mut conf_object_t);
}
extern "C" {
    pub fn SIM_create_object(
        cls: *mut conf_class_t,
        name: *const ::std::os::raw::c_char,
        attrs: attr_value_t,
    ) -> *mut conf_object_t;
}
extern "C" {
    #[doc = " Return vector with all objects."]
    pub fn SIM_get_all_objects() -> attr_value_t;
}
extern "C" {
    pub fn SIM_get_all_classes() -> attr_value_t;
}
extern "C" {
    #[doc = " Return vector with objects implementing all the ifaces"]
    pub fn VT_get_all_objects_impl(ifaces: attr_value_t) -> attr_value_t;
}
extern "C" {
    pub fn VT_get_all_instances(cls: *mut conf_class_t) -> attr_value_t;
}
extern "C" {
    pub fn DBG_check_typing_system(
        type_: *const ::std::os::raw::c_char,
        val: *mut attr_value_t,
    ) -> ::std::os::raw::c_int;
}
pub type cmd_line_id_t = ::std::os::raw::c_int;
pub const cmd_line_key_t_Cmd_Line_Key_Left: cmd_line_key_t = 0;
pub const cmd_line_key_t_Cmd_Line_Key_Right: cmd_line_key_t = 1;
pub const cmd_line_key_t_Cmd_Line_Key_Up: cmd_line_key_t = 2;
pub const cmd_line_key_t_Cmd_Line_Key_Down: cmd_line_key_t = 3;
pub const cmd_line_key_t_Cmd_Line_Key_PgUp: cmd_line_key_t = 4;
pub const cmd_line_key_t_Cmd_Line_Key_PgDn: cmd_line_key_t = 5;
pub const cmd_line_key_t_Cmd_Line_Key_Home: cmd_line_key_t = 6;
pub const cmd_line_key_t_Cmd_Line_Key_End: cmd_line_key_t = 7;
pub const cmd_line_key_t_Cmd_Line_Key_Back: cmd_line_key_t = 8;
pub const cmd_line_key_t_Cmd_Line_Key_Tab: cmd_line_key_t = 9;
pub const cmd_line_key_t_Cmd_Line_Key_Enter: cmd_line_key_t = 10;
pub const cmd_line_key_t_Cmd_Line_Key_Del: cmd_line_key_t = 11;
pub const cmd_line_key_t_Cmd_Line_Key_Ins: cmd_line_key_t = 12;
pub const cmd_line_key_t_Cmd_Line_Key_F1: cmd_line_key_t = 13;
pub const cmd_line_key_t_Cmd_Line_Key_F2: cmd_line_key_t = 14;
pub const cmd_line_key_t_Cmd_Line_Key_F3: cmd_line_key_t = 15;
pub const cmd_line_key_t_Cmd_Line_Key_F4: cmd_line_key_t = 16;
pub const cmd_line_key_t_Cmd_Line_Key_F5: cmd_line_key_t = 17;
pub const cmd_line_key_t_Cmd_Line_Key_F6: cmd_line_key_t = 18;
pub const cmd_line_key_t_Cmd_Line_Key_F7: cmd_line_key_t = 19;
pub const cmd_line_key_t_Cmd_Line_Key_F8: cmd_line_key_t = 20;
pub const cmd_line_key_t_Cmd_Line_Key_F9: cmd_line_key_t = 21;
pub const cmd_line_key_t_Cmd_Line_Key_F10: cmd_line_key_t = 22;
pub const cmd_line_key_t_Cmd_Line_Key_F11: cmd_line_key_t = 23;
pub const cmd_line_key_t_Cmd_Line_Key_F12: cmd_line_key_t = 24;
#[doc = " This enum must be kept in sync with the array simicsToSwt in\n SimicsKeyTranslator.java, otherwise the Eclipse Console view\n will break."]
pub type cmd_line_key_t = ::std::os::raw::c_uint;
pub const cmd_line_mod_t_Cmd_Line_Mod_None: cmd_line_mod_t = 0;
pub const cmd_line_mod_t_Cmd_Line_Mod_Shift: cmd_line_mod_t = 1;
pub const cmd_line_mod_t_Cmd_Line_Mod_Ctrl: cmd_line_mod_t = 2;
pub const cmd_line_mod_t_Cmd_Line_Mod_Alt: cmd_line_mod_t = 4;
pub type cmd_line_mod_t = ::std::os::raw::c_uint;
pub type cmd_line_frontend_interface_t = cmd_line_frontend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cmd_line_frontend_interface {
    #[doc = " write a character on the command line at the current cursor\nposition, overwriting any existing character there"]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, str_: *const ::std::os::raw::c_char),
    >,
    #[doc = " deletes the line from current position to the end of the line"]
    pub delete_line: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " moves the cursor <param>num</param> characters to the left."]
    pub cursor_left: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, num: ::std::os::raw::c_int),
    >,
    #[doc = " moves the cursor <param>num</param> characters to the right."]
    pub cursor_right: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, num: ::std::os::raw::c_int),
    >,
    #[doc = " clears the screen and moves the cursor to position 0. Optional,\nmay be NULL if not implemented."]
    pub clear_screen: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " called when the prompt has been printed with the position on\nthe line of the first non-prompt character. Optional, may be\nnull if not implemented"]
    pub prompt_end: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, pos: ::std::os::raw::c_int),
    >,
    #[doc = " optional"]
    pub bell: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_cmd_line_frontend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cmd_line_frontend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmd_line_frontend_interface>(),
        64usize,
        concat!("Size of: ", stringify!(cmd_line_frontend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cmd_line_frontend_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cmd_line_frontend_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(delete_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_left) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(cursor_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_right) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(cursor_right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_screen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(clear_screen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prompt_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(prompt_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_frontend_interface),
            "::",
            stringify!(bell)
        )
    );
}
pub type cmd_line_selection_interface_t = cmd_line_selection_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cmd_line_selection_interface {
    pub new_selection: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ),
    >,
    pub to_clipboard: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, str_: *const ::std::os::raw::c_char),
    >,
}
#[test]
fn bindgen_test_layout_cmd_line_selection_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cmd_line_selection_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmd_line_selection_interface>(),
        16usize,
        concat!("Size of: ", stringify!(cmd_line_selection_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cmd_line_selection_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cmd_line_selection_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_selection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_selection_interface),
            "::",
            stringify!(new_selection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_clipboard) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmd_line_selection_interface),
            "::",
            stringify!(to_clipboard)
        )
    );
}
extern "C" {
    #[doc = " The following functions are internal and will probably be replaced\nby a \"cmd_line\" interface."]
    pub fn VT_command_line_create(
        obj: *mut conf_object_t,
        interactive: bool,
        primary: bool,
    ) -> cmd_line_id_t;
}
extern "C" {
    pub fn VT_command_line_delete(id: cmd_line_id_t);
}
extern "C" {
    pub fn VT_command_line_new_position(id: cmd_line_id_t, pos: ::std::os::raw::c_int);
}
extern "C" {
    pub fn VT_command_line_new_selection(
        id: cmd_line_id_t,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VT_command_line_to_clipboard(id: cmd_line_id_t, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VT_command_line_key(id: cmd_line_id_t, mod_: cmd_line_mod_t, key: cmd_line_key_t);
}
extern "C" {
    pub fn VT_command_line_set_size(
        arg1: cmd_line_id_t,
        cols: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    );
}
pub type terminal_server_interface_t = terminal_server_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct terminal_server_interface {
    pub write: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, str_: *const ::std::os::raw::c_char),
    >,
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            left: ::std::os::raw::c_int,
            right: ::std::os::raw::c_int,
        ),
    >,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_terminal_server_interface() {
    const UNINIT: ::std::mem::MaybeUninit<terminal_server_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<terminal_server_interface>(),
        24usize,
        concat!("Size of: ", stringify!(terminal_server_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<terminal_server_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(terminal_server_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_server_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_server_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_server_interface),
            "::",
            stringify!(disconnect)
        )
    );
}
pub type terminal_client_interface_t = terminal_client_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct terminal_client_interface {
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            id: ::std::os::raw::c_int,
            str_: *const ::std::os::raw::c_char,
        ),
    >,
    pub disconnect: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_terminal_client_interface() {
    const UNINIT: ::std::mem::MaybeUninit<terminal_client_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<terminal_client_interface>(),
        16usize,
        concat!("Size of: ", stringify!(terminal_client_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<terminal_client_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(terminal_client_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_client_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_client_interface),
            "::",
            stringify!(disconnect)
        )
    );
}
#[doc = " <add-type id=\"hap_handle_t def\"><ndx>hap_handle_t</ndx></add-type>"]
pub type hap_handle_t = ::std::os::raw::c_int;
pub type obj_hap_func_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type hap_flags_t = ::std::os::raw::c_int;
extern "C" {
    pub fn SIM_get_all_hap_types() -> attr_value_t;
}
extern "C" {
    pub fn SIM_hap_add_callback(
        hap: *const ::std::os::raw::c_char,
        func: obj_hap_func_t,
        data: *mut lang_void,
    ) -> hap_handle_t;
}
extern "C" {
    pub fn SIM_hap_add_callback_index(
        hap: *const ::std::os::raw::c_char,
        func: obj_hap_func_t,
        data: *mut lang_void,
        index: int64,
    ) -> hap_handle_t;
}
extern "C" {
    pub fn SIM_hap_add_callback_range(
        hap: *const ::std::os::raw::c_char,
        func: obj_hap_func_t,
        data: *mut lang_void,
        start: int64,
        end: int64,
    ) -> hap_handle_t;
}
extern "C" {
    pub fn SIM_hap_add_callback_obj(
        hap: *const ::std::os::raw::c_char,
        obj: *mut conf_object_t,
        flags: hap_flags_t,
        func: obj_hap_func_t,
        data: *mut lang_void,
    ) -> hap_handle_t;
}
extern "C" {
    pub fn SIM_hap_add_callback_obj_index(
        hap: *const ::std::os::raw::c_char,
        obj: *mut conf_object_t,
        flags: hap_flags_t,
        func: obj_hap_func_t,
        data: *mut lang_void,
        index: int64,
    ) -> hap_handle_t;
}
extern "C" {
    pub fn SIM_hap_add_callback_obj_range(
        hap: *const ::std::os::raw::c_char,
        obj: *mut conf_object_t,
        flags: hap_flags_t,
        func: obj_hap_func_t,
        data: *mut lang_void,
        start: int64,
        end: int64,
    ) -> hap_handle_t;
}
extern "C" {
    pub fn SIM_hap_delete_callback(
        hap: *const ::std::os::raw::c_char,
        func: obj_hap_func_t,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_hap_delete_callback_obj(
        hap: *const ::std::os::raw::c_char,
        obj: *mut conf_object_t,
        func: obj_hap_func_t,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_hap_delete_callback_id(hap: *const ::std::os::raw::c_char, handle: hap_handle_t);
}
extern "C" {
    pub fn SIM_hap_delete_callback_obj_id(
        hap: *const ::std::os::raw::c_char,
        obj: *mut conf_object_t,
        handle: hap_handle_t,
    );
}
#[doc = " when ready for reading/accept, or closed"]
pub const notify_mode_t_Sim_NM_Read: notify_mode_t = 0;
#[doc = " when ready for writing/connect"]
pub const notify_mode_t_Sim_NM_Write: notify_mode_t = 1;
pub type notify_mode_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn SIM_notify_on_descriptor(
        fd: ::std::os::raw::c_int,
        mode: notify_mode_t,
        run_in_thread: ::std::os::raw::c_int,
        callback: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_notify_on_socket(
        sock: socket_t,
        mode: notify_mode_t,
        run_in_thread: ::std::os::raw::c_int,
        callback: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_register_work(
        f: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_process_work(
        done: ::std::option::Option<
            unsafe extern "C" fn(done_data: *mut lang_void) -> ::std::os::raw::c_int,
        >,
        done_data: *mut lang_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_process_pending_work() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_post_local_work(
        cell: *mut conf_object_t,
        f: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_realtime_event(
        delay_ms: ::std::os::raw::c_uint,
        callback: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
        run_in_thread: ::std::os::raw::c_int,
        desc: *const ::std::os::raw::c_char,
    ) -> int64;
}
extern "C" {
    pub fn SIM_cancel_realtime_event(id: int64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_run_alone(
        f: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_thread_safe_callback(
        f: ::std::option::Option<unsafe extern "C" fn(data: *mut lang_void)>,
        data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_run_async_work(
        async_call: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut lang_void) -> *mut lang_void,
        >,
        async_ready: ::std::option::Option<
            unsafe extern "C" fn(async_ret: *mut lang_void, arg: *mut lang_void),
        >,
        arg: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_run_in_thread(
        f: ::std::option::Option<unsafe extern "C" fn(arg: *mut lang_void)>,
        arg: *mut lang_void,
    );
}
extern "C" {
    pub fn VT_domain_event_soon(
        domain: *mut conf_object_t,
        ec: *mut event_class_t,
        obj: *mut conf_object_t,
        param: *mut lang_void,
    );
}
extern "C" {
    pub fn VT_domain_event_at(
        domain: *mut conf_object_t,
        ec: *mut event_class_t,
        obj: *mut conf_object_t,
        clock: *mut conf_object_t,
        when: f64,
        param: *mut lang_void,
    );
}
extern "C" {
    pub fn VT_cross_cell_call(
        f: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, arg: *mut lang_void),
        >,
        obj: *mut conf_object_t,
        arg: *mut lang_void,
    );
}
extern "C" {
    pub fn VT_process_cross_cell_calls();
}
extern "C" {
    pub fn VT_dispatch_async_events();
}
extern "C" {
    pub fn VT_run_outside_cell(
        f: ::std::option::Option<unsafe extern "C" fn(arg: *mut lang_void)>,
        arg: *mut lang_void,
    );
}
extern "C" {
    pub fn VT_add_telemetry_data(
        group: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut attr_value_t,
    );
}
extern "C" {
    pub fn VT_add_telemetry_data_str(
        group: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_add_telemetry_data_int(
        group: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: uint64,
    );
}
extern "C" {
    pub fn VT_add_telemetry_data_bool(
        group: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: bool,
    );
}
pub type telemetry_manager_interface_t = telemetry_manager_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct telemetry_manager_interface {
    pub add_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            group: *const ::std::os::raw::c_char,
            key: *const ::std::os::raw::c_char,
            value: *mut attr_value_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_telemetry_manager_interface() {
    const UNINIT: ::std::mem::MaybeUninit<telemetry_manager_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<telemetry_manager_interface>(),
        8usize,
        concat!("Size of: ", stringify!(telemetry_manager_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<telemetry_manager_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(telemetry_manager_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_manager_interface),
            "::",
            stringify!(add_data)
        )
    );
}
extern "C" {
    pub fn SIM_write(
        src: *const ::std::os::raw::c_void,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_flush() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_puts(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_putchar(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " pr is just an alias for SIM_printf"]
    pub fn pr(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_printf_vararg(
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_write_rev(
        src: *const ::std::os::raw::c_void,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pr_rev(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_revexec_divert_output(divert: ::std::os::raw::c_int, discard: ::std::os::raw::c_int);
}
pub type output_handler_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut lang_void, src: *const ::std::os::raw::c_char, length: usize),
>;
extern "C" {
    pub fn SIM_add_output_handler(func: output_handler_t, user_data: *mut lang_void);
}
extern "C" {
    pub fn SIM_remove_output_handler(func: output_handler_t, user_data: *mut lang_void);
}
extern "C" {
    pub fn SIM_set_quiet(quiet: bool);
}
extern "C" {
    pub fn SIM_get_quiet() -> bool;
}
extern "C" {
    pub fn SIM_set_verbose(verbose: bool);
}
extern "C" {
    pub fn SIM_get_verbose() -> bool;
}
extern "C" {
    pub fn VT_real_network_warnings();
}
extern "C" {
    pub fn VT_use_ipv4() -> bool;
}
pub const sim_version_t_SIM_VERSION_7: sim_version_t = 7000;
pub const sim_version_t_SIM_VERSION_6: sim_version_t = 6000;
pub const sim_version_t_SIM_VERSION_5: sim_version_t = 5000;
pub const sim_version_t_SIM_VERSION_4_8: sim_version_t = 4500;
#[doc = " Build ID for initial major versions. Available in DML and Python."]
pub type sim_version_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbuffer {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"dbuffer_t def\"></add-type>"]
pub type dbuffer_t = dbuffer;
extern "C" {
    #[doc = " Get a new buffer"]
    pub fn new_dbuffer() -> *mut dbuffer_t;
}
extern "C" {
    #[doc = " Release a buffer.  The buffer should not be freed in any other\nway."]
    pub fn dbuffer_free(dbuffer: *mut dbuffer_t);
}
extern "C" {
    #[doc = " Get the length"]
    pub fn dbuffer_len(dbuffer: *const dbuffer_t) -> usize;
}
extern "C" {
    #[doc = " Add static data.  This will make the buffer reference the data\n pointed to directly, without making a copy.\n\n If the 'adopt' flag is true, the control of the data block is\n transferred to the dbuffer.  It is assumed to be a MM_MALLOCed\n block that will be MM_FREEd when the dbuffer is freed.\n\n If the 'adopt' flag is false, the dbuffer will not free the\n memory. Instead it is up to the caller to free the memory, but it\n must not do so before the dbuffer is freed.  Actually, this\n reference could be copied to other dbuffers, so great care has to\n be taken.  This should only be used for buffers that will only be\n read, since it hard to know if a write operation will actually\n write to the buffer or to a copy."]
    pub fn dbuffer_append_external_data(
        dbuffer: *mut dbuffer_t,
        data: *mut ::std::os::raw::c_void,
        len: usize,
        adopt: bool,
    ) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_prepend_external_data(
        dbuffer: *mut dbuffer_t,
        data: *mut ::std::os::raw::c_void,
        len: usize,
        adopt: bool,
    ) -> *mut uint8;
}
extern "C" {
    #[doc = " Copy from one buffer to another."]
    pub fn dbuffer_copy_append(dst: *mut dbuffer_t, src: *mut dbuffer_t, offset: usize, len: usize);
}
extern "C" {
    pub fn dbuffer_copy_prepend(
        dst: *mut dbuffer_t,
        src: *mut dbuffer_t,
        offset: usize,
        len: usize,
    );
}
extern "C" {
    #[doc = " Add a repeating byte value"]
    pub fn dbuffer_append_value(
        dbuffer: *mut dbuffer_t,
        value: ::std::os::raw::c_int,
        len: usize,
    ) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_prepend_value(
        dbuffer: *mut dbuffer_t,
        value: ::std::os::raw::c_int,
        len: usize,
    ) -> *mut uint8;
}
extern "C" {
    #[doc = " Add uninitialized memory"]
    pub fn dbuffer_append(dbuffer: *mut dbuffer_t, len: usize) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_prepend(dbuffer: *mut dbuffer_t, len: usize) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_insert(dbuffer: *mut dbuffer_t, offset: usize, len: usize) -> *mut uint8;
}
extern "C" {
    #[doc = " Make the buffer smaller"]
    pub fn dbuffer_remove(dbuffer: *mut dbuffer_t, offset: usize, remove_len: usize);
}
extern "C" {
    pub fn dbuffer_remove_head(dbuffer: *mut dbuffer_t, remove_len: usize);
}
extern "C" {
    pub fn dbuffer_remove_tail(dbuffer: *mut dbuffer_t, remove_len: usize);
}
extern "C" {
    #[doc = " The pointer returned by dbuffer_read() may point to memory shared\nwith other buffers, and should not be written to."]
    pub fn dbuffer_read(dbuffer: *mut dbuffer_t, offset: usize, len: usize) -> *const uint8;
}
extern "C" {
    pub fn dbuffer_read_some(
        dbuffer: *mut dbuffer_t,
        offset: usize,
        len: usize,
        actual_len: *mut usize,
    ) -> *const uint8;
}
extern "C" {
    pub fn dbuffer_read_all(dbuffer: *mut dbuffer_t) -> *const uint8;
}
extern "C" {
    #[doc = " A buffer returned by dbuffer_update() is not used by any other\ndbuffer_t and can be freely read from or written to."]
    pub fn dbuffer_update(dbuffer: *mut dbuffer_t, offset: usize, len: usize) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_update_some(
        dbuffer: *mut dbuffer_t,
        offset: usize,
        len: usize,
        actual_len: *mut usize,
    ) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_update_all(dbuffer: *mut dbuffer_t) -> *mut uint8;
}
extern "C" {
    #[doc = " A buffer returned by dbuffer_replace() is not used by any other\ndbuffer_t and may contain junk.  This function should only be used\nwhen the whole buffer section will be overwritten with new data."]
    pub fn dbuffer_replace(dbuffer: *mut dbuffer_t, offset: usize, len: usize) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_replace_some(
        dbuffer: *mut dbuffer_t,
        offset: usize,
        len: usize,
        actual_len: *mut usize,
    ) -> *mut uint8;
}
extern "C" {
    pub fn dbuffer_replace_all(dbuffer: *mut dbuffer_t) -> *mut uint8;
}
extern "C" {
    #[doc = " Make a full copy of another buffer"]
    pub fn dbuffer_clone(dbuffer: *mut dbuffer_t) -> *mut dbuffer_t;
}
extern "C" {
    #[doc = " Split a buffer in two.  The data after 'offset' is left in the old\ndbuffer, and the data before 'offset' is returned in a newly\nallocated dbuffer."]
    pub fn dbuffer_split(dbuffer: *mut dbuffer_t, offset: usize) -> *mut dbuffer_t;
}
extern "C" {
    pub fn dbuffer_clear(dbuffer: *mut dbuffer_t);
}
extern "C" {
    pub fn dbuffer_set(dbuffer: *mut dbuffer_t, val: ::std::os::raw::c_int, len: usize);
}
extern "C" {
    pub fn dbuffer_bytes(dbuffer: *mut dbuffer_t) -> bytes_t;
}
pub type frags_t = frags;
pub type frags_it_t = frags_it;
#[doc = " The structures should never be used directly. Only use the accessor\n functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct frags_frag {
    pub start: *const uint8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_frags_frag() {
    const UNINIT: ::std::mem::MaybeUninit<frags_frag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frags_frag>(),
        16usize,
        concat!("Size of: ", stringify!(frags_frag))
    );
    assert_eq!(
        ::std::mem::align_of::<frags_frag>(),
        8usize,
        concat!("Alignment of ", stringify!(frags_frag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frags_frag),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frags_frag),
            "::",
            stringify!(len)
        )
    );
}
impl Default for frags_frag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structures should never be used directly. Only use the accessor\n functions."]
pub type frags_frag_t = frags_frag;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct frags {
    pub len: usize,
    pub nfrags: ::std::os::raw::c_uint,
    pub fraglist: [frags_frag_t; 8usize],
}
#[test]
fn bindgen_test_layout_frags() {
    const UNINIT: ::std::mem::MaybeUninit<frags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frags>(),
        144usize,
        concat!("Size of: ", stringify!(frags))
    );
    assert_eq!(
        ::std::mem::align_of::<frags>(),
        8usize,
        concat!("Alignment of ", stringify!(frags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frags),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nfrags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frags),
            "::",
            stringify!(nfrags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fraglist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frags),
            "::",
            stringify!(fraglist)
        )
    );
}
impl Default for frags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct frags_it {
    pub frag: *const frags_frag,
    pub skip: usize,
    pub left: usize,
}
#[test]
fn bindgen_test_layout_frags_it() {
    const UNINIT: ::std::mem::MaybeUninit<frags_it> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frags_it>(),
        24usize,
        concat!("Size of: ", stringify!(frags_it))
    );
    assert_eq!(
        ::std::mem::align_of::<frags_it>(),
        8usize,
        concat!("Alignment of ", stringify!(frags_it))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frags_it),
            "::",
            stringify!(frag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frags_it),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frags_it),
            "::",
            stringify!(left)
        )
    );
}
impl Default for frags_it {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " <add-fun id=\"frags_api\">\n<short>extract the contents of a <type>frags_t</type></short>\n\nCopy the whole contents of <param>buf</param> to <param>vdst</param>. The\ndestination buffer <param>vdst</param> should be large enough to contain\nall data in <param>buf</param>.\n\nThis function is completely equivalent to <fun>frags_extract_slice()</fun>\nwith an <param>offset</param> and a <param>length</param> covering the\nwhole contents of the <type>frags_t</type>, and is provided for\nconvenience.\n\n<di name=\"RETURN VALUE\">None</di>\n<di name=\"EXECUTION CONTEXT\">Cell Context</di>\n<di name=\"EXAMPLE\">\n<insert id=\"fg_extract\"/>\n</di>\n<di name=\"SEE ALSO\">\n<fun>frags_extract_8</fun>, <fun>frags_extract_slice</fun>,\n<fun>frags_extract_alloc</fun>, <fun>frags_extract_slice_alloc</fun>\n</di>\n\n</add-fun>"]
    pub fn frags_extract(buf: *const frags_t, vdst: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " <add-fun id=\"frags_api\">\n<short>extract a slice of a <type>frags_t</type></short>\n\nCopy a slice of size <param>len</param>, starting at offset\n<param>offset</param>, of the contents of <param>buf</param>, to\n<param>vdst</param>. The destination buffer <param>vdst</param> should be\nable to contain at least <param>len</param> bytes.\n\n<di name=\"RETURN VALUE\">None</di>\n<di name=\"EXECUTION CONTEXT\">Cell Context</di>\n<di name=\"EXAMPLE\">\n<insert id=\"fg_extract_slice\"/>\n</di>\n<di name=\"SEE ALSO\">\n<fun>frags_extract_8</fun>, <fun>frags_extract</fun>,\n<fun>frags_extract_alloc</fun>, <fun>frags_extract_slice_alloc</fun>\n</di>\n\n</add-fun>"]
    pub fn frags_extract_slice(
        buf: *const frags_t,
        vdst: *mut ::std::os::raw::c_void,
        offset: usize,
        len: usize,
    );
}
extern "C" {
    #[doc = " <add-fun id=\"frags_api\">\n<short>return a copy of the contents of a <type>frags_t</type></short>\n\nReturn an allocated copy of the contents of <param>buf</param>. The buffer\nreturned is allocated with <fun>MM_MALLOC()</fun>, and its ownership is\npassed to the caller, which should free it when appropriate.\n\nThis function is equivalent to allocating a buffer of the correct size\nwith <fun>MM_MALLOC()</fun> followed by a call to\n<fun>frags_extract()</fun>, and is provided for convenience.\n\n<di name=\"RETURN VALUE\">A newly allocated copy of the contents</di>\n<di name=\"EXECUTION CONTEXT\">Cell Context</di>\n<di name=\"EXAMPLE\">\n<insert id=\"fg_extract_alloc\"/>\n</di>\n<di name=\"SEE ALSO\">\n<fun>frags_extract</fun>, <fun>frags_extract_slice</fun>,\n<fun>frags_extract_slice_alloc</fun>\n</di>\n\n</add-fun>"]
    pub fn frags_extract_alloc(buf: *const frags_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " <add-fun id=\"frags_api\">\n<short>return a partial copy of the contents of a\n<type>frags_t</type></short>\n\nReturn an allocated copy of a slice of size <param>len</param>, starting\nat offset <param>offset</param>, of the contents of\n<param>buf</param>. The return value is allocated with\n<fun>MM_MALLOC()</fun>, and its ownership is passed to the caller, which\nshould free it when appropriate.\n\nThis function is equivalent to allocating a buffer of the correct size\nwith <fun>MM_MALLOC()</fun> followed by a call to\n<fun>frags_extract_slice()</fun>, and is provided for convenience.\n\n<di name=\"RETURN VALUE\">A newly allocated, partial copy of the data</di>\n<di name=\"EXECUTION CONTEXT\">Cell Context</di>\n<di name=\"EXAMPLE\">\n<insert id=\"fg_extract_slice_alloc\"/>\n</di>\n<di name=\"SEE ALSO\">\n<fun>frags_extract</fun>, <fun>frags_extract_slice</fun>,\n<fun>frags_extract_alloc</fun>\n</di>\n\n</add-fun>"]
    pub fn frags_extract_slice_alloc(
        buf: *const frags_t,
        offset: usize,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn VT_run_unrestricted_python(
        obj: *mut conf_object_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, param: *mut lang_void),
        >,
        user_data: *mut lang_void,
    );
}
extern "C" {
    pub fn SIM_run_unrestricted(
        obj: *mut conf_object_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(obj: *mut conf_object_t, param: *mut lang_void),
        >,
        user_data: *mut lang_void,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct duration_t {
    pub t: int64,
}
#[test]
fn bindgen_test_layout_duration_t() {
    const UNINIT: ::std::mem::MaybeUninit<duration_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duration_t>(),
        8usize,
        concat!("Size of: ", stringify!(duration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<duration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(duration_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duration_t),
            "::",
            stringify!(t)
        )
    );
}
extern "C" {
    pub fn signed_divide_128_by_64(
        dividend_high: int64,
        dividend_low: int64,
        divisor: int64,
        quotient: *mut int64,
        remainder: *mut int64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsigned_gcd(n: uint64, d: uint64) -> uint64;
}
extern "C" {
    pub fn unsigned_multiply_rational(
        num1: uint64,
        den1: uint64,
        num2: uint64,
        den2: uint64,
        result_num: *mut uint64,
        result_den: *mut uint64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct int128 {
    pub lo: uint64,
    pub hi: int64,
}
#[test]
fn bindgen_test_layout_int128() {
    const UNINIT: ::std::mem::MaybeUninit<int128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int128>(),
        16usize,
        concat!("Size of: ", stringify!(int128))
    );
    assert_eq!(
        ::std::mem::align_of::<int128>(),
        8usize,
        concat!("Alignment of ", stringify!(int128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int128),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int128),
            "::",
            stringify!(hi)
        )
    );
}
extern "C" {
    pub fn int128_from_double(dst: *mut int128, src: f64) -> bool;
}
extern "C" {
    pub fn int128_to_double(src: int128) -> f64;
}
extern "C" {
    pub fn int128_div_int64(a: int128, b: int64, q: *mut int128, r: *mut int64) -> bool;
}
extern "C" {
    pub fn int128_as_string(
        v: int128,
        buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " <add-type id=\"bigtime_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bigtime_t {
    pub val: int128,
}
#[test]
fn bindgen_test_layout_bigtime_t() {
    const UNINIT: ::std::mem::MaybeUninit<bigtime_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bigtime_t>(),
        16usize,
        concat!("Size of: ", stringify!(bigtime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bigtime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bigtime_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bigtime_t),
            "::",
            stringify!(val)
        )
    );
}
extern "C" {
    pub fn bigtime_mul(t: bigtime_t, factor: int64) -> bigtime_t;
}
extern "C" {
    pub fn bigtime_div_raw(t: bigtime_t, divisor: int64, exact: *mut bool) -> bigtime_t;
}
extern "C" {
    pub fn bigtime_div_floor(t: bigtime_t, divisor: int64) -> bigtime_t;
}
extern "C" {
    pub fn bigtime_to_attr(t: bigtime_t) -> attr_value_t;
}
extern "C" {
    pub fn bigtime_from_attr(a: attr_value_t) -> bigtime_t;
}
extern "C" {
    pub fn bigtime_as_string(
        t: bigtime_t,
        buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct local_time_t {
    #[doc = " The clock is an object which implements the cycle interface. The\ntime stamp given in this struct is only valid in the clocks' \"time\nspace\"."]
    pub clock: *mut conf_object_t,
    pub t: bigtime_t,
}
#[test]
fn bindgen_test_layout_local_time_t() {
    const UNINIT: ::std::mem::MaybeUninit<local_time_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<local_time_t>(),
        24usize,
        concat!("Size of: ", stringify!(local_time_t))
    );
    assert_eq!(
        ::std::mem::align_of::<local_time_t>(),
        8usize,
        concat!("Alignment of ", stringify!(local_time_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_time_t),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(local_time_t),
            "::",
            stringify!(t)
        )
    );
}
impl Default for local_time_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn local_time_to_attr(t: local_time_t) -> attr_value_t;
}
extern "C" {
    pub fn local_time_from_attr(val: attr_value_t) -> local_time_t;
}
extern "C" {
    pub fn local_time_as_string(v: local_time_t, str_: *mut ::std::os::raw::c_char);
}
pub type cycle_interface_t = cycle_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cycle_interface {
    pub get_cycle_count:
        ::std::option::Option<unsafe extern "C" fn(queue: *mut conf_object_t) -> cycles_t>,
    pub get_time: ::std::option::Option<unsafe extern "C" fn(queue: *mut conf_object_t) -> f64>,
    pub cycles_delta: ::std::option::Option<
        unsafe extern "C" fn(clock: *mut conf_object_t, when: f64) -> cycles_t,
    >,
    pub get_frequency:
        ::std::option::Option<unsafe extern "C" fn(queue: *mut conf_object_t) -> uint64>,
    pub post_cycle: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            cycles: cycles_t,
            user_data: *mut lang_void,
        ),
    >,
    pub post_time: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            seconds: f64,
            user_data: *mut lang_void,
        ),
    >,
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ),
    >,
    pub find_next_cycle: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ) -> cycles_t,
    >,
    pub find_next_time: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ) -> f64,
    >,
    pub events:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    #[doc = " new picoseconds based functions"]
    pub get_time_in_ps:
        ::std::option::Option<unsafe extern "C" fn(queue: *mut conf_object_t) -> local_time_t>,
    pub cycles_delta_from_ps: ::std::option::Option<
        unsafe extern "C" fn(clock: *mut conf_object_t, when: local_time_t) -> cycles_t,
    >,
    pub post_time_in_ps: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            picoseconds: duration_t,
            user_data: *mut lang_void,
        ),
    >,
    pub find_next_time_in_ps: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ) -> duration_t,
    >,
}
#[test]
fn bindgen_test_layout_cycle_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cycle_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cycle_interface>(),
        112usize,
        concat!("Size of: ", stringify!(cycle_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cycle_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cycle_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cycle_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(get_cycle_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(get_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycles_delta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(cycles_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_frequency) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(get_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_cycle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(post_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_time) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(post_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_next_cycle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(find_next_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_next_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(find_next_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_time_in_ps) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(get_time_in_ps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycles_delta_from_ps) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(cycles_delta_from_ps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_time_in_ps) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(post_time_in_ps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_next_time_in_ps) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_interface),
            "::",
            stringify!(find_next_time_in_ps)
        )
    );
}
extern "C" {
    pub fn SIM_register_clock(
        cls: *mut conf_class_t,
        iface: *const cycle_interface_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_register_passive_clock(
        cls: *mut conf_class_t,
        iface: *const cycle_interface_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Normal informational message"]
pub const log_type_t_Sim_Log_Info: log_type_t = 0;
#[doc = " Simics error"]
pub const log_type_t_Sim_Log_Error: log_type_t = 1;
#[doc = " target program violates the specification"]
pub const log_type_t_Sim_Log_Spec_Violation: log_type_t = 2;
#[doc = " not implemented in Simics"]
pub const log_type_t_Sim_Log_Unimplemented: log_type_t = 3;
#[doc = " Critical error stopping Simics"]
pub const log_type_t_Sim_Log_Critical: log_type_t = 4;
#[doc = " Breakpoint trace messages"]
pub const log_type_t_Sim_Log_Trace: log_type_t = 5;
#[doc = " Do not use"]
pub const log_type_t_Sim_Log_Num_Types: log_type_t = 6;
#[doc = " <add-type id=\"log_type_t def\">\n</add-type>"]
pub type log_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct log_object {
    _unused: [u8; 0],
}
pub type log_object_t = log_object;
extern "C" {
    pub fn SIM_log_register_groups(
        cls: *mut conf_class_t,
        names: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_log_message(
        obj: *mut conf_object_t,
        level: ::std::os::raw::c_int,
        group_ids: ::std::os::raw::c_int,
        log_type: log_type_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_log_message64(
        obj: *mut conf_object_t,
        level: ::std::os::raw::c_int,
        group_ids: uint64,
        log_type: log_type_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_log_message(
        obj: *mut conf_object_t,
        level: ::std::os::raw::c_int,
        group_ids: uint64,
        log_type: log_type_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_critical_error(
        short_msg: *const ::std::os::raw::c_char,
        long_msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_log_error(
        dev: *mut conf_object_t,
        grp: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SIM_log_critical(
        dev: *mut conf_object_t,
        grp: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SIM_log_info(
        lvl: ::std::os::raw::c_int,
        dev: *mut conf_object_t,
        grp: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SIM_log_spec_violation(
        lvl: ::std::os::raw::c_int,
        dev: *mut conf_object_t,
        grp: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SIM_log_unimplemented(
        lvl: ::std::os::raw::c_int,
        dev: *mut conf_object_t,
        grp: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn VT_log_error(
        dev: *mut conf_object_t,
        grp: uint64,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn VT_log_critical(
        dev: *mut conf_object_t,
        grp: uint64,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn VT_log_info(
        lvl: ::std::os::raw::c_int,
        dev: *mut conf_object_t,
        grp: uint64,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn VT_log_spec_violation(
        lvl: ::std::os::raw::c_int,
        dev: *mut conf_object_t,
        grp: uint64,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn VT_log_unimplemented(
        lvl: ::std::os::raw::c_int,
        dev: *mut conf_object_t,
        grp: uint64,
        str_: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SIM_log_level(obj: *const conf_object_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SIM_set_log_level(obj: *mut conf_object_t, level: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SIM_is_restoring_state(obj: *mut conf_object_t) -> bool;
}
extern "C" {
    #[doc = " will return 1 while getting persistent attributes only"]
    pub fn VT_is_saving_persistent_data() -> bool;
}
extern "C" {
    pub fn VT_object_cell(obj: *mut conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_get_map_generation(obj: *mut conf_object_t) -> uint32;
}
extern "C" {
    pub fn VT_is_reversing() -> bool;
}
extern "C" {
    pub fn SIM_is_loading_micro_checkpoint(obj: *mut conf_object_t) -> bool;
}
pub const global_notifier_type_t_Sim_Global_Notify_Object_Delete: global_notifier_type_t = 100;
pub const global_notifier_type_t_Sim_Global_Notify_Objects_Finalized: global_notifier_type_t = 101;
#[doc = " <add id=\"global_notifier_type_t DOC\">\n<ndx>global_notifier_type_t</ndx>\n<name index=\"true\">global_notifier_type_t</name>\n<doc>\n<doc-item name=\"NAME\">global_notifier_type_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<smaller>\n<insert id=\"global_notifier_type_t def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThis enum is used to identify pre-defined global notifier. The\n<tt>Sim_Global_Notify_Object_Delete</tt> notifier is triggered by Simics\nwhen objects are being deleted. In the callback, objects are still fully\navailable, but <fun>SIM_marked_for_deletion</fun> can be used to determine\nif an object is being deleted.\n\nThe <tt>Sim_Global_Notify_Objects_Finalized</tt> notifier is triggered by\nSimics when new objects have been finalized, after their\n<tt>objects_finalized</tt> methods have been called.\n\nThe corresponding names used in e.g. <cmd>list-notifiers</cmd>\nare as follows:\n<ul>\n<li>\"global-object-delete\" (<var>Sim_Global_Notify_Object_Delete</var>)</li>\n<li>\"global-objects-finalized\" (<var>Sim_Global_Notify_Objects_Finalized</var>)</li>\n</ul>\n\n</doc-item>\n<doc-item name=\"SEE ALSO\">\n<fun>SIM_add_global_notifier</fun>,\n<fun>SIM_add_global_notifier_once</fun>,\n<fun>SIM_delete_global_notifier</fun>,\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"global_notifier_type_t def\"></add-type>"]
pub type global_notifier_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct global_notifier_callback {
    _unused: [u8; 0],
}
#[doc = " Consumer API"]
pub type global_notifier_callback_t = global_notifier_callback;
extern "C" {
    pub fn SIM_add_global_notifier(
        what: global_notifier_type_t,
        subscriber: *mut conf_object_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(subscriber: *mut conf_object_t, data: *mut lang_void),
        >,
        data: *mut lang_void,
    ) -> *mut global_notifier_callback_t;
}
extern "C" {
    pub fn SIM_add_global_notifier_once(
        what: global_notifier_type_t,
        subscriber: *mut conf_object_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(subscriber: *mut conf_object_t, data: *mut lang_void),
        >,
        data: *mut lang_void,
    ) -> *mut global_notifier_callback_t;
}
extern "C" {
    pub fn SIM_delete_global_notifier(handle: *mut global_notifier_callback_t);
}
pub type hap_type_t = ::std::os::raw::c_int;
extern "C" {
    pub fn SIM_hap_add_type(
        hap: *const ::std::os::raw::c_char,
        params: *const ::std::os::raw::c_char,
        param_desc: *const ::std::os::raw::c_char,
        index: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        unused: ::std::os::raw::c_int,
    ) -> hap_type_t;
}
extern "C" {
    pub fn SIM_hap_remove_type(hap: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SIM_hap_get_number(hap: *const ::std::os::raw::c_char) -> hap_type_t;
}
extern "C" {
    pub fn SIM_hap_get_name(hap: hap_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_hap_is_active(hap: hap_type_t) -> bool;
}
extern "C" {
    pub fn SIM_hap_is_active_obj(hap: hap_type_t, obj: *mut conf_object_t) -> bool;
}
extern "C" {
    pub fn SIM_hap_is_active_obj_idx(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        index: int64,
    ) -> bool;
}
extern "C" {
    pub fn SIM_c_hap_occurred(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        value: int64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_c_hap_occurred_vararg(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        value: int64,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_c_hap_occurred_always(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        value: int64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_c_hap_occurred_always_vararg(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        value: int64,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_hap_occurred(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        value: int64,
        list: *mut attr_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SIM_hap_occurred_always(
        hap: hap_type_t,
        obj: *mut conf_object_t,
        value: int64,
        list: *mut attr_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_hap_global_callback_ranges(hap: hap_type_t) -> attr_value_t;
}
pub const addr_space_t_Sim_Addr_Space_Conf: addr_space_t = 0;
pub const addr_space_t_Sim_Addr_Space_IO: addr_space_t = 1;
pub const addr_space_t_Sim_Addr_Space_Memory: addr_space_t = 2;
#[doc = " <add-type id=\"addr_space_t def\"><ndx>addr_space_t</ndx></add-type>"]
pub type addr_space_t = ::std::os::raw::c_uint;
pub const read_or_write_t_Sim_RW_Read: read_or_write_t = 0;
pub const read_or_write_t_Sim_RW_Write: read_or_write_t = 1;
#[doc = " <add id=\"read_or_write_t DOC\">\n<ndx>read_or_write_t</ndx>\n<name index=\"true\">read_or_write_t</name>\n<doc>\n<doc-item name=\"NAME\">read_or_write_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"read_or_write_t def\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\nWhether a memory access is a <i>read</i> (from memory) or a <i>write</i>\n(to memory).\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"read_or_write_t def\"></add-type>"]
pub type read_or_write_t = ::std::os::raw::c_uint;
pub const endianness_t_Sim_Endian_Target: endianness_t = 0;
pub const endianness_t_Sim_Endian_Host_From_BE: endianness_t = 1;
pub const endianness_t_Sim_Endian_Host_From_LE: endianness_t = 2;
#[doc = " <add id=\"endianness_t DOC\">\n<ndx>endianness_t</ndx>\n<name index=\"true\">endianness_t</name>\n<doc>\n<doc-item name=\"NAME\">endianness_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"endianness_t def\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\nSpecifies the endianness to use for certain memory operations. When\n<const>Sim_Endian_Target</const> is used, the data from memory is\ncopied without any endian conversion.\n<const>Sim_Endian_Host_From_BE</const> and\n<const>Sim_Endian_Host_From_LE</const> copies data between a\nbig-endian, or little-endian, memory and a host buffer.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"endianness_t def\"></add-type>"]
pub type endianness_t = ::std::os::raw::c_uint;
pub const swap_mode_Sim_Swap_None: swap_mode = 0;
pub const swap_mode_Sim_Swap_Bus: swap_mode = 1;
pub const swap_mode_Sim_Swap_Bus_Trans: swap_mode = 2;
pub const swap_mode_Sim_Swap_Trans: swap_mode = 3;
#[doc = " <add-type id=\"map_info_t def\"></add-type>"]
pub type swap_mode = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"map_info_t def\"></add-type>"]
pub use self::swap_mode as swap_mode_t;
#[doc = " <add id=\"map_info_t DOC\">\n<ndx>map_info_t</ndx>\n<ndx>swap_mode_t</ndx>\n<name index=\"true\">map_info_t</name>\n<doc>\n<doc-item name=\"NAME\">map_info_t, swap_mode_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<ndx>map_type_t</ndx>\n<smaller>\n<insert id=\"map_info_t def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThe <tt>map_info_t</tt> structure members have the following meaning:\n<ul>\n<li>\n<tt>base</tt>: The base address of the device mapping in the memory space.\n</li>\n<li>\n<tt>start</tt>: The address inside the device memory space where the mapping\nstarts.</li>\n<li><tt>length</tt>: The length of the mapped memory, in bytes.</li>\n<li><tt>function</tt>: Used to map the same object several times\nwith different functionality. Corresponds to the function argument used\nwhen mapping devices into a memory space.</li>\n<li>If the map target does not support large accesses, then\n<tt>align_size</tt> can be set to the maximum allowed size. Accesses\nspanning align boundaries will be split into several smaller\ntransactions. The align size must be a power of two, or zero (which\nmeans \"use the default value\": 8 for devices and 8192 for memory).</li>\n<li>Mappings with an align size of 2, 4, or 8 may set the\n<tt>reverse_endian</tt> field to a non zero value. This can be used to\nmodel bridges that perform byte swapping on a specific bus width.</li>\n</ul>\n\nIf both <tt>base</tt> and <tt>length</tt> are 0 the map will become a\n<tt>default_target</tt>.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"map_info_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct map_info {
    pub base: physical_address_t,
    pub start: physical_address_t,
    pub length: physical_address_t,
    pub function: ::std::os::raw::c_int,
    pub priority: int16,
    pub align_size: ::std::os::raw::c_int,
    pub reverse_endian: swap_mode_t,
}
#[test]
fn bindgen_test_layout_map_info() {
    const UNINIT: ::std::mem::MaybeUninit<map_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<map_info>(),
        40usize,
        concat!("Size of: ", stringify!(map_info))
    );
    assert_eq!(
        ::std::mem::align_of::<map_info>(),
        8usize,
        concat!("Alignment of ", stringify!(map_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).align_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(align_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_endian) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(map_info),
            "::",
            stringify!(reverse_endian)
        )
    );
}
impl Default for map_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"map_info_t DOC\">\n<ndx>map_info_t</ndx>\n<ndx>swap_mode_t</ndx>\n<name index=\"true\">map_info_t</name>\n<doc>\n<doc-item name=\"NAME\">map_info_t, swap_mode_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<ndx>map_type_t</ndx>\n<smaller>\n<insert id=\"map_info_t def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThe <tt>map_info_t</tt> structure members have the following meaning:\n<ul>\n<li>\n<tt>base</tt>: The base address of the device mapping in the memory space.\n</li>\n<li>\n<tt>start</tt>: The address inside the device memory space where the mapping\nstarts.</li>\n<li><tt>length</tt>: The length of the mapped memory, in bytes.</li>\n<li><tt>function</tt>: Used to map the same object several times\nwith different functionality. Corresponds to the function argument used\nwhen mapping devices into a memory space.</li>\n<li>If the map target does not support large accesses, then\n<tt>align_size</tt> can be set to the maximum allowed size. Accesses\nspanning align boundaries will be split into several smaller\ntransactions. The align size must be a power of two, or zero (which\nmeans \"use the default value\": 8 for devices and 8192 for memory).</li>\n<li>Mappings with an align size of 2, 4, or 8 may set the\n<tt>reverse_endian</tt> field to a non zero value. This can be used to\nmodel bridges that perform byte swapping on a specific bus width.</li>\n</ul>\n\nIf both <tt>base</tt> and <tt>length</tt> are 0 the map will become a\n<tt>default_target</tt>.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"map_info_t def\"></add-type>"]
pub type map_info_t = map_info;
pub const map_type_t_Sim_Map_Ram: map_type_t = 0;
pub const map_type_t_Sim_Map_Rom: map_type_t = 1;
pub const map_type_t_Sim_Map_IO: map_type_t = 2;
pub const map_type_t_Sim_Map_Port: map_type_t = 3;
#[doc = " pseudo - do not use"]
pub const map_type_t_Sim_Map_Translate: map_type_t = 256;
pub const map_type_t_Sim_Map_Translate_To_Space: map_type_t = 257;
pub const map_type_t_Sim_Map_Translate_To_Ram: map_type_t = 258;
pub const map_type_t_Sim_Map_Translate_To_Rom: map_type_t = 259;
#[doc = " <add-type id=\"map_type_t def\"></add-type>"]
pub type map_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"page_t def\"><ndx>page_t</ndx></add-type>"]
pub type page_t = page;
#[doc = " <add id=\"map_list_t DOC\">\n<ndx>map_list_t</ndx>\n<ndx>map_type_t</ndx>\n<name index=\"true\">map_list_t</name>\n<doc>\n<doc-item name=\"NAME\">map_list_t, map_type_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<ndx>map_type_t</ndx><ndx>map_info_t</ndx>\n<smaller>\n<insert id=\"map_type_t def\"/>\n<insert id=\"struct map_list def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThis data structure is used to pass information about the set of\nmappings a particular address in an address space contains.\n</doc-item>\n</doc>\n</add>\n<add-type id=\"struct map_list def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct map_list {
    pub map_type: map_type_t,
    pub object: *mut conf_object_t,
    pub port: *const ::std::os::raw::c_char,
    pub interface_ptr: *const ::std::os::raw::c_void,
    pub target_interface: *const ::std::os::raw::c_void,
    pub breakpoint_interface: *const ::std::os::raw::c_void,
    pub breakpoint_query_interface: *const ::std::os::raw::c_void,
    pub bridge_interface: *const ::std::os::raw::c_void,
    pub target_object: *mut conf_object_t,
    pub target_port: *const ::std::os::raw::c_char,
    pub bridge: *mut conf_object_t,
    pub map_info: map_info_t,
    #[doc = " not constant, use with caution"]
    pub map_size: physical_address_t,
    #[doc = " internal flag - should always be 0 !"]
    pub deleted: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_map_list() {
    const UNINIT: ::std::mem::MaybeUninit<map_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<map_list>(),
        144usize,
        concat!("Size of: ", stringify!(map_list))
    );
    assert_eq!(
        ::std::mem::align_of::<map_list>(),
        8usize,
        concat!("Alignment of ", stringify!(map_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(map_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_ptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(interface_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_interface) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(target_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).breakpoint_interface) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(breakpoint_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).breakpoint_query_interface) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(breakpoint_query_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bridge_interface) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(bridge_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_object) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(target_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_port) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(target_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bridge) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(bridge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_info) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(map_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_size) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(map_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deleted) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(map_list),
            "::",
            stringify!(deleted)
        )
    );
}
impl Default for map_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"map_list_t DOC\">\n<ndx>map_list_t</ndx>\n<ndx>map_type_t</ndx>\n<name index=\"true\">map_list_t</name>\n<doc>\n<doc-item name=\"NAME\">map_list_t, map_type_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<ndx>map_type_t</ndx><ndx>map_info_t</ndx>\n<smaller>\n<insert id=\"map_type_t def\"/>\n<insert id=\"struct map_list def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThis data structure is used to pass information about the set of\nmappings a particular address in an address space contains.\n</doc-item>\n</doc>\n</add>\n<add-type id=\"struct map_list def\"></add-type>"]
pub type map_list_t = map_list;
#[doc = " Type provided for backwards compatibility."]
pub type pseudo_exceptions_t = ::std::os::raw::c_int;
pub const exception_type_t_Sim_PE_Cancelled: exception_type_t = 1022;
pub const exception_type_t_Sim_PE_Async_Required: exception_type_t = 1023;
pub const exception_type_t_Sim_PE_Deferred: exception_type_t = 1024;
pub const exception_type_t_Sim_PE_No_Exception: exception_type_t = 1025;
pub const exception_type_t_Sim_PE_Silent_Break: exception_type_t = 1026;
pub const exception_type_t_Sim_PE_Stop_Request: exception_type_t = 1027;
pub const exception_type_t_Sim_PE_Inquiry_Outside_Memory: exception_type_t = 1028;
pub const exception_type_t_Sim_PE_Inquiry_Unhandled: exception_type_t = 1029;
pub const exception_type_t_Sim_PE_Execute_Outside_Memory: exception_type_t = 1030;
pub const exception_type_t_Sim_PE_IO_Not_Taken: exception_type_t = 1031;
pub const exception_type_t_Sim_PE_IO_Error: exception_type_t = 1032;
pub const exception_type_t_Sim_PE_Stall_Cpu: exception_type_t = 1033;
pub const exception_type_t_Sim_PE_Instruction_Finished: exception_type_t = 1034;
pub const exception_type_t_Sim_PE_Default_Semantics: exception_type_t = 1035;
pub const exception_type_t_Sim_PE_Ignore_Semantics: exception_type_t = 1036;
pub const exception_type_t_Sim_PE_Last: exception_type_t = 1037;
pub type exception_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn VT_describe_pseudo_exception(ex: pseudo_exceptions_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_describe_pseudo_exception(ex: exception_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_translation_changed(obj: *mut conf_object_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct granted_mem {
    _unused: [u8; 0],
}
#[doc = " Opaque type"]
pub type granted_mem_t = granted_mem;
#[doc = " <add-type id=\"direct_memory_handle_t\"></add-type>"]
pub type direct_memory_handle_t = *mut granted_mem_t;
#[doc = " <add id=\"direct_memory_t\">\n<ndx>direct_memory_t</ndx>\n<insert-upto text=\"direct_memory_t;\"/>\n</add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_t {
    pub data: *mut uint8,
    pub permission: access_t,
    pub inhibit: access_t,
}
#[test]
fn bindgen_test_layout_direct_memory_t() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_t>(),
        16usize,
        concat!("Size of: ", stringify!(direct_memory_t))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_t>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).permission) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_t),
            "::",
            stringify!(permission)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inhibit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_t),
            "::",
            stringify!(inhibit)
        )
    );
}
impl Default for direct_memory_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"direct_memory_ack_id_t\"></add-type>"]
pub type direct_memory_ack_id_t = uint64;
#[doc = " <add id=\"direct_memory_lookup_t\">\n<ndx>direct_memory_t</ndx>\n<insert-upto text=\"direct_memory_lookup_t;\"/>\n</add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_lookup_t {
    pub target: *mut conf_object_t,
    pub offs: uint64,
    #[doc = " conflicting breakpoints"]
    pub breakpoints: access_t,
    #[doc = " conflicting tracers"]
    pub tracers: access_t,
    #[doc = " handle valid for access"]
    pub access: access_t,
}
#[test]
fn bindgen_test_layout_direct_memory_lookup_t() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_lookup_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_lookup_t>(),
        32usize,
        concat!("Size of: ", stringify!(direct_memory_lookup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_lookup_t>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_lookup_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_t),
            "::",
            stringify!(offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).breakpoints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_t),
            "::",
            stringify!(breakpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracers) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_t),
            "::",
            stringify!(tracers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_t),
            "::",
            stringify!(access)
        )
    );
}
impl Default for direct_memory_lookup_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"direct_memory_tags_t\">\n<ndx>direct_memory_tags_t</ndx>\n<insert-upto text=\"direct_memory_tags_t;\"/>\n</add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_tags_t {
    pub data: *mut uint8,
    pub len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_direct_memory_tags_t() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_tags_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_tags_t>(),
        16usize,
        concat!("Size of: ", stringify!(direct_memory_tags_t))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_tags_t>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_tags_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_tags_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_tags_t),
            "::",
            stringify!(len)
        )
    );
}
impl Default for direct_memory_tags_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const Sim_Trn_Instr: _bindgen_ty_16 = 1;
pub const Sim_Trn_Write: _bindgen_ty_16 = 2;
#[doc = " Not a memory transaction. Signifies that\nthis is not an exchange of data between CPU\nand memory."]
pub const Sim_Trn_Control: _bindgen_ty_16 = 4;
#[doc = " no defined semantics really, may go away"]
pub const Sim_Trn_Prefetch: _bindgen_ty_16 = 8;
#[doc = " Bits in memory transaction types"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const mem_op_type_t_Sim_Trans_Load: mem_op_type_t = 0;
pub const mem_op_type_t_Sim_Trans_Store: mem_op_type_t = 2;
pub const mem_op_type_t_Sim_Trans_Instr_Fetch: mem_op_type_t = 1;
pub const mem_op_type_t_Sim_Trans_Prefetch: mem_op_type_t = 12;
pub const mem_op_type_t_Sim_Trans_Cache: mem_op_type_t = 4;
#[doc = " <add id=\"mem_op_type_t DOC\">\n<ndx>mem_op_type_t</ndx>\n<name index=\"true\">mem_op_type_t</name>\n<doc>\n<doc-item name=\"NAME\">mem_op_type_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<smaller>\n<insert id=\"mem_op_type_t def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThis enum is used to identify the type of a memory operation. The\nfunction <fun>SIM_get_mem_op_type()</fun> returns the type of a\n<type>generic_transaction_t</type>, and <fun>SIM_set_mem_op_type()</fun>\nis used to set it.\n</doc-item>\n<doc-item name=\"SEE ALSO\">\n<fun>SIM_get_mem_op_type</fun>, <fun>SIM_set_mem_op_type</fun>,\n<fun>SIM_get_mem_op_type_name</fun>\n<type>generic_transaction_t</type>,\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"mem_op_type_t def\"></add-type>"]
pub type mem_op_type_t = ::std::os::raw::c_uint;
#[doc = " catch uninitialized"]
pub const ini_type_t_Sim_Initiator_Illegal: ini_type_t = 0;
pub const ini_type_t_Sim_Initiator_CPU: ini_type_t = 4096;
pub const ini_type_t_Sim_Initiator_CPU_V9: ini_type_t = 4352;
pub const ini_type_t_Sim_Initiator_CPU_X86: ini_type_t = 4608;
pub const ini_type_t_Sim_Initiator_CPU_PPC: ini_type_t = 4864;
pub const ini_type_t_Sim_Initiator_CPU_Alpha: ini_type_t = 5120;
pub const ini_type_t_Sim_Initiator_CPU_MIPS: ini_type_t = 5632;
pub const ini_type_t_Sim_Initiator_CPU_ARM: ini_type_t = 5888;
pub const ini_type_t_Sim_Initiator_CPU_V8: ini_type_t = 6144;
pub const ini_type_t_Sim_Initiator_CPU_H8: ini_type_t = 6400;
pub const ini_type_t_Sim_Initiator_CPU_SH: ini_type_t = 6656;
pub const ini_type_t_Sim_Initiator_Device: ini_type_t = 8192;
pub const ini_type_t_Sim_Initiator_PCI_Device: ini_type_t = 8208;
#[doc = " The transaction is a cache\ntransaction as defined by\ng-cache"]
pub const ini_type_t_Sim_Initiator_Cache: ini_type_t = 12288;
#[doc = " initiator == NULL"]
pub const ini_type_t_Sim_Initiator_Other: ini_type_t = 16384;
#[doc = " 0x5000 - 0x5fff are for user-\nwritten objects that need to\ntag mem-ops."]
pub const ini_type_t_Sim_Initiator_User_Defined: ini_type_t = 20480;
#[doc = " <add-type id=\"ini_type_t\"></add-type>"]
pub type ini_type_t = ::std::os::raw::c_uint;
#[doc = " want memhier or timing model\nto see future accesses"]
pub const block_flag_t_Sim_Block_Memhier: block_flag_t = 1;
#[doc = " want future MMU visibility"]
pub const block_flag_t_Sim_Block_MMU: block_flag_t = 2;
#[doc = " want future MMU visibility\nfor accesses that skip the\nIOSTC lookup"]
pub const block_flag_t_Sim_Block_MMU_IOSTC: block_flag_t = 4;
#[doc = " need breakpoint check"]
pub const block_flag_t_Sim_Block_Breakpoint: block_flag_t = 8;
#[doc = " is not memory"]
pub const block_flag_t_Sim_Block_Notmem: block_flag_t = 16;
#[doc = " memory is byteswapped"]
pub const block_flag_t_Sim_Block_Endian: block_flag_t = 32;
#[doc = " DSTC is disabled for this\naccess"]
pub const block_flag_t_Sim_Block_DSTC_Disabled: block_flag_t = 64;
#[doc = " <add id=\"block_flag_t DOC\">\n<ndx>block_flag_t</ndx>\n<name index=\"true\">block_flag_t</name>\n<doc>\n<doc-item name=\"NAME\">block_flag_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<insert id=\"block_flag_t def\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nThis enum are flags for blocking various internal caches (internal).\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"block_flag_t def\"></add-type>"]
pub type block_flag_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"generic_transaction_t DOC\">\n<ndx>generic_transaction_t</ndx>\n<name index=\"true\">generic_transaction_t</name>\n<doc>\n\n<doc-item name=\"NAME\">generic_transaction_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> A <type>generic_transaction_t</type>\nrepresents a memory transaction. It should only be accessed via the accessor\nfunctions documented in <cite>Device API Functions, Core, Memory\nTransactions</cite>.</doc-item>\n\n</doc>\n</add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct generic_transaction {
    pub logical_address: logical_address_t,
    pub physical_address: physical_address_t,
    #[doc = " size in bytes"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " opaque"]
    pub type_: mem_op_type_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = " what we wish to block\nfrom caching"]
    pub block_flags: ::std::os::raw::c_uint,
    #[doc = " cpu, device, or other"]
    pub ini_type: ini_type_t,
    pub ini_ptr: *mut conf_object_t,
    #[doc = " set if memhier throws\nexception, otherwise\nSim_PE_No_Exception"]
    pub exception: exception_type_t,
    #[doc = " user pointer that Simics never\ntouches"]
    pub user_ptr: *mut ::std::os::raw::c_void,
    #[doc = " data pointer for the\ninitiator"]
    pub real_address: *mut uint8,
    #[doc = " internal, # of memory space\ntransitions"]
    pub space_count: ::std::os::raw::c_int,
    pub transaction: *mut transaction,
    #[doc = " no longer used"]
    pub reserved: *mut page_t,
    #[doc = " no longer used"]
    pub reserved2: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_generic_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<generic_transaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<generic_transaction>(),
        104usize,
        concat!("Size of: ", stringify!(generic_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<generic_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(generic_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(logical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(physical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(block_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ini_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(ini_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ini_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(ini_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_ptr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(user_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).real_address) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(real_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(space_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(transaction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_transaction),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for generic_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl generic_transaction {
    #[inline]
    pub fn atomic(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_atomic(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inquiry(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inquiry(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_coherent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_coherent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_stall(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_stall(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reissue(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reissue(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn block_STC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block_STC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_page_cache(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_page_cache(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inverse_endian(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inverse_endian(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn page_cross(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_page_cross(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_hier_on_fetch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_hier_on_fetch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        atomic: ::std::os::raw::c_uint,
        inquiry: ::std::os::raw::c_uint,
        non_coherent: ::std::os::raw::c_uint,
        ignore: ::std::os::raw::c_uint,
        may_stall: ::std::os::raw::c_uint,
        reissue: ::std::os::raw::c_uint,
        block_STC: ::std::os::raw::c_uint,
        use_page_cache: ::std::os::raw::c_uint,
        inverse_endian: ::std::os::raw::c_uint,
        page_cross: ::std::os::raw::c_uint,
        mem_hier_on_fetch: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let atomic: u32 = unsafe { ::std::mem::transmute(atomic) };
            atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inquiry: u32 = unsafe { ::std::mem::transmute(inquiry) };
            inquiry as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let non_coherent: u32 = unsafe { ::std::mem::transmute(non_coherent) };
            non_coherent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore: u32 = unsafe { ::std::mem::transmute(ignore) };
            ignore as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let may_stall: u32 = unsafe { ::std::mem::transmute(may_stall) };
            may_stall as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reissue: u32 = unsafe { ::std::mem::transmute(reissue) };
            reissue as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let block_STC: u32 = unsafe { ::std::mem::transmute(block_STC) };
            block_STC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let use_page_cache: u32 = unsafe { ::std::mem::transmute(use_page_cache) };
            use_page_cache as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inverse_endian: u32 = unsafe { ::std::mem::transmute(inverse_endian) };
            inverse_endian as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let page_cross: u32 = unsafe { ::std::mem::transmute(page_cross) };
            page_cross as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mem_hier_on_fetch: u32 = unsafe { ::std::mem::transmute(mem_hier_on_fetch) };
            mem_hier_on_fetch as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " <add id=\"generic_transaction_t DOC\">\n<ndx>generic_transaction_t</ndx>\n<name index=\"true\">generic_transaction_t</name>\n<doc>\n\n<doc-item name=\"NAME\">generic_transaction_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> A <type>generic_transaction_t</type>\nrepresents a memory transaction. It should only be accessed via the accessor\nfunctions documented in <cite>Device API Functions, Core, Memory\nTransactions</cite>.</doc-item>\n\n</doc>\n</add>"]
pub type generic_transaction_t = generic_transaction;
extern "C" {
    pub fn SIM_c_get_mem_op_value_buf(mop: *const generic_transaction_t, dst: *mut uint8);
}
extern "C" {
    pub fn SIM_c_set_mem_op_value_buf(mop: *mut generic_transaction_t, src: *const uint8);
}
extern "C" {
    pub fn SIM_get_mem_op_value_buf(mop: *const generic_transaction_t) -> attr_value_t;
}
extern "C" {
    pub fn SIM_set_mem_op_value_buf(mop: *mut generic_transaction_t, value: attr_value_t);
}
extern "C" {
    pub fn SIM_get_mem_op_type_name(type_: mem_op_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_get_mem_op_value_le(mop: *const generic_transaction_t) -> uint64;
}
extern "C" {
    pub fn SIM_get_mem_op_value_be(mop: *const generic_transaction_t) -> uint64;
}
extern "C" {
    pub fn SIM_get_mem_op_value_cpu(mop: *const generic_transaction_t) -> uint64;
}
extern "C" {
    pub fn SIM_set_mem_op_value_le(mop: *mut generic_transaction_t, value: uint64);
}
extern "C" {
    pub fn SIM_set_mem_op_value_be(mop: *mut generic_transaction_t, value: uint64);
}
extern "C" {
    pub fn SIM_set_mem_op_value_cpu(mop: *mut generic_transaction_t, value: uint64);
}
extern "C" {
    pub fn SIM_set_mem_op_ignore(mop: *mut generic_transaction_t, ignore: bool);
}
extern "C" {
    pub fn SIM_get_mem_op_ignore(mop: *const generic_transaction_t) -> bool;
}
extern "C" {
    pub fn SIM_make_mem_op_write(
        addr: physical_address_t,
        data: bytes_t,
        inquiry: bool,
        initiator: *mut conf_object_t,
    ) -> generic_transaction_t;
}
extern "C" {
    pub fn SIM_make_mem_op_read(
        addr: physical_address_t,
        data: buffer_t,
        inquiry: bool,
        initiator: *mut conf_object_t,
    ) -> generic_transaction_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct map_target {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"map_target_t def\"></add-type>"]
pub type map_target_t = map_target;
extern "C" {
    pub fn SIM_new_map_target(
        obj: *mut conf_object_t,
        port: *const ::std::os::raw::c_char,
        chained_target: *const map_target_t,
    ) -> *mut map_target_t;
}
extern "C" {
    pub fn SIM_free_map_target(mt: *mut map_target_t);
}
extern "C" {
    pub fn SIM_map_target_object(mt: *const map_target_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_map_target_port(mt: *const map_target_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_map_target_target(mt: *const map_target_t) -> *const map_target_t;
}
extern "C" {
    pub fn VT_map_target_access(
        mt: *const map_target_t,
        mop: *mut generic_transaction_t,
    ) -> exception_type_t;
}
extern "C" {
    pub fn VT_map_target_dm_lookup(
        mt: *const map_target_t,
        requester: *mut conf_object_t,
        addr: physical_address_t,
        size: uint64,
        access: access_t,
    ) -> direct_memory_lookup_t;
}
extern "C" {
    pub fn SIM_map_target_flush(
        mt: *const map_target_t,
        base: uint64,
        size: uint64,
        access: access_t,
    ) -> bool;
}
pub const translation_flags_t_Sim_Translation_Dynamic: translation_flags_t = 1;
pub const translation_flags_t_Sim_Translation_Ambiguous: translation_flags_t = 2;
#[doc = " <add id=\"translation_t DOC\">\n<ndx>translation_flags_t</ndx>\n<ndx>translation_t</ndx>\n<name index=\"true\">translation_t</name>\n\n<doc>\n<doc-item name=\"NAME\">translation_t</doc-item>\n<doc-item name=\"DESCRIPTION\">\n<insert id=\"translation_t description\"/>\n</doc-item>\n</doc>\n</add>\n\n<add id=\"translation_t description\">\n\nThe <type>translation_t</type> type is used for the implementation\nof the <iface>translator</iface> and <iface>transaction_translator</iface>\ninterfaces. It describes the range\nfor which the translation is valid, its target as well as\ntranslation properties.\n\nThe range for which the translation is valid is specified by the\nfields <param>base</param> and <param>size</param>. As a special case,\nif <param>size</param> and <param>base</param> are both 0, then the\ntranslation is valid for the entire address space. To allow optimizations\n(e.g., caching of translations) translators should return as wide ranges\nas possible.\n\nThe <param>target</param> field specifies the object and interface\nport which is mapped into the address range in the form of a map target.\nMap targets can be created using the function\n<fun>SIM_new_map_target</fun>. Please note that the ownership over\nthe returned map target is not transferred to the interface caller.\nThis means that to avoid memory leaks the reference to the map\ntarget must be kept by the implementing object, and\n<fun>SIM_free_map_target</fun> function should be later used to\ndeallocate the map target. Possible map targets include IO\nbanks, RAM, ROM, memory spaces, port spaces, bridges, and translators.\nThe <param>base</param> address in the source address space is\nmapped to the target address returned in the <param>start</param> field.\n\nA null value returned in the <param>target</param> field signifies that\nthe translation cannot be done. This can happen if there is nothing mapped\nin the range defined by <param>base</param> and <param>size</param>\n(transactions directed to this region will be terminated\nwith the pseudo exception <const>Sim_PE_IO_Not_Taken</const>) or\nif a translation valid for all requested accesses cannot be performed.\nIn the latter case, the requestor is expected to repeat\nthe interface call with just a single bit set in the access mask,\ne.g. <const>Sim_Access_Read</const>.\n\nIf the returned translation is not static but instead depends on e.g.\na device register, then the translator can set the flags field\nto <const>Sim_Translation_Dynamic</const>. This flag indicates that\nthe translation must not be cached. If this flag is not used, then it\nis the responsibility of the translator to call\neither <fun>SIM_map_target_flush</fun> (preferably)\nor <fun>SIM_translation_changed</fun> function when a previously performed\ntranslation is no longer valid.\n\nThe <const>Sim_Translation_Ambiguous</const> flag should not generally\nbe used by models. It is used by Simics objects of\nthe <class>memory-space</class> class to indicate an error in\nthe memory mapping when several destinations are specified for the address.\n\n<insert-until text=\"// ADD TYPE translation\"/>\n\n<doc-item name=\"SEE ALSO\">\n<fun>SIM_map_target_flush</fun>,\n<fun>SIM_translation_changed</fun>\n</doc-item>\n\n</add>"]
pub type translation_flags_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct translation_t {
    #[doc = " target of translation"]
    pub target: *const map_target_t,
    #[doc = " base address of translated range"]
    pub base: physical_address_t,
    #[doc = " start address in mapped object"]
    pub start: physical_address_t,
    #[doc = " size of translated range"]
    pub size: physical_address_t,
    pub flags: translation_flags_t,
}
#[test]
fn bindgen_test_layout_translation_t() {
    const UNINIT: ::std::mem::MaybeUninit<translation_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<translation_t>(),
        40usize,
        concat!("Size of: ", stringify!(translation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<translation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(translation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(translation_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(translation_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(translation_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(translation_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(translation_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for translation_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const atom_id_t_Sim_Atom_Id_illegal: atom_id_t = 0;
pub const atom_id_t_Sim_Atom_Id_list_end: atom_id_t = 1;
pub const atom_id_t_Sim_Atom_Id_flags: atom_id_t = 2;
pub const atom_id_t_Sim_Atom_Id_data: atom_id_t = 3;
pub const atom_id_t_Sim_Atom_Id_size: atom_id_t = 4;
pub const atom_id_t_Sim_Atom_Id_fill_value: atom_id_t = 5;
pub const atom_id_t_Sim_Atom_Id_initiator: atom_id_t = 6;
pub const atom_id_t_Sim_Atom_Id_user_data: atom_id_t = 7;
pub const atom_id_t_Sim_Atom_Id_completion: atom_id_t = 8;
pub const atom_id_t_Sim_Atom_Id_owner: atom_id_t = 9;
pub const atom_id_t_Sim_Atom_Id_memop: atom_id_t = 10;
pub const atom_id_t_Sim_Atom_Id_bytemap: atom_id_t = 11;
pub const atom_id_t_Sim_Atom_Id_pcie_type: atom_id_t = 256;
pub const atom_id_t_Sim_Atom_Id_pcie_requester_id: atom_id_t = 257;
pub const atom_id_t_Sim_Atom_Id_pcie_msg_type: atom_id_t = 258;
pub const atom_id_t_Sim_Atom_Id_pcie_msg_route: atom_id_t = 259;
pub const atom_id_t_Sim_Atom_Id_pcie_pasid: atom_id_t = 260;
pub const atom_id_t_Sim_Atom_Id_pcie_at: atom_id_t = 261;
pub const atom_id_t_Sim_Atom_Id_pcie_error_ret: atom_id_t = 262;
pub const atom_id_t_Sim_Atom_Id_pcie_byte_count_ret: atom_id_t = 263;
pub const atom_id_t_Sim_Atom_Id_pcie_device_id: atom_id_t = 264;
pub const atom_id_t_Sim_Atom_Id_arm_privileged: atom_id_t = 512;
pub const atom_id_t_Sim_Atom_Id_arm_nonsecure: atom_id_t = 513;
pub const atom_id_t_Sim_Atom_Id_arm_memory_attributes: atom_id_t = 514;
pub const atom_id_t_Sim_Atom_Id_arm_smmu_attributes: atom_id_t = 515;
pub const atom_id_t_Sim_Atom_Id_arm_nsaid: atom_id_t = 516;
pub const atom_id_t_Sim_Atom_Id_riscv_wg_wid: atom_id_t = 768;
#[doc = " <add id=\"atom_id_t DOC\">\n<ndx>atom_id_t</ndx>\n<name index=\"true\">atom_id_t</name>\n<doc>\n\n<doc-item name=\"NAME\">atom_id_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> Each atom type is associated\nwith a unique id, the <type>atom_id_t</type>. Most atoms types are\npre-defined by Simics Core and have static ids, but there are\nalso dynamically assigned ids which are used for custom atom types.\n\nAtom ids are internal to Simics Core and should never be used explicitly\nby a Simics models. Instead, there are API functions like\ne.g. <fun>ATOM_size</fun> or <fun>ATOM_initiator</fun> which should be\nused instead.\n</doc-item>\n</doc></add>"]
pub type atom_id_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"atom_t DOC\">\n<ndx>atom_t</ndx>\n<name index=\"true\">atom_t</name>\n<doc>\n\n<doc-item name=\"NAME\">atom_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> The <type>atom_t</type> type is a container\ntype for tagged data associated with a transaction. The kind of data\nstored in the atom is determined by the <var>id</var> field, and a pointer\nto the data or the data itself is stored in the <var>ptr</var> field.\n\nAtoms should always be initialized using provided constructor functions\nlike <fun>ATOM_flags</fun> or <fun>ATOM_size</fun>. Usage of\nthe constructors ensures that the data payload is of the correct type\nand that the <fun>id</fun> is set to the correct value.\n\nAtom lists must be terminated with the special <const>ATOM_LIST_END</const>\nmarker.\n</doc-item>\n</doc></add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct atom_t {
    pub id: atom_id_t,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_atom_t() {
    const UNINIT: ::std::mem::MaybeUninit<atom_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<atom_t>(),
        16usize,
        concat!("Size of: ", stringify!(atom_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atom_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atom_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atom_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atom_t),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for atom_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"transaction_t DOC\">\n<ndx>transaction_t</ndx>\n<name index=\"true\">transaction_t</name>\n<doc>\n\n<doc-item name=\"NAME\">transaction_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> A <type>transaction_t</type>\nrepresents a memory transaction. The properties of the\ntransaction is stored in the form of an atom list, where each\natom describes a particular aspect of the transaction, like the\nsize of the transaction.\n\nThe field <var>atoms</var> points to the atoms list,\nwhich must be terminated with the constant <const>ATOM_LIST_END</const>.\n\nThe <var>prev</var> field points to an optional parent transaction.\nIf a particular atom is not found in the atoms list, then the\nparent's list of atoms is consulted instead. The <var>prev</var>\npointer is also used when a chained transaction is monitored\nwith <fun>SIM_monitor_chained_transaction</fun>.\n\nBesides the fields above, the transaction contains some internal\nfields that should be initialized to 0. The internal fields should\nnot be referenced explicitly since they are likely to change\nin future Simics releases.\n\nFor details, please refer to \"Transactions\" chapter in\nthe Model Builder's User Guide.\n\n</doc-item>\n</doc></add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct transaction {
    pub atoms: *mut atom_t,
    pub prev: *mut transaction,
    pub _cache: *mut transaction_cache,
    pub _status: uint64,
}
#[test]
fn bindgen_test_layout_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<transaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<transaction>(),
        32usize,
        concat!("Size of: ", stringify!(transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atoms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(transaction),
            "::",
            stringify!(atoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(transaction),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cache) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(transaction),
            "::",
            stringify!(_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._status) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(transaction),
            "::",
            stringify!(_status)
        )
    );
}
impl Default for transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"transaction_t DOC\">\n<ndx>transaction_t</ndx>\n<name index=\"true\">transaction_t</name>\n<doc>\n\n<doc-item name=\"NAME\">transaction_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> A <type>transaction_t</type>\nrepresents a memory transaction. The properties of the\ntransaction is stored in the form of an atom list, where each\natom describes a particular aspect of the transaction, like the\nsize of the transaction.\n\nThe field <var>atoms</var> points to the atoms list,\nwhich must be terminated with the constant <const>ATOM_LIST_END</const>.\n\nThe <var>prev</var> field points to an optional parent transaction.\nIf a particular atom is not found in the atoms list, then the\nparent's list of atoms is consulted instead. The <var>prev</var>\npointer is also used when a chained transaction is monitored\nwith <fun>SIM_monitor_chained_transaction</fun>.\n\nBesides the fields above, the transaction contains some internal\nfields that should be initialized to 0. The internal fields should\nnot be referenced explicitly since they are likely to change\nin future Simics releases.\n\nFor details, please refer to \"Transactions\" chapter in\nthe Model Builder's User Guide.\n\n</doc-item>\n</doc></add>"]
pub type transaction_t = transaction;
#[doc = " <add id=\"transaction_completion_t DOC\">\n<ndx>transaction_completion_t</ndx>\n<name index=\"true\">transaction_completion_t</name>\n<doc>\n<doc-item name=\"NAME\">transaction_completion_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<insert id=\"transaction_completion_t def\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\nCallback invoked when an asynchronous transaction is completed.\nThe callback is stored in a <type>completion</type> atom belonging\nto the transaction <arg>t</arg>. Similarly, <arg>obj</arg> is an\nobject stored in either an <type>owner</type> atom or an\n<type>initiator</type> atom. The former takes precedence if both are\npresent.\n\nCompletion callbacks are only invoked for transactions monitored\nwith either <fun>SIM_monitor_transaction</fun> or\n<fun>SIM_monitor_chained_transaction</fun>, or for transactions\ndeferred with <fun>SIM_defer_owned_transaction</fun>.\n\nThe completion status for the operation is given in the\n<param>ex</param> argument, and is usually equal to\n<const>Sim_PE_No_Exception</const>.\n\nThe return value of the callback is the completion status\nfor the transaction <arg>t</arg>. This status is used to complete\nthe parent transaction if the transaction is being monitored with\n<fun>SIM_monitor_chained_transaction</fun>. The return value is\nalso returned by <fun>SIM_monitor_transaction</fun> or\n<fun>SIM_monitor_chained_transaction</fun> when a transaction is\ncompleted synchronously.\n\nIf the callback returns <const>Sim_PE_Deferred</const>, then\nthe transaction <arg>t</arg> is left uncompleted. It must then\nbe completed later on by an explicit call to\n<fun>SIM_complete_transaction</fun>.\n\n</doc-item></doc></add>\n\n<add-type id=\"transaction_completion_t def\"></add-type>"]
pub type transaction_completion_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        t: *mut transaction_t,
        ex: exception_type_t,
    ) -> exception_type_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct transaction_bytemap {
    _unused: [u8; 0],
}
pub type transaction_bytemap_t = transaction_bytemap;
pub const transaction_flags_t_Sim_Transaction_Fetch: transaction_flags_t = 1;
pub const transaction_flags_t_Sim_Transaction_Write: transaction_flags_t = 2;
pub const transaction_flags_t_Sim_Transaction_Control: transaction_flags_t = 4;
pub const transaction_flags_t_Sim_Transaction_Inquiry: transaction_flags_t = 256;
pub const transaction_flags_t_Sim_Transaction_Incoherent: transaction_flags_t = 512;
pub const transaction_flags_t_Sim_Transaction_Atomic: transaction_flags_t = 1024;
#[doc = " <add id=\"transaction_flags_t DOC\">\n<ndx>transaction_flags_t</ndx>\n<name index=\"true\">transaction_flags_t</name>\n<doc>\n\n<doc-item name=\"NAME\">transaction_flags_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<insert id=\"transaction_flags_t def\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\nThe <type>transaction_flags_t</type> type is bitmask\nused to specify the transaction type. It is a combination\nof the following bits:\n\n<tt>Sim_Transaction_Fetch</tt> indicates that the transaction is\nan instruction fetch.\n\n<tt>Sim_Transaction_Write</tt> is set if the transaction is a write.\n\n<tt>Sim_Transaction_Control</tt> is set if the transaction does not\nactually transfer any data. One example of such transactions is\ncache control operations.\n\nThe <tt>Sim_Transaction_Inquiry</tt> bit signifies that side\neffects normally triggered by the transaction should be suppressed.\nExamples of side effects include triggering breakpoints and\nclearing \"read-to-clear\" device registers.\n\nWhen neither <tt>Sim_Transaction_Fetch</tt>\nnor <tt>Sim_Transaction_Write</tt> is set the transaction is\na read transaction.\n\n</doc-item></doc></add>\n<add-type id=\"transaction_flags_t def\"></add-type>"]
pub type transaction_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Accessors."]
    pub fn SIM_transaction_is_fetch(t: *const transaction_t) -> bool;
}
extern "C" {
    pub fn SIM_transaction_is_write(t: *const transaction_t) -> bool;
}
extern "C" {
    pub fn SIM_transaction_is_read(t: *const transaction_t) -> bool;
}
extern "C" {
    pub fn SIM_transaction_is_inquiry(t: *const transaction_t) -> bool;
}
extern "C" {
    pub fn SIM_transaction_is_deferrable(t: *const transaction_t) -> bool;
}
extern "C" {
    pub fn SIM_transaction_size(t: *const transaction_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SIM_transaction_initiator(t: *const transaction_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIM_transaction_flags(t: *const transaction_t) -> transaction_flags_t;
}
extern "C" {
    #[doc = " Transaction completion."]
    pub fn SIM_complete_transaction(t: *mut transaction_t, ex: exception_type_t);
}
extern "C" {
    pub fn SIM_defer_transaction(
        obj: *mut conf_object_t,
        t: *mut transaction_t,
    ) -> *mut transaction_t;
}
extern "C" {
    pub fn SIM_defer_owned_transaction(t: *mut transaction_t) -> *mut transaction_t;
}
extern "C" {
    pub fn SIM_replace_transaction(t_old: *mut transaction_t, t_new: *mut transaction_t);
}
extern "C" {
    pub fn SIM_monitor_transaction(t: *mut transaction_t, ex: exception_type_t)
        -> exception_type_t;
}
extern "C" {
    pub fn SIM_monitor_chained_transaction(
        t: *mut transaction_t,
        ex: exception_type_t,
    ) -> exception_type_t;
}
extern "C" {
    pub fn SIM_transaction_wait(t: *mut transaction_t, ex: exception_type_t) -> exception_type_t;
}
extern "C" {
    pub fn SIM_poll_transaction(t: *mut transaction_t) -> exception_type_t;
}
extern "C" {
    #[doc = " Transaction data transfer."]
    pub fn SIM_set_transaction_bytes(t: *const transaction_t, bytes: bytes_t);
}
extern "C" {
    pub fn SIM_set_transaction_value_le(t: *const transaction_t, val: uint64);
}
extern "C" {
    pub fn SIM_set_transaction_value_be(t: *const transaction_t, val: uint64);
}
extern "C" {
    pub fn SIM_set_transaction_bytes_offs(
        t: *const transaction_t,
        offs: ::std::os::raw::c_uint,
        bytes: bytes_t,
    );
}
extern "C" {
    pub fn SIM_set_transaction_bytes_constant(t: *const transaction_t, value: uint8);
}
extern "C" {
    pub fn SIM_get_transaction_bytes(t: *const transaction_t, bytes: buffer_t);
}
extern "C" {
    pub fn SIM_get_transaction_bytes_offs(
        t: *const transaction_t,
        offs: ::std::os::raw::c_uint,
        buf: buffer_t,
        zerofill_holes: bool,
    );
}
extern "C" {
    pub fn SIM_get_transaction_value_le(t: *const transaction_t) -> uint64;
}
extern "C" {
    pub fn SIM_get_transaction_value_be(t: *const transaction_t) -> uint64;
}
extern "C" {
    #[doc = " Transaction Issue."]
    pub fn SIM_issue_transaction(
        mt: *const map_target_t,
        t: *mut transaction_t,
        addr: uint64,
    ) -> exception_type_t;
}
extern "C" {
    #[doc = " This declaration fits better into <simics/base/memory.h>. We had to put it\nhere since our headers intermix type definitions and func declarations."]
    pub fn SIM_inspect_address_routing(
        mt: *const map_target_t,
        t: *mut transaction_t,
        addr: uint64,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                mt: *const map_target_t,
                t: *const transaction_t,
                addr: uint64,
                base: uint64,
                start: uint64,
                size: uint64,
                access: access_t,
                flags: translation_flags_t,
                data: *mut lang_void,
            ) -> bool,
        >,
        data: *mut lang_void,
    ) -> bool;
}
extern "C" {
    pub fn SIM_inspect_breakpoints(
        mt: *const map_target_t,
        t: *mut transaction_t,
        start: uint64,
        end: uint64,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                trigger_object: *mut conf_object_t,
                bp_set: breakpoint_set_t,
                t: *const transaction_t,
                addr: uint64,
                size: uint64,
                data: *mut lang_void,
            ) -> bool,
        >,
        data: *mut lang_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Transaction Checkpointing."]
    pub fn SIM_get_transaction_id(t: *mut transaction_t) -> int64;
}
extern "C" {
    pub fn SIM_reconnect_transaction(t: *mut transaction_t, id: int64);
}
extern "C" {
    pub fn VT_get_transaction(id: int64) -> *mut transaction_t;
}
extern "C" {
    #[doc = " Atom handling."]
    pub fn VT_register_atom_class(
        name: *const ::std::os::raw::c_char,
        pywrap_atom_from_type: *const ::std::os::raw::c_char,
        pywrap_type_from_atom: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_get_atom_class_id(name: *const ::std::os::raw::c_char) -> atom_id_t;
}
extern "C" {
    pub fn VT_lookup_atom_class_id(name: *const ::std::os::raw::c_char) -> atom_id_t;
}
extern "C" {
    pub fn VT_transaction_atom(
        t: *const transaction_t,
        id: atom_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn VT_lookup_transaction_atom(t: *const transaction_t, id: atom_id_t) -> *const atom_t;
}
extern "C" {
    pub fn SIM_register_python_atom_type(name: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_completion {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_completion() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_completion> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_completion>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_completion))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_completion>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_completion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_completion),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_flags {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_flags() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_flags> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_flags>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_flags),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_user_data {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_user_data() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_user_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_user_data>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_user_data))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_user_data>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_user_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_user_data),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_memop {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_memop() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_memop> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_memop>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_memop))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_memop>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_memop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_memop),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_fill_value {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_fill_value() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_fill_value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_fill_value>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_fill_value))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_fill_value>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_fill_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_fill_value),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_initiator {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_initiator() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_initiator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_initiator>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_initiator))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_initiator>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_initiator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_initiator),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_owner {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_owner() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_owner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_owner>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_owner))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_owner>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_owner))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_owner),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_list_end {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_list_end() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_list_end> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_list_end>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_list_end))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_list_end>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_list_end))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_list_end),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_data {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_data() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_data>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_data))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_data>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_data),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_size {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_size() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_size> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_size>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_size))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_size>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_size),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_bytemap {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_bytemap() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_bytemap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_bytemap>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_bytemap))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_bytemap>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_bytemap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_bytemap),
            "::",
            stringify!(dummy)
        )
    );
}
pub const notifier_type_t_Sim_Notify_Queue_Change: notifier_type_t = 0;
pub const notifier_type_t_Sim_Notify_Cell_Change: notifier_type_t = 1;
pub const notifier_type_t_Sim_Notify_Frequency_Change: notifier_type_t = 2;
pub const notifier_type_t_Sim_Notify_Concurrency_Change: notifier_type_t = 3;
pub const notifier_type_t_Sim_Notify_Object_Delete: notifier_type_t = 4;
pub const notifier_type_t_Sim_Notify_Map_Change: notifier_type_t = 5;
pub const notifier_type_t_Sim_Notify_State_Change: notifier_type_t = 6;
pub const notifier_type_t_Sim_Notify_Freerunning_Mode_Change: notifier_type_t = 7;
pub const notifier_type_t_Sim_Notify_Bank_Register_Value_Change: notifier_type_t = 8;
#[doc = " <add id=\"notifier_type_t DOC\">\n<ndx>notifier_type_t</ndx>\n<name index=\"true\">notifier_type_t</name>\n<doc>\n<doc-item name=\"NAME\">notifier_type_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\n<smaller>\n<insert id=\"notifier_type_t def\"/>\n</smaller>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nValues of the <type>notifier_type_t</type> type identify notification events.\nA <type>notifier_type_t</type> value should be obtained from\nthe <fun>SIM_notifier_type</fun> function and can then be used in other\nfunctions such as <fun>SIM_register_notifier</fun>,\n<fun>SIM_add_notifier</fun>, <fun>SIM_notify</fun>.\n\nA few notification events have predefined (constant) values. They are listed\nbelow where a notifier type in the form of a string (as accepted by\n<fun>SIM_notifier_type</fun>) is followed by the constant of the\n<type>notifier_type_t</type> type corresponding to the notification event\n(as returned by <fun>SIM_notifier_type</fun>):\n<ul>\n<li>\"queue-change\" (<var>Sim_Notify_Queue_Change</var>)</li>\n<li>\"cell-change\" (<var>Sim_Notify_Cell_Change</var>)</li>\n<li>\"frequency-change\" (<var>Sim_Notify_Frequency_Change</var>)</li>\n<li>\"concurrency-change\" (<var>Sim_Notify_Concurrency_Change</var>)</li>\n<li>\"object-delete\" (<var>Sim_Notify_Object_Delete</var>)</li>\n<li>\"map-change\" (<var>Sim_Notify_Map_Change</var>)</li>\n<li>\"state-change\" (<var>Sim_Notify_State_Change</var>)</li>\n<li>\"freerunning-mode-change\"\n(<var>Sim_Notify_Freerunning_Mode_Change</var>)</li>\n<li>\"bank-register-value-change\"\n(<var>Sim_Notify_Bank_Register_Value_Change</var>)</li>\n</ul>\n</doc-item>\n<doc-item name=\"SEE ALSO\">\n<fun>SIM_notify</fun>,\n<fun>SIM_add_notifier</fun>,\n<fun>SIM_register_notifier</fun>,\n<fun>SIM_notifier_type</fun>,\n<fun>SIM_describe_notifier</fun>,\n<fun>SIM_notifier_description</fun>\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"notifier_type_t def\"></add-type>"]
pub type notifier_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn SIM_notifier_type(type_: *const ::std::os::raw::c_char) -> notifier_type_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notifier_handle {
    _unused: [u8; 0],
}
#[doc = " Consumer API"]
pub type notifier_handle_t = notifier_handle;
extern "C" {
    pub fn SIM_add_notifier(
        obj: *mut conf_object_t,
        what: notifier_type_t,
        subscriber: *mut conf_object_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                subscriber: *mut conf_object_t,
                notifier: *mut conf_object_t,
                data: *mut lang_void,
            ),
        >,
        data: *mut lang_void,
    ) -> *mut notifier_handle_t;
}
extern "C" {
    pub fn SIM_delete_notifier(obj: *mut conf_object_t, handle: *mut notifier_handle_t);
}
extern "C" {
    pub fn SIM_has_notifier(obj: *mut conf_object_t, what: notifier_type_t) -> bool;
}
extern "C" {
    pub fn SIM_class_has_notifier(cls: *mut conf_class_t, what: notifier_type_t) -> bool;
}
extern "C" {
    #[doc = " Producer API"]
    pub fn SIM_register_notifier(
        cls: *mut conf_class_t,
        what: notifier_type_t,
        desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_register_tracked_notifier(
        cls: *mut conf_class_t,
        what: notifier_type_t,
        desc: *const ::std::os::raw::c_char,
        subscribed_changed: ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut conf_object_t,
                type_: notifier_type_t,
                has_subscribers: bool,
            ),
        >,
    );
}
extern "C" {
    pub fn SIM_notify(obj: *mut conf_object_t, type_: notifier_type_t);
}
extern "C" {
    pub fn SIM_describe_notifier(
        type_: notifier_type_t,
        generic_desc: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_notifier_description(type_: notifier_type_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct domain_lock {
    _unused: [u8; 0],
}
pub type domain_lock_t = domain_lock;
extern "C" {
    pub fn SIM_acquire_object(
        obj: *mut conf_object_t,
        function_name: *const ::std::os::raw::c_char,
        source_location: *const ::std::os::raw::c_char,
    ) -> *mut domain_lock_t;
}
extern "C" {
    pub fn SIM_acquire_target(
        obj: *mut conf_object_t,
        function_name: *const ::std::os::raw::c_char,
        source_location: *const ::std::os::raw::c_char,
    ) -> *mut domain_lock_t;
}
extern "C" {
    pub fn SIM_acquire_cell(
        obj: *mut conf_object_t,
        function_name: *const ::std::os::raw::c_char,
        source_location: *const ::std::os::raw::c_char,
    ) -> *mut domain_lock_t;
}
extern "C" {
    pub fn SIM_release_object(obj: *mut conf_object_t, lock: *mut domain_lock_t);
}
extern "C" {
    pub fn SIM_release_target(obj: *mut conf_object_t, lock: *mut domain_lock_t);
}
extern "C" {
    pub fn SIM_release_cell(obj: *mut conf_object_t, lock: *mut domain_lock_t);
}
extern "C" {
    pub fn SIM_acquire_object_for_execution(obj: *mut conf_object_t) -> *mut domain_lock_t;
}
extern "C" {
    pub fn SIM_yield_thread_domains();
}
extern "C" {
    pub fn VT_acquire_object(
        obj: *mut conf_object_t,
        func: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
    ) -> *mut domain_lock_t;
}
extern "C" {
    pub fn VT_acquire_cell(
        obj: *mut conf_object_t,
        func: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
    ) -> *mut domain_lock_t;
}
extern "C" {
    pub fn VT_acquire_target(
        obj: *mut conf_object_t,
        func: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
    ) -> *mut domain_lock_t;
}
extern "C" {
    pub fn VT_release_object(obj: *mut conf_object_t, lock: *mut domain_lock_t);
}
extern "C" {
    pub fn VT_release_cell(obj: *mut conf_object_t, lock: *mut domain_lock_t);
}
extern "C" {
    pub fn VT_release_target(obj: *mut conf_object_t, lock: *mut domain_lock_t);
}
extern "C" {
    pub fn VT_assert_object_lock(
        obj: *mut conf_object_t,
        func: *const ::std::os::raw::c_char,
        line: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_assert_cell_context(
        obj: *mut conf_object_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIM_drop_thread_domains() -> *mut domain_lock_t;
}
extern "C" {
    pub fn SIM_reacquire_thread_domains(lock: *mut domain_lock_t);
}
pub const sim_exception_SimExc_No_Exception: sim_exception = 0;
pub const sim_exception_SimExc_General: sim_exception = 1;
pub const sim_exception_SimExc_Lookup: sim_exception = 2;
pub const sim_exception_SimExc_Attribute: sim_exception = 3;
pub const sim_exception_SimExc_IOError: sim_exception = 4;
pub const sim_exception_SimExc_Index: sim_exception = 5;
pub const sim_exception_SimExc_Memory: sim_exception = 6;
pub const sim_exception_SimExc_Type: sim_exception = 7;
pub const sim_exception_SimExc_Break: sim_exception = 8;
pub const sim_exception_SimExc_PythonTranslation: sim_exception = 9;
pub const sim_exception_SimExc_License: sim_exception = 10;
pub const sim_exception_SimExc_IllegalValue: sim_exception = 11;
pub const sim_exception_SimExc_InquiryOutsideMemory: sim_exception = 12;
pub const sim_exception_SimExc_InquiryUnhandled: sim_exception = 13;
pub const sim_exception_SimExc_InterfaceNotFound: sim_exception = 14;
pub const sim_exception_SimExc_AttrNotFound: sim_exception = 15;
pub const sim_exception_SimExc_AttrNotReadable: sim_exception = 16;
pub const sim_exception_SimExc_AttrNotWritable: sim_exception = 17;
pub const sim_exception_Sim_Exceptions: sim_exception = 18;
pub type sim_exception = ::std::os::raw::c_uint;
pub use self::sim_exception as sim_exception_t;
extern "C" {
    pub fn SIM_clear_exception() -> sim_exception_t;
}
extern "C" {
    pub fn SIM_get_pending_exception() -> sim_exception_t;
}
extern "C" {
    pub fn DBG_get_pending_exception() -> sim_exception_t;
}
extern "C" {
    pub fn SIM_last_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_frontend_exception(exc_type: sim_exception_t, str_: *const ::std::os::raw::c_char);
}
pub type os_time_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct os_tm {
    #[doc = " Seconds.     [0-60] (1 leap second)"]
    pub tm_sec: ::std::os::raw::c_int,
    #[doc = " Minutes.     [0-59]"]
    pub tm_min: ::std::os::raw::c_int,
    #[doc = " Hours.       [0-23]"]
    pub tm_hour: ::std::os::raw::c_int,
    #[doc = " Day.         [1-31]"]
    pub tm_mday: ::std::os::raw::c_int,
    #[doc = " Month.       [0-11]"]
    pub tm_mon: ::std::os::raw::c_int,
    #[doc = " Year - 1900."]
    pub tm_year: ::std::os::raw::c_int,
    #[doc = " Day of week. [0-6]"]
    pub tm_wday: ::std::os::raw::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: ::std::os::raw::c_int,
    #[doc = " DST.         [-1/0/1]"]
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_os_tm() {
    const UNINIT: ::std::mem::MaybeUninit<os_tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<os_tm>(),
        36usize,
        concat!("Size of: ", stringify!(os_tm))
    );
    assert_eq!(
        ::std::mem::align_of::<os_tm>(),
        4usize,
        concat!("Alignment of ", stringify!(os_tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(os_tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
pub type os_tm_t = os_tm;
extern "C" {
    pub fn os_gmtime(timep: *const os_time_t) -> os_tm_t;
}
extern "C" {
    pub fn os_timegm(tmp: *mut os_tm_t) -> os_time_t;
}
extern "C" {
    pub fn os_strptime(
        str_: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        tm: *mut os_tm_t,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " All the structs below are INTERNAL and should not be used directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ht_key_t {
    pub i: uint64,
    pub s: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ht_key_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_key_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_key_t>(),
        8usize,
        concat!("Size of: ", stringify!(ht_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_key_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_key_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_key_t),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_key_t),
            "::",
            stringify!(s)
        )
    );
}
impl Default for ht_key_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ht_entry_common {
    pub value: *const ::std::os::raw::c_void,
    pub next: *mut ht_entry_common,
    pub key: ht_key_t,
    #[doc = " raw hash value"]
    pub hash: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ht_entry_common() {
    const UNINIT: ::std::mem::MaybeUninit<ht_entry_common> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_entry_common>(),
        32usize,
        concat!("Size of: ", stringify!(ht_entry_common))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_entry_common>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_entry_common))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_entry_common),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_entry_common),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_entry_common),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_entry_common),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for ht_entry_common {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ht_entry_common_t = ht_entry_common;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ht_int_entry_t {
    pub e: ht_entry_common_t,
}
#[test]
fn bindgen_test_layout_ht_int_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_int_entry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_int_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(ht_int_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_int_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_int_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_int_entry_t),
            "::",
            stringify!(e)
        )
    );
}
impl Default for ht_int_entry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ht_str_entry_t {
    pub e: ht_entry_common_t,
}
#[test]
fn bindgen_test_layout_ht_str_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_str_entry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_str_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(ht_str_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_str_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_str_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_str_entry_t),
            "::",
            stringify!(e)
        )
    );
}
impl Default for ht_str_entry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ht_table_common_t {
    #[doc = " size of buckets array; 0 or a power of 2"]
    pub nbuckets: ::std::os::raw::c_uint,
    #[doc = " nbuckets > 0 ? log2(nbuckets) : 0"]
    pub bits: ::std::os::raw::c_uint,
    #[doc = " array [nbuckets], or NULL"]
    pub buckets: *mut *mut ht_entry_common_t,
    #[doc = " total number of elements"]
    pub num_elements: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ht_table_common_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_table_common_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_table_common_t>(),
        24usize,
        concat!("Size of: ", stringify!(ht_table_common_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_table_common_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_table_common_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbuckets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_table_common_t),
            "::",
            stringify!(nbuckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_table_common_t),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buckets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_table_common_t),
            "::",
            stringify!(buckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_elements) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_table_common_t),
            "::",
            stringify!(num_elements)
        )
    );
}
impl Default for ht_table_common_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ht_str_table_t {
    pub t: ht_table_common_t,
    #[doc = " whether the table owns the keys"]
    pub keys_owned: bool,
}
#[test]
fn bindgen_test_layout_ht_str_table_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_str_table_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_str_table_t>(),
        32usize,
        concat!("Size of: ", stringify!(ht_str_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_str_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_str_table_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_str_table_t),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys_owned) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_str_table_t),
            "::",
            stringify!(keys_owned)
        )
    );
}
impl Default for ht_str_table_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ht_int_table_t {
    pub t: ht_table_common_t,
}
#[test]
fn bindgen_test_layout_ht_int_table_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_int_table_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_int_table_t>(),
        24usize,
        concat!("Size of: ", stringify!(ht_int_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_int_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_int_table_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_int_table_t),
            "::",
            stringify!(t)
        )
    );
}
impl Default for ht_int_table_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ht_iter_common_t {
    pub ht: *mut ht_table_common_t,
    #[doc = " current bucket"]
    pub index: ::std::os::raw::c_uint,
    #[doc = " current entry"]
    pub e: *mut ht_entry_common_t,
    #[doc = " next entry (current may be removed)"]
    pub next: *mut ht_entry_common_t,
}
#[test]
fn bindgen_test_layout_ht_iter_common_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_iter_common_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_iter_common_t>(),
        32usize,
        concat!("Size of: ", stringify!(ht_iter_common_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_iter_common_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_iter_common_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_iter_common_t),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_iter_common_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_iter_common_t),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_iter_common_t),
            "::",
            stringify!(next)
        )
    );
}
impl Default for ht_iter_common_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ht_int_iter_t {
    pub it: ht_iter_common_t,
}
#[test]
fn bindgen_test_layout_ht_int_iter_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_int_iter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_int_iter_t>(),
        32usize,
        concat!("Size of: ", stringify!(ht_int_iter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_int_iter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_int_iter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_int_iter_t),
            "::",
            stringify!(it)
        )
    );
}
impl Default for ht_int_iter_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ht_str_iter_t {
    pub it: ht_iter_common_t,
}
#[test]
fn bindgen_test_layout_ht_str_iter_t() {
    const UNINIT: ::std::mem::MaybeUninit<ht_str_iter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ht_str_iter_t>(),
        32usize,
        concat!("Size of: ", stringify!(ht_str_iter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ht_str_iter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ht_str_iter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ht_str_iter_t),
            "::",
            stringify!(it)
        )
    );
}
impl Default for ht_str_iter_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ht_clear_int_table(ht: *mut ht_int_table_t, free_vals: bool);
}
extern "C" {
    pub fn ht_clear_str_table(ht: *mut ht_str_table_t, free_vals: bool);
}
extern "C" {
    pub fn ht_delete_int_table(ht: *mut ht_int_table_t, free_values: bool);
}
extern "C" {
    pub fn ht_delete_str_table(ht: *mut ht_str_table_t, free_values: bool);
}
extern "C" {
    pub fn ht_insert_int(
        ht: *mut ht_int_table_t,
        key: uint64,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ht_insert_str(
        ht: *mut ht_str_table_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ht_update_int(
        ht: *mut ht_int_table_t,
        key: uint64,
        value: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ht_update_str(
        ht: *mut ht_str_table_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ht_remove_int(ht: *mut ht_int_table_t, key: uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ht_remove_str(
        ht: *mut ht_str_table_t,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ht_entry_lookup_int(ht: *mut ht_int_table_t, key: uint64) -> *mut ht_int_entry_t;
}
extern "C" {
    pub fn ht_entry_lookup_str(
        ht: *mut ht_str_table_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ht_str_entry_t;
}
extern "C" {
    pub fn ht_lookup_int(ht: *mut ht_int_table_t, key: uint64) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ht_lookup_str(
        ht: *mut ht_str_table_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ht_for_each_entry_int(
        table: *mut ht_int_table_t,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                table: *mut ht_int_table_t,
                key: uint64,
                value: *mut ::std::os::raw::c_void,
                data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ht_for_each_entry_str(
        table: *mut ht_str_table_t,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                table: *mut ht_str_table_t,
                key: *const ::std::os::raw::c_char,
                value: *mut ::std::os::raw::c_void,
                data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prof_data {
    _unused: [u8; 0],
}
pub type prof_data_t = prof_data;
pub type prof_data_address_t = uint64;
pub type prof_data_counter_t = uint64;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct prof_data_iter_t {
    pub pd: *mut prof_data_t,
    pub start: uint64,
    pub end: uint64,
    pub hit: ht_int_iter_t,
    #[doc = " position in current chunk"]
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_prof_data_iter_t() {
    const UNINIT: ::std::mem::MaybeUninit<prof_data_iter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<prof_data_iter_t>(),
        64usize,
        concat!("Size of: ", stringify!(prof_data_iter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<prof_data_iter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(prof_data_iter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(prof_data_iter_t),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(prof_data_iter_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(prof_data_iter_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(prof_data_iter_t),
            "::",
            stringify!(hit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(prof_data_iter_t),
            "::",
            stringify!(index)
        )
    );
}
impl Default for prof_data_iter_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn prof_data_create(granularity: ::std::os::raw::c_uint) -> *mut prof_data_t;
}
extern "C" {
    pub fn prof_data_delete(pd: *mut prof_data_t);
}
extern "C" {
    pub fn prof_data_clear(pd: *mut prof_data_t);
}
extern "C" {
    pub fn prof_data_granularity_log2(pd: *mut prof_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prof_data_set(
        pd: *mut prof_data_t,
        address: prof_data_address_t,
        value: prof_data_counter_t,
    );
}
extern "C" {
    pub fn prof_data_add(
        pd: *mut prof_data_t,
        address: prof_data_address_t,
        value: prof_data_counter_t,
    );
}
extern "C" {
    pub fn prof_data_get(pd: *mut prof_data_t, address: prof_data_address_t)
        -> prof_data_counter_t;
}
extern "C" {
    pub fn prof_data_new_iter(
        pd: *mut prof_data_t,
        it: *mut prof_data_iter_t,
        start: prof_data_address_t,
        end: prof_data_address_t,
    );
}
extern "C" {
    pub fn prof_data_iter_next(it: *mut prof_data_iter_t) -> prof_data_counter_t;
}
extern "C" {
    pub fn prof_data_iter_addr(it: *mut prof_data_iter_t) -> prof_data_address_t;
}
extern "C" {
    pub fn prof_data_save(pd: *mut prof_data_t, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prof_data_load(pd: *mut prof_data_t, f: *mut FILE) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct craff_file {
    _unused: [u8; 0],
}
pub type craff_file_t = craff_file;
pub const craff_compr_t_Compr_None: craff_compr_t = 0;
#[doc = " 1 used to be bz2 compression"]
pub const craff_compr_t_Compr_Gz: craff_compr_t = 2;
pub type craff_compr_t = ::std::os::raw::c_uint;
#[doc = " Craff file creation parameters; see vin0010 for a more thorough description\nof these."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct craff_params_t {
    #[doc = " log2(block size in bytes)"]
    pub block_bits: ::std::os::raw::c_int,
    #[doc = " log2(sub-blocks per block)"]
    pub sub_bits: ::std::os::raw::c_int,
    #[doc = " log2(directory entries per node)"]
    pub directory_bits: ::std::os::raw::c_int,
    pub compression: craff_compr_t,
}
#[test]
fn bindgen_test_layout_craff_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<craff_params_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<craff_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(craff_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<craff_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(craff_params_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_params_t),
            "::",
            stringify!(block_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_bits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_params_t),
            "::",
            stringify!(sub_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_params_t),
            "::",
            stringify!(directory_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compression) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_params_t),
            "::",
            stringify!(compression)
        )
    );
}
impl Default for craff_params_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct craff_info_t {
    pub size: uint64,
    pub block_bits: ::std::os::raw::c_int,
    pub sub_bits: ::std::os::raw::c_int,
    pub directory_bits: ::std::os::raw::c_int,
    pub compression: craff_compr_t,
    pub version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_craff_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<craff_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<craff_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(craff_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<craff_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(craff_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_info_t),
            "::",
            stringify!(block_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_bits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_info_t),
            "::",
            stringify!(sub_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_bits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_info_t),
            "::",
            stringify!(directory_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compression) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_info_t),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_info_t),
            "::",
            stringify!(version)
        )
    );
}
impl Default for craff_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct craff_interv_t {
    pub ofs: uint64,
    pub len: uint64,
}
#[test]
fn bindgen_test_layout_craff_interv_t() {
    const UNINIT: ::std::mem::MaybeUninit<craff_interv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<craff_interv_t>(),
        16usize,
        concat!("Size of: ", stringify!(craff_interv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<craff_interv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(craff_interv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ofs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_interv_t),
            "::",
            stringify!(ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_interv_t),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " no error"]
pub const craff_errclass_t_Craff_Err_Success: craff_errclass_t = 0;
#[doc = " out of disk space or quota"]
pub const craff_errclass_t_Craff_Err_Nospace: craff_errclass_t = 1;
#[doc = " corrupt craff file"]
pub const craff_errclass_t_Craff_Err_Corrupt: craff_errclass_t = 2;
#[doc = " wrong magic number (not a craff file)"]
pub const craff_errclass_t_Craff_Err_Notcraff: craff_errclass_t = 3;
#[doc = " not a dmg image"]
pub const craff_errclass_t_Craff_Err_Notdmg: craff_errclass_t = 4;
#[doc = " image not writable (read-only)"]
pub const craff_errclass_t_Craff_Err_ReadOnly: craff_errclass_t = 5;
#[doc = " file not found"]
pub const craff_errclass_t_Craff_Err_Notfound: craff_errclass_t = 6;
#[doc = " Unsupported feature"]
pub const craff_errclass_t_Craff_Err_Nosupport: craff_errclass_t = 7;
#[doc = " any other error"]
pub const craff_errclass_t_Craff_Err_Other: craff_errclass_t = 8;
pub type craff_errclass_t = ::std::os::raw::c_uint;
#[doc = " craff error state - can be shared between multiple file objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct craff_error {
    #[doc = " malloced, owned by this struct"]
    pub msg: *mut ::std::os::raw::c_char,
    pub errclass: craff_errclass_t,
}
#[test]
fn bindgen_test_layout_craff_error() {
    const UNINIT: ::std::mem::MaybeUninit<craff_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<craff_error>(),
        16usize,
        concat!("Size of: ", stringify!(craff_error))
    );
    assert_eq!(
        ::std::mem::align_of::<craff_error>(),
        8usize,
        concat!("Alignment of ", stringify!(craff_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_error),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errclass) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_error),
            "::",
            stringify!(errclass)
        )
    );
}
impl Default for craff_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " craff error state - can be shared between multiple file objects"]
pub type craff_error_t = craff_error;
pub const craff_mode_t_Craff_Read_Only: craff_mode_t = 0;
#[doc = " uncompressed craffs only"]
pub const craff_mode_t_Craff_Read_Write: craff_mode_t = 1;
#[doc = " craff_recover() not possible"]
pub const craff_mode_t_Craff_Read_Write_Allow_Compression: craff_mode_t = 2;
pub type craff_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct craff_interv_vec_t {
    pub size: ::std::os::raw::c_int,
    pub used: ::std::os::raw::c_int,
    pub elements: *mut craff_interv_t,
}
#[test]
fn bindgen_test_layout_craff_interv_vec_t() {
    const UNINIT: ::std::mem::MaybeUninit<craff_interv_vec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<craff_interv_vec_t>(),
        16usize,
        concat!("Size of: ", stringify!(craff_interv_vec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<craff_interv_vec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(craff_interv_vec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_interv_vec_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_interv_vec_t),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(craff_interv_vec_t),
            "::",
            stringify!(elements)
        )
    );
}
impl Default for craff_interv_vec_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn craff_new_error() -> *mut craff_error_t;
}
extern "C" {
    pub fn craff_free_error(ce: *mut craff_error_t);
}
extern "C" {
    pub fn craff_get_error_class(ce: *mut craff_error_t) -> craff_errclass_t;
}
extern "C" {
    pub fn craff_get_error(ce: *mut craff_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn craff_open(
        ce: *mut craff_error_t,
        file: *const ::std::os::raw::c_char,
        mode: craff_mode_t,
    ) -> *mut craff_file_t;
}
extern "C" {
    pub fn craff_creat(
        ce: *mut craff_error_t,
        file: *const ::std::os::raw::c_char,
        size: uint64,
        params: *mut craff_params_t,
    ) -> *mut craff_file_t;
}
extern "C" {
    pub fn craff_close(cf: *mut craff_file_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn craff_flush(cf: *mut craff_file_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn craff_recover(cf: *mut craff_file_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn craff_write(
        cf: *mut craff_file_t,
        buf: *const ::std::os::raw::c_void,
        ofs: uint64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn craff_read(
        cf: *mut craff_file_t,
        buf: *mut ::std::os::raw::c_void,
        ofs: uint64,
        len: usize,
        gaps: *mut craff_interv_vec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn craff_next_data(cf: *mut craff_file_t, ofs: uint64, limit: uint64) -> uint64;
}
extern "C" {
    pub fn craff_get_info(cf: *mut craff_file_t, info: *mut craff_info_t);
}
extern "C" {
    pub fn craff_file_error(cf: *mut craff_file_t) -> *mut craff_error_t;
}
extern "C" {
    pub fn craff_file_get_error(cf: *mut craff_file_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vhdx_file {
    _unused: [u8; 0],
}
pub type vhdx_file_t = vhdx_file;
#[doc = " UUID of the Microsoft kind. The byte-order of the on-disk format is\ndifferent from the standard representation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vhdx_muuid_t {
    #[doc = " Fields d1-d3 are apparently in little-endian order, despite the\nclaims of the VHD spec."]
    pub d1: uint32,
    pub d2: uint16,
    pub d3: uint16,
    #[doc = " In straight order (BE)."]
    pub d4: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_vhdx_muuid_t() {
    const UNINIT: ::std::mem::MaybeUninit<vhdx_muuid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vhdx_muuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(vhdx_muuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vhdx_muuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(vhdx_muuid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_muuid_t),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_muuid_t),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_muuid_t),
            "::",
            stringify!(d3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_muuid_t),
            "::",
            stringify!(d4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vhdx_info_t {
    #[doc = " From VHDX specification: \"Contains a UTF-16 string that can be null\nterminated. This field is optional; the implementation fills it in\nduring the creation of the VHDX file to identify, uniquely, the\ncreator of the VHDX file. Implementation MUST NOT use this field as\na mechanism to influence implementation behavior; it exists for\ndiagnostic purposes only.\""]
    pub creator: [::std::os::raw::c_char; 512usize],
    #[doc = " the size of the virtual disk, in bytes"]
    pub size: uint64,
    #[doc = " the virtual disk's sector size, in bytes"]
    pub logical_sector_size: uint32,
    #[doc = " the virtual disk's physical sector size, in bytes"]
    pub physical_sector_size: uint32,
    #[doc = " A GUID that specifies the identification of the disk."]
    pub virtual_disk_id: vhdx_muuid_t,
    #[doc = " A GUID that identifies the file's contents."]
    pub file_write_guid: vhdx_muuid_t,
    #[doc = " A GUID that identifies the contents of user visible data.\nIt is used for the validation of a differential VHDX chain."]
    pub data_write_guid: vhdx_muuid_t,
    #[doc = " Specifies the version of the VHDX format used\nwithin the VHDX file."]
    pub version: uint16,
    #[doc = " Specifies whether this file has a parent VHDX file. If set, the file\nis a differencing file, and one or more parent locators specify the\nlocation and identity of the parent."]
    pub has_parent: bool,
    #[doc = " the size of each payload block in bytes"]
    pub block_size: uint32,
}
#[test]
fn bindgen_test_layout_vhdx_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<vhdx_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vhdx_info_t>(),
        584usize,
        concat!("Size of: ", stringify!(vhdx_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vhdx_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vhdx_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(creator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_sector_size) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(logical_sector_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_sector_size) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(physical_sector_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virtual_disk_id) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(virtual_disk_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_write_guid) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(file_write_guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_write_guid) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(data_write_guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_parent) as usize - ptr as usize },
        578usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(has_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(vhdx_info_t),
            "::",
            stringify!(block_size)
        )
    );
}
impl Default for vhdx_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vhdx_open(
        fname: *const ::std::os::raw::c_char,
        writable: bool,
        ce: *mut craff_error_t,
    ) -> *mut vhdx_file_t;
}
extern "C" {
    pub fn vhdx_close(file: *mut vhdx_file_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhdx_write(
        file: *mut vhdx_file_t,
        buf: *const ::std::os::raw::c_void,
        ofs: uint64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhdx_read(
        file: *mut vhdx_file_t,
        buf: *mut ::std::os::raw::c_void,
        ofs: uint64,
        len: usize,
        gaps: *mut craff_interv_vec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhdx_virtual_disk_size(file: *mut vhdx_file_t) -> uint64;
}
extern "C" {
    pub fn vhdx_get_info(file: *mut vhdx_file_t, info: *mut vhdx_info_t, info_size: usize);
}
extern "C" {
    pub fn vhdx_file_error_message(file: *mut vhdx_file_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vhdx_muuid_to_str(vhdx_muuid: vhdx_muuid_t) -> *mut ::std::os::raw::c_char;
}
pub type interval_set_t = interval_set;
pub type interval_set_iter_t = interval_set_iter;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct range_node_t {
    pub start: uint64,
    pub end: uint64,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_range_node_t() {
    const UNINIT: ::std::mem::MaybeUninit<range_node_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<range_node_t>(),
        24usize,
        concat!("Size of: ", stringify!(range_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<range_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(range_node_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range_node_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(range_node_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(range_node_t),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for range_node_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interval_section {
    #[doc = " start of this section"]
    pub start: uint64,
    #[doc = " NULL if no intervals here"]
    pub intervals: *mut interval_bucket,
}
#[test]
fn bindgen_test_layout_interval_section() {
    const UNINIT: ::std::mem::MaybeUninit<interval_section> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interval_section>(),
        16usize,
        concat!("Size of: ", stringify!(interval_section))
    );
    assert_eq!(
        ::std::mem::align_of::<interval_section>(),
        8usize,
        concat!("Alignment of ", stringify!(interval_section))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_section),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intervals) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_section),
            "::",
            stringify!(intervals)
        )
    );
}
impl Default for interval_section {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interval_set {
    pub sections: interval_set__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interval_set__bindgen_ty_1 {
    pub size: ::std::os::raw::c_int,
    pub used: ::std::os::raw::c_int,
    pub elements: *mut interval_section,
}
#[test]
fn bindgen_test_layout_interval_set__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<interval_set__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interval_set__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(interval_set__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<interval_set__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(interval_set__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set__bindgen_ty_1),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set__bindgen_ty_1),
            "::",
            stringify!(elements)
        )
    );
}
impl Default for interval_set__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_interval_set() {
    const UNINIT: ::std::mem::MaybeUninit<interval_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interval_set>(),
        16usize,
        concat!("Size of: ", stringify!(interval_set))
    );
    assert_eq!(
        ::std::mem::align_of::<interval_set>(),
        8usize,
        concat!("Alignment of ", stringify!(interval_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sections) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set),
            "::",
            stringify!(sections)
        )
    );
}
impl Default for interval_set {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn init_interval(is: *mut interval_set_t, allow_overlap: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interval_set_iter {
    pub is: *const interval_set_t,
    pub start: uint64,
    pub end: uint64,
    #[doc = " section index"]
    pub sect: ::std::os::raw::c_uint,
    #[doc = " interval index"]
    pub inum: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_interval_set_iter() {
    const UNINIT: ::std::mem::MaybeUninit<interval_set_iter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interval_set_iter>(),
        32usize,
        concat!("Size of: ", stringify!(interval_set_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<interval_set_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(interval_set_iter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set_iter),
            "::",
            stringify!(is)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set_iter),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set_iter),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set_iter),
            "::",
            stringify!(sect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inum) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(interval_set_iter),
            "::",
            stringify!(inum)
        )
    );
}
impl Default for interval_set_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn new_interval(dummy: ::std::os::raw::c_int) -> *mut interval_set_t;
}
extern "C" {
    pub fn insert_interval(
        is: *mut interval_set_t,
        start: uint64,
        end: uint64,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn get_interval_ptr(
        is: *mut interval_set_t,
        address: uint64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_interval_vector(
        is: *mut interval_set_t,
        address: uint64,
        res: *mut *mut range_node_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_interval_vector_and_range(
        is: *mut interval_set_t,
        address: uint64,
        res: *mut *mut range_node_t,
        first_address: *mut uint64,
        last_address: *mut uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_lower_interval_ptr(
        is: *mut interval_set_t,
        address: uint64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_higher_interval_ptr(
        is: *mut interval_set_t,
        address: uint64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn touch_interval(
        is: *mut interval_set_t,
        start: uint64,
        end: uint64,
    ) -> ::std::os::raw::c_int;
}
pub type intervals_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: uint64,
        end: uint64,
        el: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn for_all_intervals(
        is: *mut interval_set_t,
        f: intervals_func_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn for_some_intervals(
        is: *mut interval_set_t,
        start: uint64,
        end: uint64,
        f: intervals_func_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn remove_interval(
        is: *mut interval_set_t,
        start: uint64,
        end: uint64,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn clear_interval(is: *mut interval_set_t);
}
extern "C" {
    pub fn free_interval(is: *mut interval_set_t);
}
extern "C" {
    pub fn interval_set_new_iter(
        is: *const interval_set_t,
        it: *mut interval_set_iter_t,
        start: uint64,
        end: uint64,
    );
}
extern "C" {
    pub fn interval_set_iter_next(it: *mut interval_set_iter_t) -> *mut range_node_t;
}
#[doc = " Structure for scatter/gather I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    #[doc = " Pointer to data."]
    pub iov_base: *mut ::std::os::raw::c_void,
    #[doc = " Length of data."]
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Sequenced, reliable, connection-based\nbyte streams."]
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
#[doc = " Connectionless, unreliable datagrams\nof fixed maximum length."]
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
#[doc = " Raw protocol interface."]
pub const __socket_type_SOCK_RAW: __socket_type = 3;
#[doc = " Reliably-delivered messages."]
pub const __socket_type_SOCK_RDM: __socket_type = 4;
#[doc = " Sequenced, reliable, connection-based,\ndatagrams of fixed maximum length."]
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
#[doc = " Datagram Congestion Control Protocol."]
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
#[doc = " Linux specific way of getting packets\nat the dev level.  For writing rarp and\nother similar things on the user level."]
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
#[doc = " Atomically set close-on-exec flag for the\nnew descriptor(s)."]
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
#[doc = " Atomically mark descriptor(s) as\nnon-blocking."]
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
#[doc = " Types of sockets."]
pub type __socket_type = ::std::os::raw::c_uint;
#[doc = " POSIX.1g specifies this type name for the `sa_family' member."]
pub type sa_family_t = ::std::os::raw::c_ushort;
#[doc = " Structure describing a generic socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    #[doc = " Address data."]
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    #[doc = " Force desired alignment."]
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Process out-of-band data."]
pub const MSG_OOB: _bindgen_ty_17 = 1;
#[doc = " Peek at incoming messages."]
pub const MSG_PEEK: _bindgen_ty_17 = 2;
#[doc = " Don't use local routing."]
pub const MSG_DONTROUTE: _bindgen_ty_17 = 4;
#[doc = " Control data lost before delivery."]
pub const MSG_CTRUNC: _bindgen_ty_17 = 8;
#[doc = " Supply or ask second address."]
pub const MSG_PROXY: _bindgen_ty_17 = 16;
pub const MSG_TRUNC: _bindgen_ty_17 = 32;
#[doc = " Nonblocking IO."]
pub const MSG_DONTWAIT: _bindgen_ty_17 = 64;
#[doc = " End of record."]
pub const MSG_EOR: _bindgen_ty_17 = 128;
#[doc = " Wait for a full request."]
pub const MSG_WAITALL: _bindgen_ty_17 = 256;
pub const MSG_FIN: _bindgen_ty_17 = 512;
pub const MSG_SYN: _bindgen_ty_17 = 1024;
#[doc = " Confirm path validity."]
pub const MSG_CONFIRM: _bindgen_ty_17 = 2048;
pub const MSG_RST: _bindgen_ty_17 = 4096;
#[doc = " Fetch message from error queue."]
pub const MSG_ERRQUEUE: _bindgen_ty_17 = 8192;
#[doc = " Do not generate SIGPIPE."]
pub const MSG_NOSIGNAL: _bindgen_ty_17 = 16384;
#[doc = " Sender will send more."]
pub const MSG_MORE: _bindgen_ty_17 = 32768;
#[doc = " Wait for at least one packet to return."]
pub const MSG_WAITFORONE: _bindgen_ty_17 = 65536;
#[doc = " sendmmsg: more messages coming."]
pub const MSG_BATCH: _bindgen_ty_17 = 262144;
#[doc = " Use user data in kernel path."]
pub const MSG_ZEROCOPY: _bindgen_ty_17 = 67108864;
#[doc = " Send data in TCP SYN."]
pub const MSG_FASTOPEN: _bindgen_ty_17 = 536870912;
#[doc = " Set close_on_exit for file\ndescriptor received through\nSCM_RIGHTS."]
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_17 = 1073741824;
#[doc = " Bits in the FLAGS argument to `send', `recv', et al."]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[doc = " Structure describing messages sent by\n`sendmsg' and received by `recvmsg'."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct msghdr {
    #[doc = " Address to send to/receive from."]
    pub msg_name: *mut ::std::os::raw::c_void,
    #[doc = " Length of address data."]
    pub msg_namelen: socklen_t,
    #[doc = " Vector of data to send/receive into."]
    pub msg_iov: *mut iovec,
    #[doc = " Number of elements in the vector."]
    pub msg_iovlen: usize,
    #[doc = " Ancillary data (eg BSD filedesc passing)."]
    pub msg_control: *mut ::std::os::raw::c_void,
    #[doc = " Ancillary data buffer length.\n The type should be socklen_t but the\ndefinition of the kernel is incompatible\nwith this."]
    pub msg_controllen: usize,
    #[doc = " Flags on received message."]
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure used for storage of ancillary data object information."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    #[doc = " Length of data in cmsg_data plus length\nof cmsghdr structure.\n The type should be socklen_t but the\ndefinition of the kernel is incompatible\nwith this."]
    pub cmsg_len: usize,
    #[doc = " Originating protocol."]
    pub cmsg_level: ::std::os::raw::c_int,
    #[doc = " Protocol specific type."]
    pub cmsg_type: ::std::os::raw::c_int,
    #[doc = " Ancillary data."]
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cmsg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
#[doc = " Transfer file descriptors."]
pub const SCM_RIGHTS: _bindgen_ty_18 = 1;
#[doc = " Socket level message types.  This must match the definitions in\n<linux/socket.h>."]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
#[doc = " Type of a signal handler."]
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[doc = " Type of a SYSV IPC key."]
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
#[doc = " This file is generally used by user-level software, so you need to\n be a little careful about namespace pollution etc.  Also, we cannot\n assume GCC is being used."]
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
#[doc = " anything below here should be completely generic"]
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[doc = " Structure used to manipulate the SO_LINGER option."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct linger {
    #[doc = " Nonzero to linger on close."]
    pub l_onoff: ::std::os::raw::c_int,
    #[doc = " Time to linger."]
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[doc = " This is the 4.3 BSD `struct sockaddr' format, which is used as wire\nformat in the grotty old 4.3 `talk' protocol."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<osockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[doc = " No more receptions."]
pub const SHUT_RD: _bindgen_ty_19 = 0;
#[doc = " No more transmissions."]
pub const SHUT_WR: _bindgen_ty_19 = 1;
#[doc = " No more receptions or transmissions."]
pub const SHUT_RDWR: _bindgen_ty_19 = 2;
#[doc = " The following constants should be used for the second parameter of\n`shutdown'."]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new socket of type TYPE in domain DOMAIN, using\nprotocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.\nReturns a file descriptor for the new socket, or -1 for errors."]
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create two new sockets, of type TYPE in domain DOMAIN and using\nprotocol PROTOCOL, which are connected to each other, and put file\ndescriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,\none will be chosen automatically.  Returns 0 on success, -1 for errors."]
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Give the socket FD the local address ADDR (which is LEN bytes long)."]
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the local address of FD into *ADDR and its length in *LEN."]
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a connection on socket FD to peer at ADDR (which LEN bytes long).\nFor connectionless socket types, just set the default address to send to\nand the only address from which to accept transmissions.\nReturn 0 on success, -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the address of the peer connected to socket FD into *ADDR\n(which is *LEN bytes long), and its actual length into *LEN."]
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send N bytes of BUF to socket FD.  Returns the number sent or -1.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[doc = " Read N bytes into BUF from socket FD.\nReturns the number read or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[doc = " Send N bytes of BUF on socket FD to peer at address ADDR (which is\nADDR_LEN bytes long).  Returns the number sent, or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Read N bytes into BUF through socket FD.\nIf ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of\nthe sender, and store the actual size of the address in *ADDR_LEN.\nReturns the number of bytes read or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepare to accept connections on socket FD.\nN connection requests will be queued before further requests are refused.\nReturns 0 on success, -1 for errors."]
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Await a connection on socket FD.\nWhen a connection arrives, open a new socket to communicate with it,\nset *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting\npeer and *ADDR_LEN to the address's actual length, and return the\nnew socket's descriptor, or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shut down all or part of the connection open on socket FD.\nHOW determines what to shut down:\nSHUT_RD   = No more receptions;\nSHUT_WR   = No more transmissions;\nSHUT_RDWR = No more receptions or transmissions.\nReturns 0 on success, -1 for errors."]
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine whether socket is at a out-of-band mark."]
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;\nreturns 1 if FD is open on an object of the indicated type, 0 if not,\nor -1 for errors (setting errno)."]
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type tcp_seq = u32;
#[doc = " TCP header.\n Per RFC 793, September, 1981."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " source port"]
    pub th_sport: u16,
    #[doc = " destination port"]
    pub th_dport: u16,
    #[doc = " sequence number"]
    pub th_seq: tcp_seq,
    #[doc = " acknowledgement number"]
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: u8,
    #[doc = " window"]
    pub th_win: u16,
    #[doc = " checksum"]
    pub th_sum: u16,
    #[doc = " urgent pointer"]
    pub th_urp: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<tcphdr__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_sport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_dport) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_dport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_ack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_ack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_flags) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_win) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_win)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_sum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_urp) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_urp)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<tcphdr__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack_seq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).urg_ptr) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::std::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::std::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::std::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::std::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::std::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::std::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::std::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr__bindgen_ty_1))
    );
}
impl Default for tcphdr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
}
impl Default for tcphdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TCP_ESTABLISHED: _bindgen_ty_20 = 1;
pub const TCP_SYN_SENT: _bindgen_ty_20 = 2;
pub const TCP_SYN_RECV: _bindgen_ty_20 = 3;
pub const TCP_FIN_WAIT1: _bindgen_ty_20 = 4;
pub const TCP_FIN_WAIT2: _bindgen_ty_20 = 5;
pub const TCP_TIME_WAIT: _bindgen_ty_20 = 6;
pub const TCP_CLOSE: _bindgen_ty_20 = 7;
pub const TCP_CLOSE_WAIT: _bindgen_ty_20 = 8;
pub const TCP_LAST_ACK: _bindgen_ty_20 = 9;
pub const TCP_LISTEN: _bindgen_ty_20 = 10;
#[doc = " now a valid state"]
pub const TCP_CLOSING: _bindgen_ty_20 = 11;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
#[doc = " Values for tcpi_state."]
pub type tcp_ca_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    #[doc = " Times."]
    pub tcpi_last_data_sent: u32,
    #[doc = " Not remembered, sorry."]
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    #[doc = " Metrics."]
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
#[test]
fn bindgen_test_layout_tcp_info() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_info>(),
        104usize,
        concat!("Size of: ", stringify!(tcp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_ca_state) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ca_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_retransmits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retransmits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_probes) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_probes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_backoff) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_backoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_options) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rto) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_ato) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ato)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_snd_mss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_mss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_mss) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_mss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_unacked) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_unacked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_sacked) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_sacked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_lost) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_retrans) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retrans)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_fackets) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_fackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_data_sent) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_ack_sent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_data_recv) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_ack_recv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_pmtu) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_pmtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_ssthresh) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rtt) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rttvar) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rttvar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_snd_ssthresh) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_snd_cwnd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_advmss) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_advmss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_reordering) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_reordering)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_rtt) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_rtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_space) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_total_retrans) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_total_retrans)
        )
    );
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: u8,
        tcpi_rcv_wscale: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_md5sig {
    #[doc = " Address associated."]
    pub tcpm_addr: sockaddr_storage,
    #[doc = " Extension flags."]
    pub tcpm_flags: u8,
    #[doc = " Address prefix."]
    pub tcpm_prefixlen: u8,
    #[doc = " Key length."]
    pub tcpm_keylen: u16,
    #[doc = " Zero."]
    pub __tcpm_pad: u32,
    #[doc = " Key (binary)."]
    pub tcpm_key: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_tcp_md5sig() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_md5sig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_md5sig>(),
        216usize,
        concat!("Size of: ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_md5sig>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_flags) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_prefixlen) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_prefixlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_keylen) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_keylen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__tcpm_pad) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(__tcpm_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_key) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_key)
        )
    );
}
impl Default for tcp_md5sig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " For socket repair options."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_opt() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_repair_opt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_opt>(),
        8usize,
        concat!("Size of: ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_val) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_val)
        )
    );
}
pub const TCP_NO_QUEUE: _bindgen_ty_21 = 0;
pub const TCP_RECV_QUEUE: _bindgen_ty_21 = 1;
pub const TCP_SEND_QUEUE: _bindgen_ty_21 = 2;
pub const TCP_QUEUES_NR: _bindgen_ty_21 = 3;
#[doc = " Queue to repair, for TCP_REPAIR_QUEUE."]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[test]
fn bindgen_test_layout_tcp_cookie_transactions() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_cookie_transactions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_cookie_transactions>(),
        544usize,
        concat!("Size of: ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_cookie_transactions>(),
        2usize,
        concat!("Alignment of ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__tcpct_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(__tcpct_pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_cookie_desired) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_cookie_desired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_s_data_desired) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_s_data_desired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_used) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_value)
        )
    );
}
impl Default for tcp_cookie_transactions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " For use with TCP_REPAIR_WINDOW."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_window() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_repair_window> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_window>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_window>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_wl1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_wnd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(max_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv_wnd) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv_wup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wup)
        )
    );
}
#[doc = " For use with TCP_ZEROCOPY_RECEIVE."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_zerocopy_receive {
    #[doc = " In: address of mapping."]
    pub address: u64,
    #[doc = " In/out: number of bytes to map/mapped."]
    pub length: u32,
    #[doc = " Out: amount of bytes to skip."]
    pub recv_skip_hint: u32,
}
#[test]
fn bindgen_test_layout_tcp_zerocopy_receive() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_zerocopy_receive> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_zerocopy_receive>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_zerocopy_receive>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_skip_hint) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(recv_skip_hint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct if_nameindex {
    #[doc = " 1, 2, ..."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = " null terminated name: \"eth0\", ..."]
    pub if_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_nameindex() {
    const UNINIT: ::std::mem::MaybeUninit<if_nameindex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<if_nameindex>(),
        16usize,
        concat!("Size of: ", stringify!(if_nameindex))
    );
    assert_eq!(
        ::std::mem::align_of::<if_nameindex>(),
        8usize,
        concat!("Alignment of ", stringify!(if_nameindex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).if_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nameindex),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).if_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nameindex),
            "::",
            stringify!(if_name)
        )
    );
}
impl Default for if_nameindex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Interface is up."]
pub const IFF_UP: _bindgen_ty_22 = 1;
#[doc = " Broadcast address valid."]
pub const IFF_BROADCAST: _bindgen_ty_22 = 2;
#[doc = " Turn on debugging."]
pub const IFF_DEBUG: _bindgen_ty_22 = 4;
#[doc = " Is a loopback net."]
pub const IFF_LOOPBACK: _bindgen_ty_22 = 8;
#[doc = " Interface is point-to-point link."]
pub const IFF_POINTOPOINT: _bindgen_ty_22 = 16;
#[doc = " Avoid use of trailers."]
pub const IFF_NOTRAILERS: _bindgen_ty_22 = 32;
#[doc = " Resources allocated."]
pub const IFF_RUNNING: _bindgen_ty_22 = 64;
#[doc = " No address resolution protocol."]
pub const IFF_NOARP: _bindgen_ty_22 = 128;
#[doc = " Receive all packets."]
pub const IFF_PROMISC: _bindgen_ty_22 = 256;
#[doc = " Receive all multicast packets."]
pub const IFF_ALLMULTI: _bindgen_ty_22 = 512;
#[doc = " Master of a load balancer."]
pub const IFF_MASTER: _bindgen_ty_22 = 1024;
#[doc = " Slave of a load balancer."]
pub const IFF_SLAVE: _bindgen_ty_22 = 2048;
#[doc = " Supports multicast."]
pub const IFF_MULTICAST: _bindgen_ty_22 = 4096;
#[doc = " Can set media type."]
pub const IFF_PORTSEL: _bindgen_ty_22 = 8192;
#[doc = " Auto media select active."]
pub const IFF_AUTOMEDIA: _bindgen_ty_22 = 16384;
#[doc = " Dialup device with changing addresses."]
pub const IFF_DYNAMIC: _bindgen_ty_22 = 32768;
#[doc = " Standard interface flags."]
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[doc = " The ifaddr structure contains information about one address of an\ninterface.  They are maintained by the different address families,\nare allocated and attached when an address is set, and are linked\ntogether so all addresses for an interface can be located."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifaddr {
    #[doc = " Address of interface."]
    pub ifa_addr: sockaddr,
    pub ifa_ifu: ifaddr__bindgen_ty_1,
    #[doc = " Back-pointer to interface."]
    pub ifa_ifp: *mut iface,
    #[doc = " Next address for interface."]
    pub ifa_next: *mut ifaddr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifaddr__bindgen_ty_1 {
    pub ifu_broadaddr: sockaddr,
    pub ifu_dstaddr: sockaddr,
}
#[test]
fn bindgen_test_layout_ifaddr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ifaddr__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifaddr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ifaddr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaddr__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ifaddr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifu_broadaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddr__bindgen_ty_1),
            "::",
            stringify!(ifu_broadaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifu_dstaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddr__bindgen_ty_1),
            "::",
            stringify!(ifu_dstaddr)
        )
    );
}
impl Default for ifaddr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_ifaddr() {
    const UNINIT: ::std::mem::MaybeUninit<ifaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifaddr>(),
        48usize,
        concat!("Size of: ", stringify!(ifaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaddr>(),
        8usize,
        concat!("Alignment of ", stringify!(ifaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddr),
            "::",
            stringify!(ifa_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_ifu) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddr),
            "::",
            stringify!(ifa_ifu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_ifp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddr),
            "::",
            stringify!(ifa_ifp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddr),
            "::",
            stringify!(ifa_next)
        )
    );
}
impl Default for ifaddr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Device mapping structure. I'd just gone off and designed a\nbeautiful scheme using only loadable modules with arguments for\ndriver options and along come the PCMCIA people 8)\n\nAh well. The get() side of this is good for WDSETUP, and it'll be\nhandy for debugging things. The set side is fine for now and being\nvery small might be worth keeping for clean configuration."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ifmap {
    pub mem_start: ::std::os::raw::c_ulong,
    pub mem_end: ::std::os::raw::c_ulong,
    pub base_addr: ::std::os::raw::c_ushort,
    pub irq: ::std::os::raw::c_uchar,
    pub dma: ::std::os::raw::c_uchar,
    pub port: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ifmap() {
    const UNINIT: ::std::mem::MaybeUninit<ifmap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifmap>(),
        24usize,
        concat!("Size of: ", stringify!(ifmap))
    );
    assert_eq!(
        ::std::mem::align_of::<ifmap>(),
        8usize,
        concat!("Alignment of ", stringify!(ifmap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(mem_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(mem_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irq) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dma) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(port)
        )
    );
}
#[doc = " Interface request structure used for socket ioctl's.  All interface\nioctl's must have parameter definitions which begin with ifr_name.\nThe remainder may be interface specific."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    #[doc = " Interface name, e.g. \"en0\"."]
    pub ifrn_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ifreq__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifreq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ifreq__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ifreq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifrn_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_1),
            "::",
            stringify!(ifrn_name)
        )
    );
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_2 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: ::std::os::raw::c_short,
    pub ifru_ivalue: ::std::os::raw::c_int,
    pub ifru_mtu: ::std::os::raw::c_int,
    pub ifru_map: ifmap,
    #[doc = " Just fits the size"]
    pub ifru_slave: [::std::os::raw::c_char; 16usize],
    pub ifru_newname: [::std::os::raw::c_char; 16usize],
    pub ifru_data: __caddr_t,
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ifreq__bindgen_ty_2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifreq__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(ifreq__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_dstaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_dstaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_broadaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_broadaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_netmask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_hwaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_hwaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_ivalue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_ivalue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_mtu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_slave) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_slave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_newname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_newname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifru_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_data)
        )
    );
}
impl Default for ifreq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_ifreq() {
    const UNINIT: ::std::mem::MaybeUninit<ifreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifreq>(),
        40usize,
        concat!("Size of: ", stringify!(ifreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifr_ifrn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq),
            "::",
            stringify!(ifr_ifrn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifr_ifru) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq),
            "::",
            stringify!(ifr_ifru)
        )
    );
}
impl Default for ifreq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure used in SIOCGIFCONF request.  Used to retrieve interface\nconfiguration for machine (useful for programs which must know all\nnetworks accessible)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    #[doc = " Size of buffer."]
    pub ifc_len: ::std::os::raw::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: __caddr_t,
    pub ifcu_req: *mut ifreq,
}
#[test]
fn bindgen_test_layout_ifconf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ifconf__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifconf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ifconf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifconf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ifconf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifcu_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifconf__bindgen_ty_1),
            "::",
            stringify!(ifcu_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifcu_req) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifconf__bindgen_ty_1),
            "::",
            stringify!(ifcu_req)
        )
    );
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_ifconf() {
    const UNINIT: ::std::mem::MaybeUninit<ifconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifconf>(),
        16usize,
        concat!("Size of: ", stringify!(ifconf))
    );
    assert_eq!(
        ::std::mem::align_of::<ifconf>(),
        8usize,
        concat!("Alignment of ", stringify!(ifconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifc_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifconf),
            "::",
            stringify!(ifc_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifc_ifcu) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ifconf),
            "::",
            stringify!(ifc_ifcu)
        )
    );
}
impl Default for ifconf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Convert an interface name to an index, and vice versa."]
    pub fn if_nametoindex(__ifname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn if_indextoname(
        __ifindex: ::std::os::raw::c_uint,
        __ifname: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a list of all interfaces and their indices."]
    pub fn if_nameindex() -> *mut if_nameindex;
}
extern "C" {
    #[doc = " Free the data returned from if_nameindex."]
    pub fn if_freenameindex(__ptr: *mut if_nameindex);
}
#[doc = " __xx is ok: it doesn't pollute the POSIX namespace. Use these in the\n header files exported to user space"]
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ethhdr {
    #[doc = " destination eth addr"]
    pub h_dest: [::std::os::raw::c_uchar; 6usize],
    #[doc = " source ether addr"]
    pub h_source: [::std::os::raw::c_uchar; 6usize],
    #[doc = " packet type ID field"]
    pub h_proto: __be16,
}
#[test]
fn bindgen_test_layout_ethhdr() {
    const UNINIT: ::std::mem::MaybeUninit<ethhdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethhdr>(),
        14usize,
        concat!("Size of: ", stringify!(ethhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ethhdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ethhdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_dest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_source) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_proto) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_proto)
        )
    );
}
#[doc = " This is a name for the 48 bit ethernet address available on many\nsystems."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ether_addr {
    pub ether_addr_octet: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    const UNINIT: ::std::mem::MaybeUninit<ether_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ether_addr_octet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_addr),
            "::",
            stringify!(ether_addr_octet)
        )
    );
}
#[doc = " 10Mb/s ethernet header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ether_header {
    #[doc = " destination eth addr"]
    pub ether_dhost: [u8; 6usize],
    #[doc = " source ether addr"]
    pub ether_shost: [u8; 6usize],
    #[doc = " packet type ID field"]
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_ether_header() {
    const UNINIT: ::std::mem::MaybeUninit<ether_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ether_header>(),
        14usize,
        concat!("Size of: ", stringify!(ether_header))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_header>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ether_dhost) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_header),
            "::",
            stringify!(ether_dhost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ether_shost) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_header),
            "::",
            stringify!(ether_shost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ether_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_header),
            "::",
            stringify!(ether_type)
        )
    );
}
#[doc = " See RFC 826 for protocol description.  ARP packets are variable\nin size; the arphdr structure defines the fixed-length portion.\nProtocol type values are the same as those for 10 Mb/s Ethernet.\nIt is followed by the variable-sized fields ar_sha, arp_spa,\narp_tha and arp_tpa in that order, according to the lengths\nspecified.  Field names used correspond to RFC 826."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arphdr {
    #[doc = " Format of hardware address."]
    pub ar_hrd: ::std::os::raw::c_ushort,
    #[doc = " Format of protocol address."]
    pub ar_pro: ::std::os::raw::c_ushort,
    #[doc = " Length of hardware address."]
    pub ar_hln: ::std::os::raw::c_uchar,
    #[doc = " Length of protocol address."]
    pub ar_pln: ::std::os::raw::c_uchar,
    #[doc = " ARP opcode (command)."]
    pub ar_op: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_arphdr() {
    const UNINIT: ::std::mem::MaybeUninit<arphdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arphdr>(),
        8usize,
        concat!("Size of: ", stringify!(arphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<arphdr>(),
        2usize,
        concat!("Alignment of ", stringify!(arphdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_hrd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arphdr),
            "::",
            stringify!(ar_hrd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_pro) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arphdr),
            "::",
            stringify!(ar_pro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_hln) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arphdr),
            "::",
            stringify!(ar_hln)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_pln) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arphdr),
            "::",
            stringify!(ar_pln)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_op) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arphdr),
            "::",
            stringify!(ar_op)
        )
    );
}
#[doc = " ARP ioctl request."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arpreq {
    #[doc = " Protocol address."]
    pub arp_pa: sockaddr,
    #[doc = " Hardware address."]
    pub arp_ha: sockaddr,
    #[doc = " Flags."]
    pub arp_flags: ::std::os::raw::c_int,
    #[doc = " Netmask (only for proxy arps)."]
    pub arp_netmask: sockaddr,
    pub arp_dev: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_arpreq() {
    const UNINIT: ::std::mem::MaybeUninit<arpreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arpreq>(),
        68usize,
        concat!("Size of: ", stringify!(arpreq))
    );
    assert_eq!(
        ::std::mem::align_of::<arpreq>(),
        4usize,
        concat!("Alignment of ", stringify!(arpreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_pa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq),
            "::",
            stringify!(arp_pa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_ha) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq),
            "::",
            stringify!(arp_ha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq),
            "::",
            stringify!(arp_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_netmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq),
            "::",
            stringify!(arp_netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_dev) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq),
            "::",
            stringify!(arp_dev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arpreq_old {
    #[doc = " Protocol address."]
    pub arp_pa: sockaddr,
    #[doc = " Hardware address."]
    pub arp_ha: sockaddr,
    #[doc = " Flags."]
    pub arp_flags: ::std::os::raw::c_int,
    #[doc = " Netmask (only for proxy arps)."]
    pub arp_netmask: sockaddr,
}
#[test]
fn bindgen_test_layout_arpreq_old() {
    const UNINIT: ::std::mem::MaybeUninit<arpreq_old> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arpreq_old>(),
        52usize,
        concat!("Size of: ", stringify!(arpreq_old))
    );
    assert_eq!(
        ::std::mem::align_of::<arpreq_old>(),
        4usize,
        concat!("Alignment of ", stringify!(arpreq_old))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_pa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq_old),
            "::",
            stringify!(arp_pa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_ha) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq_old),
            "::",
            stringify!(arp_ha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq_old),
            "::",
            stringify!(arp_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_netmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(arpreq_old),
            "::",
            stringify!(arp_netmask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arpd_request {
    #[doc = " Request type."]
    pub req: ::std::os::raw::c_ushort,
    #[doc = " IP address of entry."]
    pub ip: u32,
    #[doc = " Device entry is tied to."]
    pub dev: ::std::os::raw::c_ulong,
    pub stamp: ::std::os::raw::c_ulong,
    pub updated: ::std::os::raw::c_ulong,
    #[doc = " Hardware address."]
    pub ha: [::std::os::raw::c_uchar; 7usize],
}
#[test]
fn bindgen_test_layout_arpd_request() {
    const UNINIT: ::std::mem::MaybeUninit<arpd_request> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arpd_request>(),
        40usize,
        concat!("Size of: ", stringify!(arpd_request))
    );
    assert_eq!(
        ::std::mem::align_of::<arpd_request>(),
        8usize,
        concat!("Alignment of ", stringify!(arpd_request))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arpd_request),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arpd_request),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arpd_request),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arpd_request),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).updated) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arpd_request),
            "::",
            stringify!(updated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ha) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arpd_request),
            "::",
            stringify!(ha)
        )
    );
}
#[doc = " Ethernet Address Resolution Protocol.\n\n See RFC 826 for protocol description.  Structure below is adapted\n to resolving internet addresses.  Field names used correspond to\n RFC 826."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ether_arp {
    #[doc = " fixed-size header"]
    pub ea_hdr: arphdr,
    #[doc = " sender hardware address"]
    pub arp_sha: [u8; 6usize],
    #[doc = " sender protocol address"]
    pub arp_spa: [u8; 4usize],
    #[doc = " target hardware address"]
    pub arp_tha: [u8; 6usize],
    #[doc = " target protocol address"]
    pub arp_tpa: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_ether_arp() {
    const UNINIT: ::std::mem::MaybeUninit<ether_arp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ether_arp>(),
        28usize,
        concat!("Size of: ", stringify!(ether_arp))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_arp>(),
        2usize,
        concat!("Alignment of ", stringify!(ether_arp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ea_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_arp),
            "::",
            stringify!(ea_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_sha) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_arp),
            "::",
            stringify!(arp_sha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_spa) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_arp),
            "::",
            stringify!(arp_spa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_tha) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_arp),
            "::",
            stringify!(arp_tha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arp_tpa) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_arp),
            "::",
            stringify!(arp_tpa)
        )
    );
}
extern "C" {
    #[doc = " Open the shared object FILE and map it in; return a handle that can be\npassed to `dlsym' to get symbol values from it."]
    pub fn dlopen(
        __file: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Unmap and close a shared object opened by `dlopen'.\nThe handle cannot be used again after calling `dlclose'."]
    pub fn dlclose(__handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the run-time address in the shared object HANDLE refers to\nof the symbol called NAME."]
    pub fn dlsym(
        __handle: *mut ::std::os::raw::c_void,
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " When any of the above functions fails, call this function\nto return a string describing the error.  Each call resets\nthe error string so that a following call returns null."]
    pub fn dlerror() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vtether_aton_r(
        a: *const ::std::os::raw::c_char,
        fill: *mut ether_addr,
    ) -> *mut ether_addr;
}
extern "C" {
    pub fn vtether_ntoa_r(
        n: *const ether_addr,
        fill: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vtinet_ntoa_r(
        ip: uint32,
        fill: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vtinet_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        dstlen: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_state {
    _unused: [u8; 0],
}
pub type rand_state_t = rand_state;
extern "C" {
    pub fn genrand_init(s: uint32) -> *mut rand_state_t;
}
extern "C" {
    pub fn genrand_init_array(
        init_key: *mut uint32,
        key_length: ::std::os::raw::c_uint,
    ) -> *mut rand_state_t;
}
extern "C" {
    pub fn genrand_destroy(rs: *mut rand_state_t);
}
extern "C" {
    pub fn genrand_uint32(rs: *mut rand_state_t) -> uint32;
}
extern "C" {
    pub fn genrand_uint64(rs: *mut rand_state_t) -> uint64;
}
extern "C" {
    pub fn genrand_range(rs: *mut rand_state_t, max: uint64) -> uint64;
}
extern "C" {
    pub fn genrand_double(rs: *mut rand_state_t) -> f64;
}
extern "C" {
    pub fn genrand_serialization(rs: *const rand_state_t) -> bytes_t;
}
extern "C" {
    pub fn genrand_restore(rs: *mut rand_state_t, serialization: bytes_t) -> bool;
}
extern "C" {
    pub fn init_vtutils();
}
extern "C" {
    pub fn vtutils_set_low_memory_handler(f: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn vtutils_set_assert_error_handler(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                line: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                mod_date: *const ::std::os::raw::c_char,
                message: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
extern "C" {
    pub fn vtutils_set_fatal_error_handler(
        f: ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct str_vec_t {
    pub v: str_vec_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct str_vec_t__bindgen_ty_1 {
    pub size: ::std::os::raw::c_int,
    pub used: ::std::os::raw::c_int,
    pub elements: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_str_vec_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<str_vec_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<str_vec_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(str_vec_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<str_vec_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(str_vec_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(str_vec_t__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(str_vec_t__bindgen_ty_1),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(str_vec_t__bindgen_ty_1),
            "::",
            stringify!(elements)
        )
    );
}
impl Default for str_vec_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_str_vec_t() {
    const UNINIT: ::std::mem::MaybeUninit<str_vec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<str_vec_t>(),
        16usize,
        concat!("Size of: ", stringify!(str_vec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<str_vec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(str_vec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(str_vec_t),
            "::",
            stringify!(v)
        )
    );
}
impl Default for str_vec_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn str_vec_free(sv: *mut str_vec_t);
}
extern "C" {
    pub fn str_vec_add(sv: *mut str_vec_t, s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn str_vec_add_stealing(sv: *mut str_vec_t, s: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn str_vec_sort(sv: *mut str_vec_t);
}
extern "C" {
    pub fn str_vec_find(
        sv: *const str_vec_t,
        s: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn str_vec_remove(sv: *mut str_vec_t, s: *const ::std::os::raw::c_char);
}
pub type os_dlhandle_t = *mut ::std::os::raw::c_void;
pub type os_dlsymbol_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn os_dlopen(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> os_dlhandle_t;
}
extern "C" {
    pub fn os_dlclose(handle: os_dlhandle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_dllookup(
        handle: os_dlhandle_t,
        symbol: *const ::std::os::raw::c_char,
    ) -> os_dlsymbol_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct os_dlinfo_t {
    #[doc = " Name of symbol at or before queried addr\n(statically allocated). May be NULL."]
    pub sym_name: *const ::std::os::raw::c_char,
    #[doc = " symbol start address"]
    pub sym_base: *mut ::std::os::raw::c_void,
    #[doc = " file queried addr belongs to"]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " file start address"]
    pub file_base: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_os_dlinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<os_dlinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<os_dlinfo_t>(),
        32usize,
        concat!("Size of: ", stringify!(os_dlinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<os_dlinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(os_dlinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(os_dlinfo_t),
            "::",
            stringify!(sym_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(os_dlinfo_t),
            "::",
            stringify!(sym_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(os_dlinfo_t),
            "::",
            stringify!(file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(os_dlinfo_t),
            "::",
            stringify!(file_base)
        )
    );
}
impl Default for os_dlinfo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn os_dladdr(addr: *mut ::std::os::raw::c_void, ret: *mut os_dlinfo_t) -> bool;
}
extern "C" {
    pub fn os_get_last_error() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_last_error_was_error() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_describe_last_error() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_describe_last_dlerror() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_describe_last_socket_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_get_file_size(filename: *const ::std::os::raw::c_char) -> int64;
}
extern "C" {
    pub fn os_file_exists(filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn os_listdir(dir: *const ::std::os::raw::c_char) -> *mut str_vec_t;
}
extern "C" {
    pub fn os_normalize_path(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_isdir(arg1: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn os_isfile(filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn os_isabs(path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn os_mkdir(
        filename: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_chdir(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_getcwd() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_getcwd_nice() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_absolutify(
        path: *const ::std::os::raw::c_char,
        base: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Using os_[f]open instead of [f]open ensures that shortcuts are\nproperly followed under Windows."]
    pub fn os_fopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn os_fclose(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_basename(path: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_path_join(path: *mut strbuf_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn os_clean_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn os_open(
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_open_vararg(
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_lseek(fd: ::std::os::raw::c_int, off: int64, whence: ::std::os::raw::c_int) -> int64;
}
extern "C" {
    pub fn os_ftruncate(fd: ::std::os::raw::c_int, newsize: uint64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_make_sparse(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_pread(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        nbyte: usize,
        offset: uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_pwrite(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        nbyte: usize,
        offset: uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_close_descriptors(from: ::std::os::raw::c_int, except: ::std::os::raw::c_int);
}
pub const os_socket_status_t_Os_No_Error: os_socket_status_t = 0;
pub const os_socket_status_t_Os_Connection_Refused: os_socket_status_t = 1;
pub const os_socket_status_t_Os_Connection_Reset: os_socket_status_t = 2;
pub const os_socket_status_t_Os_Timed_Out: os_socket_status_t = 3;
pub const os_socket_status_t_Os_Net_Unreach: os_socket_status_t = 4;
pub const os_socket_status_t_Os_Host_Unreach: os_socket_status_t = 5;
pub const os_socket_status_t_Os_In_Progress: os_socket_status_t = 6;
pub const os_socket_status_t_Os_Other: os_socket_status_t = 7;
pub type os_socket_status_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn os_initialize_sockets();
}
extern "C" {
    pub fn os_socket_close(sock: socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_socket_write(
        central_fd: socket_t,
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_socket_write_non_blocking(
        central_fd: socket_t,
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_set_socket_blocking(s: socket_t, blocking: bool);
}
extern "C" {
    pub fn os_socket_read(
        central_fd: socket_t,
        buf: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_gethostname() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_set_socket_non_blocking(s: socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_set_socket_reuseaddr(s: socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_set_socket_nodelay(s: socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_socket_connect(
        s: socket_t,
        serv_addr: *const sockaddr,
        addr_len: usize,
    ) -> os_socket_status_t;
}
extern "C" {
    pub fn os_socket_get_status(s: socket_t) -> os_socket_status_t;
}
extern "C" {
    pub fn os_last_socket_error() -> os_socket_status_t;
}
extern "C" {
    pub fn os_copy(
        src: *const ::std::os::raw::c_char,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_rename(
        src: *const ::std::os::raw::c_char,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_dirname(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_quote_filename(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_remove(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_rmdir(dirname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_access(
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_millisleep(t: ::std::os::raw::c_int);
}
extern "C" {
    pub fn os_current_time() -> uint64;
}
extern "C" {
    pub fn os_current_time_us() -> uint64;
}
extern "C" {
    pub fn os_user_cpu_time_us() -> uint64;
}
extern "C" {
    pub fn os_get_library_path() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_getpid() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn os_host_phys_mem_size() -> uint64;
}
extern "C" {
    pub fn os_host_virt_mem_size() -> uint64;
}
extern "C" {
    pub fn os_host_ncpus() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn os_is_same_file(
        name1: *const ::std::os::raw::c_char,
        name2: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn os_make_readable_path(
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_dir_contains_path(
        parent: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn os_create_unique_autoremoved_file(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct os_stat_t {
    #[doc = " File size in bytes."]
    pub size: uint64,
    #[doc = " Last modification time, in seconds from epoch."]
    pub mtime: uint64,
}
#[test]
fn bindgen_test_layout_os_stat_t() {
    const UNINIT: ::std::mem::MaybeUninit<os_stat_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<os_stat_t>(),
        16usize,
        concat!("Size of: ", stringify!(os_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<os_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(os_stat_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(os_stat_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(os_stat_t),
            "::",
            stringify!(mtime)
        )
    );
}
extern "C" {
    pub fn os_stat(
        file: *const ::std::os::raw::c_char,
        result: *mut os_stat_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_get_user_name() -> *mut ::std::os::raw::c_char;
}
pub const os_mmap_flags_t_Os_Mmap_Read: os_mmap_flags_t = 1;
pub const os_mmap_flags_t_Os_Mmap_Write: os_mmap_flags_t = 2;
pub const os_mmap_flags_t_Os_Mmap_Exec: os_mmap_flags_t = 4;
#[doc = " Writes are shared and take effect in the file;\notherwise they are private."]
pub const os_mmap_flags_t_Os_Mmap_Shared: os_mmap_flags_t = 8;
pub type os_mmap_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn os_mmap(
        fd: ::std::os::raw::c_int,
        offset: uint64,
        size: uint64,
        flags: os_mmap_flags_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn os_munmap(block: *mut ::std::os::raw::c_void, size: uint64);
}
extern "C" {
    pub fn os_set_thread_name(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn os_get_thread_name(name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn os_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_path_expand_user(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_realpath(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_get_process_binary_path() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn os_rmenv(name: *const ::std::os::raw::c_char);
}
pub type os_char_t = ::std::os::raw::c_char;
extern "C" {
    pub fn initialize_encoding();
}
extern "C" {
    pub fn VT_simics_to_filename(ustr: *const ::std::os::raw::c_char) -> *mut os_char_t;
}
pub const vtopt_arguments_vtopt_no_argument: vtopt_arguments = 0;
pub const vtopt_arguments_vtopt_required_argument: vtopt_arguments = 1;
pub const vtopt_arguments_vtopt_optional_argument: vtopt_arguments = 2;
pub type vtopt_arguments = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vtoption {
    pub name: *const ::std::os::raw::c_char,
    pub has_arg: vtopt_arguments,
    pub flag: *mut ::std::os::raw::c_int,
    pub val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vtoption() {
    const UNINIT: ::std::mem::MaybeUninit<vtoption> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vtoption>(),
        32usize,
        concat!("Size of: ", stringify!(vtoption))
    );
    assert_eq!(
        ::std::mem::align_of::<vtoption>(),
        8usize,
        concat!("Alignment of ", stringify!(vtoption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vtoption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vtoption),
            "::",
            stringify!(has_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vtoption),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vtoption),
            "::",
            stringify!(val)
        )
    );
}
impl Default for vtoption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn get_vtoptind() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_vtopterr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_vtoptopt() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_vtoptarg() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vtgetopt_long(
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
        optstring: *const ::std::os::raw::c_char,
        longopts: *const vtoption,
        longindex: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vtgetopt_restart();
}
extern "C" {
    pub fn double_hex_str(
        buf: *mut ::std::os::raw::c_char,
        _d: f64,
        type_: ::std::os::raw::c_int,
        sign: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fphex_strtod(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
pub type vga_update_interface_t = vga_update_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vga_update_interface {
    pub refresh: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub refresh_all: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_vga_update_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vga_update_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vga_update_interface>(),
        16usize,
        concat!("Size of: ", stringify!(vga_update_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vga_update_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vga_update_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_update_interface),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh_all) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_update_interface),
            "::",
            stringify!(refresh_all)
        )
    );
}
#[doc = " 0xII"]
pub const gfx_con_pixel_fmt_t_GFX_8BIT_INDEXED: gfx_con_pixel_fmt_t = 8;
#[doc = " 0bRRRRRGGGGGGBBBBB"]
pub const gfx_con_pixel_fmt_t_GFX_RGB_565: gfx_con_pixel_fmt_t = 16;
#[doc = " 0xRRGGBB"]
pub const gfx_con_pixel_fmt_t_GFX_RGB_888: gfx_con_pixel_fmt_t = 24;
#[doc = " 0xXXRRGGBB (X=unused)"]
pub const gfx_con_pixel_fmt_t_GFX_xRGB_8888: gfx_con_pixel_fmt_t = 32;
#[doc = " <add id=\"gfx_con_pixel_fmt_t DOC\">\n<ndx>gfx_con_pixel_fmt_t</ndx>\n<name index=\"true\">gfx_con_pixel_fmt_t</name>\n<doc>\n\n<doc-item name=\"NAME\">gfx_con_pixel_fmt_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> These constants are used when calling the\n<fun>put_block</fun> method in the <iface>gfx_con</iface>, to specify the\npixel format of the provided buffer.\n\nSpecifying <tt>GFX_8BIT_INDEXED</tt> means that the buffer uses VGA style\n8-bit per pixel indexed colors, and that the console palette, specified by\nthe <fun>set_color</fun> method, should be used.\n\nSpecifying <tt>GFX_RGB_565</tt> means that the buffer uses 16 bits per\npixel, with format <tt>0bRRRRRGGGGGGBBBBB</tt> (in little endian).\n\nSpecifying <tt>GFX_RGB_888</tt> means that the buffer uses 24 bits per\npixel, with format <tt>0xRRGGBB</tt> (in little endian).\n\nSpecifying <tt>GFX_xRGB_8888</tt> means that the buffer uses 32 bits per\npixel, with format <tt>0xXXRRGGBB</tt> (in little endian), where <tt>X</tt>\nis unused.\n</doc-item>\n</doc></add>"]
pub type gfx_con_pixel_fmt_t = ::std::os::raw::c_uint;
pub type gfx_con_interface_t = gfx_con_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gfx_con_interface {
    pub set_color: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            index: uint8,
            r: uint8,
            g: uint8,
            b: uint8,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    pub put_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            index: uint8,
        ),
    >,
    pub put_pixel_rgb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            rgb: uint32,
        ),
    >,
    pub put_block_old: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            src: *mut uint8,
            minx: ::std::os::raw::c_int,
            miny: ::std::os::raw::c_int,
            maxx: ::std::os::raw::c_int,
            maxy: ::std::os::raw::c_int,
            src_fmt: ::std::os::raw::c_int,
            src_stride: ::std::os::raw::c_int,
            unused: ::std::os::raw::c_int,
        ),
    >,
    pub redraw: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub update_keyboard_leds: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, led_change: ::std::os::raw::c_int),
    >,
    pub put_pixel_col: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            r: ::std::os::raw::c_int,
            g: ::std::os::raw::c_int,
            b: ::std::os::raw::c_int,
        ),
    >,
    pub put_block: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            block: bytes_t,
            minx: ::std::os::raw::c_int,
            miny: ::std::os::raw::c_int,
            maxx: ::std::os::raw::c_int,
            maxy: ::std::os::raw::c_int,
            src_fmt: gfx_con_pixel_fmt_t,
            src_stride: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_gfx_con_interface() {
    const UNINIT: ::std::mem::MaybeUninit<gfx_con_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gfx_con_interface>(),
        72usize,
        concat!("Size of: ", stringify!(gfx_con_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<gfx_con_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(gfx_con_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(set_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put_pixel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(put_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put_pixel_rgb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(put_pixel_rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put_block_old) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(put_block_old)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).redraw) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(redraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_keyboard_leds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(update_keyboard_leds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put_pixel_col) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(put_pixel_col)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put_block) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_con_interface),
            "::",
            stringify!(put_block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_instrumentation_info {
    _unused: [u8; 0],
}
pub type instruction_handle_t = cpu_instrumentation_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_memory_info {
    _unused: [u8; 0],
}
pub type memory_handle_t = cpu_memory_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_replace_info {
    _unused: [u8; 0],
}
pub type decoder_handle_t = cpu_replace_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_exception_info {
    _unused: [u8; 0],
}
pub type exception_handle_t = cpu_exception_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_exception_return_info {
    _unused: [u8; 0],
}
pub type exception_return_handle_t = cpu_exception_return_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_address_info {
    _unused: [u8; 0],
}
pub type address_handle_t = cpu_address_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cached_instruction_data {
    _unused: [u8; 0],
}
pub type cached_instruction_handle_t = cached_instruction_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct instrumentation_entry {
    _unused: [u8; 0],
}
pub type cpu_cb_handle_t = instrumentation_entry;
pub type cpu_stream_handle_t = instrumentation_entry;
#[doc = " <add-type id=\"cpu_bytes_t\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_bytes {
    pub size: usize,
    pub data: *const uint8,
}
#[test]
fn bindgen_test_layout_cpu_bytes() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_bytes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_bytes>(),
        16usize,
        concat!("Size of: ", stringify!(cpu_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_bytes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_bytes),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_bytes),
            "::",
            stringify!(data)
        )
    );
}
impl Default for cpu_bytes {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"cpu_bytes_t\"></add-type>"]
pub type cpu_bytes_t = cpu_bytes;
pub type cpu_instruction_query_interface_t = cpu_instruction_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_instruction_query_interface {
    pub logical_address: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut instruction_handle_t,
        ) -> logical_address_t,
    >,
    pub physical_address: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut instruction_handle_t,
        ) -> physical_address_t,
    >,
    pub get_instruction_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut instruction_handle_t,
        ) -> cpu_bytes_t,
    >,
}
#[test]
fn bindgen_test_layout_cpu_instruction_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_instruction_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_instruction_query_interface>(),
        24usize,
        concat!("Size of: ", stringify!(cpu_instruction_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_instruction_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_instruction_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instruction_query_interface),
            "::",
            stringify!(logical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instruction_query_interface),
            "::",
            stringify!(physical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_instruction_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instruction_query_interface),
            "::",
            stringify!(get_instruction_bytes)
        )
    );
}
pub const page_crossing_info_t_Sim_Page_Crossing_None: page_crossing_info_t = 0;
pub const page_crossing_info_t_Sim_Page_Crossing_First: page_crossing_info_t = 1;
pub const page_crossing_info_t_Sim_Page_Crossing_Second: page_crossing_info_t = 2;
#[doc = " <add-type id=\"page_crossing_info_t\">\nStates the type of memory accesses related to page crossings.\n</add-type>"]
pub type page_crossing_info_t = ::std::os::raw::c_uint;
pub type cpu_memory_query_interface_t = cpu_memory_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_memory_query_interface {
    pub logical_address: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut memory_handle_t,
        ) -> logical_address_t,
    >,
    pub physical_address: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut memory_handle_t,
        ) -> physical_address_t,
    >,
    pub set_host_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut memory_handle_t,
            p: *mut ::std::os::raw::c_void,
        ),
    >,
    pub get_bytes: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut memory_handle_t) -> cpu_bytes_t,
    >,
    pub set_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut memory_handle_t,
            bytes: cpu_bytes_t,
        ),
    >,
    pub atomic: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: *mut memory_handle_t) -> bool,
    >,
    pub arch: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: *mut memory_handle_t) -> ini_type_t,
    >,
    pub get_page_crossing_info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: *mut memory_handle_t,
        ) -> page_crossing_info_t,
    >,
    pub get_surrounding_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut memory_handle_t,
            granularity_log2: ::std::os::raw::c_uint,
        ) -> buffer_t,
    >,
}
#[test]
fn bindgen_test_layout_cpu_memory_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_memory_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_memory_query_interface>(),
        72usize,
        concat!("Size of: ", stringify!(cpu_memory_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_memory_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_memory_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(logical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(physical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_host_ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(set_host_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_bytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(get_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_bytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(set_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atomic) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(atomic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_page_crossing_info) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(get_page_crossing_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_surrounding_bytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_memory_query_interface),
            "::",
            stringify!(get_surrounding_bytes)
        )
    );
}
pub type cpu_exception_query_interface_t = cpu_exception_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_exception_query_interface {
    pub exception_number: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut exception_handle_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub fault_pc: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut exception_handle_t,
        ) -> logical_address_t,
    >,
}
#[test]
fn bindgen_test_layout_cpu_exception_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_exception_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_exception_query_interface>(),
        16usize,
        concat!("Size of: ", stringify!(cpu_exception_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_exception_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_exception_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_exception_query_interface),
            "::",
            stringify!(exception_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fault_pc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_exception_query_interface),
            "::",
            stringify!(fault_pc)
        )
    );
}
#[doc = " <add id=\"cpu_instruction_cb_t DOC\"> <ndx>cpu_instruction_cb_t</ndx>\n<name index=\"true\">cpu_instruction_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_instruction_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_instruction_cb_t\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instrumentation_subscribe</iface> or the\n<iface>cpu_cached_instruction</iface> interfaces to get a callback before or\nafter an instruction has been executed. The <param>cpu</param> is the\nprocessor which executed an instruction. The <param>handle</param> is an\nopaque handle associated with the instruction being executed. It can be used\nwith the <iface>cpu_instruction_query</iface> interface to get more\ninformation about the instruction. The <param>user_data</param> is the user\ndata for the callback.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"cpu_instruction_cb_t\"></add-type>"]
pub type cpu_instruction_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        handle: *mut instruction_handle_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add id=\"cpu_callback_free_user_data_cb_t DOC\">\n<ndx>cpu_callback_free_user_data_cb_t</ndx>\n<name index=\"true\">cpu_callback_free_user_data_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_callback_free_user_data_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_callback_free_user_data_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nCallback function registered through the\n<iface>cpu_cached_instruction</iface> interface to free instruction specific\nuser data when the instruction is not being cached anymore.  The\n<arg>user_data</arg> is the pointer to the callback data. <arg>obj</arg> is\nthe connection object and <arg>cpu</arg> is the processor that the callback\nwas registered for.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"cpu_callback_free_user_data_cb_t\"></add-type>"]
pub type cpu_callback_free_user_data_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add id=\"cpu_memory_cb_t DOC\">\n<ndx>cpu_memory_cb_t</ndx>\n<name index=\"true\">cpu_memory_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_memory_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_memory_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instrumentation_subscribe</iface> or the\n<iface>cpu_cached_instruction</iface> interfaces to get a callback before or\nafter an memory access is executed. The <param>cpu</param> is the\nprocessor which executed a load/store. The <param>handle</param> is an\nopaque handle associated with the instruction being executed. It can be used\nwith the <iface>cpu_memory_query</iface> interface to get more\ninformation about the access. The <param>user_data</param> is the user\ndata for the callback.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"cpu_memory_cb_t\"></add-type>"]
pub type cpu_memory_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        handle: *mut memory_handle_t,
        user_data: *mut lang_void,
    ),
>;
pub type cpu_cached_instruction_interface_t = cpu_cached_instruction_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_cached_instruction_interface {
    pub register_instruction_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_instruction_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub register_instruction_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_instruction_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub register_read_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_memory_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub register_read_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_memory_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub register_write_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_memory_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub register_write_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_memory_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub add_counter: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            counter: *mut uint64,
            use_atomic_increment: bool,
        ),
    >,
}
#[test]
fn bindgen_test_layout_cpu_cached_instruction_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_cached_instruction_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_cached_instruction_interface>(),
        56usize,
        concat!("Size of: ", stringify!(cpu_cached_instruction_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_cached_instruction_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cpu_cached_instruction_interface)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_before_cb) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(register_instruction_before_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_after_cb) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(register_instruction_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_read_before_cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(register_read_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_read_after_cb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(register_read_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_write_before_cb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(register_write_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_write_after_cb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(register_write_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_counter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_interface),
            "::",
            stringify!(add_counter)
        )
    );
}
pub type cpu_cached_instruction_once_interface_t = cpu_cached_instruction_once_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_cached_instruction_once_interface {
    pub register_instruction_before_once_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_instruction_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
    pub register_instruction_after_once_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            cb: cpu_instruction_cb_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_cpu_cached_instruction_once_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_cached_instruction_once_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_cached_instruction_once_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cpu_cached_instruction_once_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_cached_instruction_once_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cpu_cached_instruction_once_interface)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_before_once_cb) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_once_interface),
            "::",
            stringify!(register_instruction_before_once_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_after_once_cb) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_instruction_once_interface),
            "::",
            stringify!(register_instruction_after_once_cb)
        )
    );
}
pub type internal_cached_instruction_interface_t = internal_cached_instruction_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct internal_cached_instruction_interface {
    pub add_counters: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            i_counter: *mut uint64,
            t_counter: *mut uint64,
            use_atomic_increment: bool,
        ),
    >,
    pub get_service_routine_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            iq_handle: *mut instruction_handle_t,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_internal_cached_instruction_interface() {
    const UNINIT: ::std::mem::MaybeUninit<internal_cached_instruction_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<internal_cached_instruction_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(internal_cached_instruction_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<internal_cached_instruction_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(internal_cached_instruction_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_counters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(internal_cached_instruction_interface),
            "::",
            stringify!(add_counters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_service_routine_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(internal_cached_instruction_interface),
            "::",
            stringify!(get_service_routine_name)
        )
    );
}
#[doc = " <add id=\"cpu_cached_instruction_cb_t DOC\">\n<ndx>cpu_cached_instruction_cb_t</ndx>\n<name index=\"true\">cpu_cached_instruction_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_cached_instruction_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_cached_instruction_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instrumentation_subscribe</iface> interface's\n<fun>register_cached_instruction_cb</fun> member function.\n\nThis callback will be called when an instruction is about to be cached in\nthe processor model (this is not the same as being in the processor's real\nhardware instruction cache). The <param>cpu</param> is the processor which\nexecuted an instruction. The <param>ci_handle</param> is an opaque handle\nassociated with the instruction being executed, it is used in\nthe <iface>cpu_cached_instruction</iface> interface to install instruction\nspecific callbacks. The <param>iq_handle</param> is used with the\n<iface>cpu_instruction_query</iface> interface to get more information about\nthe instruction. The <param>user_data</param> is the user\ndata for the callback.\n</doc-item>\n</doc>\n</add>\n<add-type id=\"cpu_cached_instruction_cb_t\"></add-type>"]
pub type cpu_cached_instruction_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        ci_handle: *mut cached_instruction_handle_t,
        iq_handle: *mut instruction_handle_t,
        user_data: *mut lang_void,
    ),
>;
pub const cpu_emulation_t_CPU_Emulation_Fall_Through: cpu_emulation_t = 0;
pub const cpu_emulation_t_CPU_Emulation_Control_Flow: cpu_emulation_t = 1;
pub const cpu_emulation_t_CPU_Emulation_Default_Semantics: cpu_emulation_t = 2;
pub const cpu_emulation_t_CPU_Emulation_Stall: cpu_emulation_t = 3;
#[doc = " <add-type id=\"cpu_emulation_t\"></add-type>"]
pub type cpu_emulation_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"cpu_emulation_cb_t DOC\">\n<ndx>cpu_emulation_cb_t</ndx>\n<name index=\"true\">cpu_emulation_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_emulation_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_emulation_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instruction_decoder</iface> interface.\n\nThis callback will be called when an user added instruction is about to\nbe executed in the processor. The <param>cpu</param> is the processor which\nexecutes an instruction. The <param>instruction_user_data</param> is\nthe user-data associated with the instruction.\nThe return type <type>cpu_emulation_t</type> is used to tell Simics how the\nnext instruction should be fetched. For more information, see the\n<iface>cpu_instruction_decoder</iface> interface.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"cpu_emulation_cb_t\"></add-type>"]
pub type cpu_emulation_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        user_data: *mut lang_void,
    ) -> cpu_emulation_t,
>;
pub type cpu_instruction_decoder_interface_t = cpu_instruction_decoder_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_instruction_decoder_interface {
    pub register_emulation_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            cb: cpu_emulation_cb_t,
            handle: *mut decoder_handle_t,
            user_data: *mut lang_void,
            free_cb: cpu_callback_free_user_data_cb_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_cpu_instruction_decoder_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_instruction_decoder_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_instruction_decoder_interface>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_instruction_decoder_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_instruction_decoder_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cpu_instruction_decoder_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_emulation_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instruction_decoder_interface),
            "::",
            stringify!(register_emulation_cb)
        )
    );
}
#[doc = " <add id=\"cpu_instruction_decoder_cb_t DOC\">\n<ndx>cpu_instruction_decoder_cb_t</ndx>\n<name index=\"true\">cpu_instruction_decoder_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_instruction_decoder_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_instruction_decoder_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instrumentation_subscribe</iface> interface's\n<fun>register_instruction_decoder_cb()</fun> member function.\n\nThis callback will be called when an instruction is about to be cached in\nthe processor model (this is not the same as being in the processor's real\nhardware instruction cache). The <param>cpu</param> is the processor which\nexecuted an instruction. The <param>decoder_handle</param> is an opaque\nhandle associated with the instruction being executed and used in the\n<iface>cpu_instruction_decoder</iface> interface.\nThe <param>iq_handle</param> is used with the\n<iface>cpu_instruction_query</iface> interface to get more information on\nthe instruction. The <param>user_data</param> is the user data\nassociated with the callback.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"cpu_instruction_decoder_cb_t\"></add-type>"]
pub type cpu_instruction_decoder_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        decoder_handle: *mut decoder_handle_t,
        iq_handle: *mut instruction_handle_t,
        user_data: *mut lang_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <add id=\"cpu_instruction_disassemble_cb_t DOC\">\n<ndx>cpu_instruction_disassemble_cb_t</ndx>\n<name index=\"true\">cpu_instruction_disassemble_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_instruction_disassemble_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_instruction_disassemble_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instrumentation_subscribe</iface> interface's\n<fun>register_instruction_decoder_cb()</fun> member function.\n\nThe callback will be called when a replaced instruction is being\ndisassembled.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"cpu_instruction_disassemble_cb_t\"></add-type>"]
pub type cpu_instruction_disassemble_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        addr: generic_address_t,
        bytes: cpu_bytes_t,
    ) -> tuple_int_string_t,
>;
#[doc = " <add id=\"cpu_address_cb_t DOC\">\n<ndx>cpu_address_cb_t</ndx>\n<name index=\"true\">cpu_address_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">cpu_address_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"cpu_address_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<iface>cpu_instrumentation_subscribe</iface> interface's\n<fun>register_address_before()</fun> member function.\n\nThe callback will be called prior to a processor memory access, allowing\nthe callback to change the logical address for an access.\n\nThe argument <arg>obj</arg> is the object installing the callback and the\n<arg>cpu</arg> is the processor generating the logical\n<arg>address</arg>. If the access crosses a page boundary the access will be\nsplit into two calls. The <arg>part</arg> argument tells if the address\nbelongs to the first or the second part. The <type>cpu_address_part_t</type>\ntype has two values: <tt>CPU_Address_Part_First</tt> and\n<tt>CPU_Address_Part_Second</tt>. The <arg>handle</arg> can be used to\nextract more information about he address by using a architecture specific\ninterface. See the <iface>x86_address_query</iface> for example.\n\n</doc-item>\n</doc>\n</add>\n<add-type id=\"cpu_address_cb_t\"></add-type>"]
pub type cpu_address_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        address: logical_address_t,
        handle: *mut address_handle_t,
        user_data: *mut lang_void,
    ) -> logical_address_t,
>;
#[doc = " <add-type id=\"cpu_exception_cb_t\"></add-type>"]
pub type cpu_exception_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        exception_handle: *mut exception_handle_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add-type id=\"cpu_exception_return_cb_t\"></add-type>"]
pub type cpu_exception_return_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        exception_handle: *mut exception_return_handle_t,
        user_data: *mut lang_void,
    ),
>;
pub const cpu_exception_scope_t_CPU_Exception_All: cpu_exception_scope_t = -1;
#[doc = " <add-type id=\"cpu_exception_scope_t\"></add-type>"]
pub type cpu_exception_scope_t = ::std::os::raw::c_int;
pub const cpu_control_register_scope_t_CPU_Control_Register_All: cpu_control_register_scope_t = -1;
#[doc = " <add-type id=\"cpu_control_register_scope_t\"></add-type>"]
pub type cpu_control_register_scope_t = ::std::os::raw::c_int;
#[doc = " <add-type id=\"cpu_mode_change_cb_t\"></add-type>"]
pub type cpu_mode_change_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        old_mode: processor_mode_t,
        new_mode: processor_mode_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add-type id=\"cpu_control_register_read_cb_t\"></add-type>"]
pub type cpu_control_register_read_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        register_number: ::std::os::raw::c_int,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add-type id=\"cpu_control_register_write_cb_t\"></add-type>"]
pub type cpu_control_register_write_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        register_number: ::std::os::raw::c_int,
        value: uint64,
        user_data: *mut lang_void,
    ),
>;
pub const cpu_access_scope_t_CPU_Access_Scope_Explicit: cpu_access_scope_t = 0;
pub const cpu_access_scope_t_CPU_Access_Scope_Implicit: cpu_access_scope_t = 1;
#[doc = " <add-type id=\"cpu_access_scope_t\">\nUsed to select the access scope for instrumentation of memory\naccesses. CPU_Access_Scope_Explicit selects explicit accesses used by an\ninstruction such as loading or storing a value. CPU_Access_Scope_Implicit\nselects implicit accesses such as table walks and exceptions handling. See\nthe <iface>cpu_instrumentation_subscribe</iface> for more information.\n</add-type>"]
pub type cpu_access_scope_t = ::std::os::raw::c_uint;
pub type cpu_instrumentation_subscribe_interface_t = cpu_instrumentation_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_instrumentation_subscribe_interface {
    #[doc = " Callback specific methods"]
    pub remove_callback: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut cpu_cb_handle_t),
    >,
    pub enable_callback: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut cpu_cb_handle_t),
    >,
    pub disable_callback: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut cpu_cb_handle_t),
    >,
    #[doc = " Callback groups methods, operating on several callbacks\nassociated to a connection."]
    pub remove_connection_callbacks: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, connection: *mut conf_object_t),
    >,
    pub enable_connection_callbacks: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, connection: *mut conf_object_t),
    >,
    pub disable_connection_callbacks: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, connection: *mut conf_object_t),
    >,
    #[doc = " Subscribe methods"]
    pub register_instruction_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_instruction_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_instruction_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_instruction_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_read_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            scope: cpu_access_scope_t,
            cb: cpu_memory_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_read_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            scope: cpu_access_scope_t,
            cb: cpu_memory_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_write_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            scope: cpu_access_scope_t,
            cb: cpu_memory_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_write_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            scope: cpu_access_scope_t,
            cb: cpu_memory_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_address_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_address_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_cached_instruction_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_cached_instruction_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_instruction_decoder_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_instruction_decoder_cb_t,
            disass_cb: cpu_instruction_disassemble_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_exception_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            exception_number: ::std::os::raw::c_int,
            cb: cpu_exception_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_exception_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            exception_number: ::std::os::raw::c_int,
            cb: cpu_exception_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_exception_return_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_exception_return_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_exception_return_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_exception_return_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_mode_change_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_mode_change_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_control_register_read_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            register_number: ::std::os::raw::c_int,
            cb: cpu_control_register_read_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_control_register_write_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            register_number: ::std::os::raw::c_int,
            cb: cpu_control_register_write_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_cpu_instrumentation_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_instrumentation_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_instrumentation_subscribe_interface>(),
        176usize,
        concat!(
            "Size of: ",
            stringify!(cpu_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_instrumentation_subscribe_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cpu_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(remove_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(enable_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(disable_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_connection_callbacks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(remove_connection_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_connection_callbacks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(enable_connection_callbacks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disable_connection_callbacks) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(disable_connection_callbacks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_before_cb) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_instruction_before_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_after_cb) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_instruction_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_read_before_cb) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_read_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_read_after_cb) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_read_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_write_before_cb) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_write_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_write_after_cb) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_write_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_address_before_cb) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_address_before_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_cached_instruction_cb) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_cached_instruction_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_instruction_decoder_cb) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_instruction_decoder_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_exception_before_cb) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_exception_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_exception_after_cb) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_exception_after_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_exception_return_before_cb) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_exception_return_before_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_exception_return_after_cb) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_exception_return_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_mode_change_cb) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_mode_change_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_control_register_read_before_cb) as usize
                - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_control_register_read_before_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_control_register_write_before_cb) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_subscribe_interface),
            "::",
            stringify!(register_control_register_write_before_cb)
        )
    );
}
pub const cpu_stream_enum_t_CPU_Stream_Instruction_PA: cpu_stream_enum_t = 0;
pub const cpu_stream_enum_t_CPU_Stream_Instruction_VA: cpu_stream_enum_t = 1;
pub const cpu_stream_enum_t_CPU_Stream_Instruction_VA_After: cpu_stream_enum_t = 2;
pub const cpu_stream_enum_t_CPU_Stream_Read_PA: cpu_stream_enum_t = 3;
pub const cpu_stream_enum_t_CPU_Stream_Read_VA: cpu_stream_enum_t = 4;
pub const cpu_stream_enum_t_CPU_Stream_Write_PA: cpu_stream_enum_t = 5;
pub const cpu_stream_enum_t_CPU_Stream_Write_VA: cpu_stream_enum_t = 6;
pub const cpu_stream_enum_t_CPU_Stream_Read_Bytes: cpu_stream_enum_t = 7;
pub const cpu_stream_enum_t_CPU_Stream_Written_Bytes: cpu_stream_enum_t = 8;
pub const cpu_stream_enum_t_CPU_Stream_Address_VA: cpu_stream_enum_t = 9;
pub const cpu_stream_enum_t_CPU_Stream_Object: cpu_stream_enum_t = 10;
pub const cpu_stream_enum_t_CPU_Stream_Opcode: cpu_stream_enum_t = 17;
pub const cpu_stream_enum_t_CPU_Stream_Local: cpu_stream_enum_t = 32;
#[doc = " last, enum can used as bit number"]
pub const cpu_stream_enum_t_CPU_Stream_User_Data: cpu_stream_enum_t = 63;
#[doc = " ADD INTERFACE cpu_instrumentation_subscribe"]
pub type cpu_stream_enum_t = ::std::os::raw::c_uint;
#[doc = " Contains bits created by using bit numbers from cpu_stream_enum_t"]
pub type cpu_stream_bits_t = uint64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_stream_data_t {
    #[doc = " stored as CPU_STREAM_MAKE_TYPE(type, data)"]
    pub tag: uint64,
    #[doc = " tag-specific-data"]
    pub data: uint64,
}
#[test]
fn bindgen_test_layout_cpu_stream_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_stream_data_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_stream_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(cpu_stream_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_stream_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_stream_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_stream_data_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_stream_data_t),
            "::",
            stringify!(data)
        )
    );
}
pub type cpu_cached_stream_interface_t = cpu_cached_stream_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_cached_stream_interface {
    pub add_stream: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ci_handle: *mut cached_instruction_handle_t,
            bits: cpu_stream_bits_t,
            data: *mut *mut cpu_stream_data_t,
            user_data: uint64,
        ),
    >,
}
#[test]
fn bindgen_test_layout_cpu_cached_stream_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_cached_stream_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_cached_stream_interface>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_cached_stream_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_cached_stream_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_cached_stream_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_cached_stream_interface),
            "::",
            stringify!(add_stream)
        )
    );
}
pub type cpu_instrumentation_stream_interface_t = cpu_instrumentation_stream_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_instrumentation_stream_interface {
    pub add_stream: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            bits: cpu_stream_bits_t,
            data: *mut *mut cpu_stream_data_t,
            scope: cpu_access_scope_t,
        ) -> *mut cpu_stream_handle_t,
    >,
    pub remove_stream: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut cpu_stream_handle_t),
    >,
}
#[test]
fn bindgen_test_layout_cpu_instrumentation_stream_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_instrumentation_stream_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_instrumentation_stream_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cpu_instrumentation_stream_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_instrumentation_stream_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cpu_instrumentation_stream_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_stream_interface),
            "::",
            stringify!(add_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_stream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_instrumentation_stream_interface),
            "::",
            stringify!(remove_stream)
        )
    );
}
#[doc = " <add id=\"pre_decoder_cb_t DOC\">\n<ndx>pre_decoder_cb_t</ndx>\n<name index=\"true\">pre_decoder_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">pre_decoder_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"pre_decoder_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThis callback is used by the <iface>pre_decoder_interface_t</iface> to\nobserve and modify the instruction byte stream.\n\nThe <arg>obj</arg> is the connection object which owns the callback, or\nNULL, if no connection is used. <arg>cpu</arg> is the cpu which decodes the\ninstructions. <arg>instruction_start_address</arg> is the address of the\nfirst byte in the instruction that is being decoded. For x86 this is the\nlinerar address. <arg>opcode_bytes</arg> is a pointer to the first opcode\nbyte in the instruction. The <arg>valid_bytes</arg> tells how many bytes\nthat can read from the first byte.\n\nIf the decoded instruction crosses a page boundary this callback is invoked\ntwice, first with the bytes on the first page and then with additional bytes\nlocated on the next page. The <arg>instruction_position</arg> tells where in\nthe instruction opcode the next bytes are added from the second page, and\nhence will be greater 0 if this occurs.\n\nThe <arg>position_physical_address</arg> reflects the physical address of\nthe <arg>instruction_position</arg>.\n\nThe function should return true if the memory was modified, otherwise false.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"pre_decoder_cb_t\"></add-type>"]
pub type pre_decoder_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        instruction_start_address: generic_address_t,
        position_physical_address: physical_address_t,
        opcode_bytes: *mut uint8,
        valid_bytes: ::std::os::raw::c_uint,
        instruction_position: ::std::os::raw::c_uint,
        user_data: *mut lang_void,
    ) -> bool,
>;
pub type pre_decoder_interface_t = pre_decoder_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pre_decoder_interface {
    pub register_pre_decoder_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: pre_decoder_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_pre_decoder_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pre_decoder_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pre_decoder_interface>(),
        8usize,
        concat!("Size of: ", stringify!(pre_decoder_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pre_decoder_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pre_decoder_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_pre_decoder_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pre_decoder_interface),
            "::",
            stringify!(register_pre_decoder_cb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct step_instrumentation {
    _unused: [u8; 0],
}
pub type step_handle_t = step_instrumentation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_instrumentation {
    _unused: [u8; 0],
}
pub type cycle_handle_t = clock_instrumentation;
pub type step_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        step_obj: *mut conf_object_t,
        event_obj: *mut conf_object_t,
        steps: pc_step_t,
        event_class_name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        value: attr_value_t,
        user_data: *mut lang_void,
    ),
>;
pub type step_event_instrumentation_interface_t = step_event_instrumentation_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct step_event_instrumentation_interface {
    pub register_step_event_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: step_event_cb_t,
            data: *mut lang_void,
        ) -> *mut step_handle_t,
    >,
    pub remove_step_event_cb: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut step_handle_t),
    >,
}
#[test]
fn bindgen_test_layout_step_event_instrumentation_interface() {
    const UNINIT: ::std::mem::MaybeUninit<step_event_instrumentation_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<step_event_instrumentation_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(step_event_instrumentation_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<step_event_instrumentation_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(step_event_instrumentation_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_step_event_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(step_event_instrumentation_interface),
            "::",
            stringify!(register_step_event_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_step_event_cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(step_event_instrumentation_interface),
            "::",
            stringify!(remove_step_event_cb)
        )
    );
}
#[doc = " ADD INTERFACE step_event_instrumentation"]
pub type cycle_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        step_obj: *mut conf_object_t,
        event_obj: *mut conf_object_t,
        cycles: cycles_t,
        event_class_name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        value: attr_value_t,
        user_data: *mut lang_void,
    ),
>;
pub type cycle_event_instrumentation_interface_t = cycle_event_instrumentation_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cycle_event_instrumentation_interface {
    pub register_cycle_event_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cycle_event_cb_t,
            data: *mut lang_void,
        ) -> *mut cycle_handle_t,
    >,
    pub remove_cycle_event_cb: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut cycle_handle_t),
    >,
}
#[test]
fn bindgen_test_layout_cycle_event_instrumentation_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cycle_event_instrumentation_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cycle_event_instrumentation_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cycle_event_instrumentation_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cycle_event_instrumentation_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cycle_event_instrumentation_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_cycle_event_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_instrumentation_interface),
            "::",
            stringify!(register_cycle_event_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_cycle_event_cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_instrumentation_interface),
            "::",
            stringify!(remove_cycle_event_cb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_spage {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"image_spage_t def\"></add-type>"]
pub type image_spage_t = image_spage;
pub type image_interface_t = image_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct image_interface {
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut conf_object_t,
            to_buf: *mut ::std::os::raw::c_void,
            start: uint64,
            length: usize,
        ),
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut conf_object_t,
            from_buf: *const ::std::os::raw::c_void,
            start: uint64,
            length: usize,
        ),
    >,
    pub for_all_spages: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut conf_object_t,
            f: ::std::option::Option<
                unsafe extern "C" fn(
                    p: *mut image_spage_t,
                    ofs: uint64,
                    arg: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_persistent: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub save_to_file: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            file: *const ::std::os::raw::c_char,
            start: uint64,
            length: uint64,
        ),
    >,
    pub save_diff: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, file: *const ::std::os::raw::c_char),
    >,
    pub clear_range: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, start: uint64, length: uint64),
    >,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, start: uint64, length: uint64, value: uint8),
    >,
    pub size: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint64>,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, ofs: uint64, b: bytes_t),
    >,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, ofs: uint64, size: usize) -> bytes_t,
    >,
    pub flush_writable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_image_interface() {
    const UNINIT: ::std::mem::MaybeUninit<image_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_interface>(),
        96usize,
        concat!("Size of: ", stringify!(image_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<image_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(image_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).for_all_spages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(for_all_spages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_persistent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(set_persistent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_to_file) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(save_to_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_diff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(save_diff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_range) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(clear_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_writable) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(image_interface),
            "::",
            stringify!(flush_writable)
        )
    );
}
pub type linear_image_interface_t = linear_image_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct linear_image_interface {
    pub get_base: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, retsize: *mut usize) -> *mut uint8,
    >,
    pub set_base:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, base: *mut uint8)>,
    pub prepare_range: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            type_: read_or_write_t,
            offs: usize,
            size: usize,
        ),
    >,
}
#[test]
fn bindgen_test_layout_linear_image_interface() {
    const UNINIT: ::std::mem::MaybeUninit<linear_image_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linear_image_interface>(),
        24usize,
        concat!("Size of: ", stringify!(linear_image_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<linear_image_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(linear_image_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linear_image_interface),
            "::",
            stringify!(get_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(linear_image_interface),
            "::",
            stringify!(set_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepare_range) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(linear_image_interface),
            "::",
            stringify!(prepare_range)
        )
    );
}
pub type image_snoop_interface_t = image_snoop_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct image_snoop_interface {
    pub page_modified: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            img: *mut conf_object_t,
            offset: uint64,
            page_data: *mut uint8,
            spage: *mut image_spage_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_image_snoop_interface() {
    const UNINIT: ::std::mem::MaybeUninit<image_snoop_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_snoop_interface>(),
        8usize,
        concat!("Size of: ", stringify!(image_snoop_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<image_snoop_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(image_snoop_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_modified) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_snoop_interface),
            "::",
            stringify!(page_modified)
        )
    );
}
pub type pool_protect_interface_t = pool_protect_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pool_protect_interface {
    pub create_group: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            image_obj: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub protect: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_pool_protect_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pool_protect_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pool_protect_interface>(),
        16usize,
        concat!("Size of: ", stringify!(pool_protect_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_protect_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_protect_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_protect_interface),
            "::",
            stringify!(create_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_protect_interface),
            "::",
            stringify!(protect)
        )
    );
}
pub const sim_key_t_SK_ILLEGAL: sim_key_t = 0;
pub const sim_key_t_SK_ESC: sim_key_t = 1;
pub const sim_key_t_SK_F1: sim_key_t = 2;
pub const sim_key_t_SK_F2: sim_key_t = 3;
pub const sim_key_t_SK_F3: sim_key_t = 4;
pub const sim_key_t_SK_F4: sim_key_t = 5;
pub const sim_key_t_SK_F5: sim_key_t = 6;
pub const sim_key_t_SK_F6: sim_key_t = 7;
pub const sim_key_t_SK_F7: sim_key_t = 8;
pub const sim_key_t_SK_F8: sim_key_t = 9;
pub const sim_key_t_SK_F9: sim_key_t = 10;
pub const sim_key_t_SK_F10: sim_key_t = 11;
pub const sim_key_t_SK_F11: sim_key_t = 12;
pub const sim_key_t_SK_F12: sim_key_t = 13;
pub const sim_key_t_SK_PRNT_SCRN: sim_key_t = 14;
pub const sim_key_t_SK_SCROLL_LOCK: sim_key_t = 15;
pub const sim_key_t_SK_NUM_LOCK: sim_key_t = 16;
pub const sim_key_t_SK_CAPS_LOCK: sim_key_t = 17;
pub const sim_key_t_SK_0: sim_key_t = 18;
pub const sim_key_t_SK_1: sim_key_t = 19;
pub const sim_key_t_SK_2: sim_key_t = 20;
pub const sim_key_t_SK_3: sim_key_t = 21;
pub const sim_key_t_SK_4: sim_key_t = 22;
pub const sim_key_t_SK_5: sim_key_t = 23;
pub const sim_key_t_SK_6: sim_key_t = 24;
pub const sim_key_t_SK_7: sim_key_t = 25;
pub const sim_key_t_SK_8: sim_key_t = 26;
pub const sim_key_t_SK_9: sim_key_t = 27;
pub const sim_key_t_SK_A: sim_key_t = 28;
pub const sim_key_t_SK_B: sim_key_t = 29;
pub const sim_key_t_SK_C: sim_key_t = 30;
pub const sim_key_t_SK_D: sim_key_t = 31;
pub const sim_key_t_SK_E: sim_key_t = 32;
pub const sim_key_t_SK_F: sim_key_t = 33;
pub const sim_key_t_SK_G: sim_key_t = 34;
pub const sim_key_t_SK_H: sim_key_t = 35;
pub const sim_key_t_SK_I: sim_key_t = 36;
pub const sim_key_t_SK_J: sim_key_t = 37;
pub const sim_key_t_SK_K: sim_key_t = 38;
pub const sim_key_t_SK_L: sim_key_t = 39;
pub const sim_key_t_SK_M: sim_key_t = 40;
pub const sim_key_t_SK_N: sim_key_t = 41;
pub const sim_key_t_SK_O: sim_key_t = 42;
pub const sim_key_t_SK_P: sim_key_t = 43;
pub const sim_key_t_SK_Q: sim_key_t = 44;
pub const sim_key_t_SK_R: sim_key_t = 45;
pub const sim_key_t_SK_S: sim_key_t = 46;
pub const sim_key_t_SK_T: sim_key_t = 47;
pub const sim_key_t_SK_U: sim_key_t = 48;
pub const sim_key_t_SK_V: sim_key_t = 49;
pub const sim_key_t_SK_W: sim_key_t = 50;
pub const sim_key_t_SK_X: sim_key_t = 51;
pub const sim_key_t_SK_Y: sim_key_t = 52;
pub const sim_key_t_SK_Z: sim_key_t = 53;
pub const sim_key_t_SK_APOSTROPHE: sim_key_t = 54;
pub const sim_key_t_SK_COMMA: sim_key_t = 55;
pub const sim_key_t_SK_PERIOD: sim_key_t = 56;
pub const sim_key_t_SK_SEMICOLON: sim_key_t = 57;
pub const sim_key_t_SK_EQUAL: sim_key_t = 58;
pub const sim_key_t_SK_SLASH: sim_key_t = 59;
pub const sim_key_t_SK_BACKSLASH: sim_key_t = 60;
pub const sim_key_t_SK_SPACE: sim_key_t = 61;
pub const sim_key_t_SK_LEFT_BRACKET: sim_key_t = 62;
pub const sim_key_t_SK_RIGHT_BRACKET: sim_key_t = 63;
pub const sim_key_t_SK_MINUS: sim_key_t = 64;
pub const sim_key_t_SK_GRAVE: sim_key_t = 65;
pub const sim_key_t_SK_TAB: sim_key_t = 66;
pub const sim_key_t_SK_ENTER: sim_key_t = 67;
pub const sim_key_t_SK_BACKSPACE: sim_key_t = 68;
pub const sim_key_t_SK_CTRL_L: sim_key_t = 69;
pub const sim_key_t_SK_CTRL_R: sim_key_t = 70;
pub const sim_key_t_SK_SHIFT_L: sim_key_t = 71;
pub const sim_key_t_SK_SHIFT_R: sim_key_t = 72;
pub const sim_key_t_SK_ALT_L: sim_key_t = 73;
pub const sim_key_t_SK_ALT_R: sim_key_t = 74;
pub const sim_key_t_SK_GR_DIVIDE: sim_key_t = 75;
pub const sim_key_t_SK_GR_MULTIPLY: sim_key_t = 76;
pub const sim_key_t_SK_GR_MINUS: sim_key_t = 77;
pub const sim_key_t_SK_GR_PLUS: sim_key_t = 78;
pub const sim_key_t_SK_GR_ENTER: sim_key_t = 79;
pub const sim_key_t_SK_GR_INSERT: sim_key_t = 80;
pub const sim_key_t_SK_GR_HOME: sim_key_t = 81;
pub const sim_key_t_SK_GR_PG_UP: sim_key_t = 82;
pub const sim_key_t_SK_GR_DELETE: sim_key_t = 83;
pub const sim_key_t_SK_GR_END: sim_key_t = 84;
pub const sim_key_t_SK_GR_PG_DOWN: sim_key_t = 85;
pub const sim_key_t_SK_GR_UP: sim_key_t = 86;
pub const sim_key_t_SK_GR_DOWN: sim_key_t = 87;
pub const sim_key_t_SK_GR_LEFT: sim_key_t = 88;
pub const sim_key_t_SK_GR_RIGHT: sim_key_t = 89;
pub const sim_key_t_SK_KP_HOME: sim_key_t = 90;
pub const sim_key_t_SK_KP_UP: sim_key_t = 91;
pub const sim_key_t_SK_KP_PG_UP: sim_key_t = 92;
pub const sim_key_t_SK_KP_LEFT: sim_key_t = 93;
pub const sim_key_t_SK_KP_CENTER: sim_key_t = 94;
pub const sim_key_t_SK_KP_RIGHT: sim_key_t = 95;
pub const sim_key_t_SK_KP_END: sim_key_t = 96;
pub const sim_key_t_SK_KP_DOWN: sim_key_t = 97;
pub const sim_key_t_SK_KP_PG_DOWN: sim_key_t = 98;
pub const sim_key_t_SK_KP_INSERT: sim_key_t = 99;
pub const sim_key_t_SK_KP_DELETE: sim_key_t = 100;
pub const sim_key_t_SK_PAUSE: sim_key_t = 101;
pub const sim_key_t_SK_LEFT_WIN: sim_key_t = 102;
pub const sim_key_t_SK_RIGHT_WIN: sim_key_t = 103;
pub const sim_key_t_SK_LIST_BIT: sim_key_t = 104;
pub const sim_key_t_SK_KEYB: sim_key_t = 105;
pub const sim_key_t_SK_BREAK: sim_key_t = 106;
pub const sim_key_t_SK_SYSREQ: sim_key_t = 107;
pub const sim_key_t_SK_SUN_STOP: sim_key_t = 108;
pub const sim_key_t_SK_SUN_AGAIN: sim_key_t = 109;
pub const sim_key_t_SK_SUN_PROPS: sim_key_t = 110;
pub const sim_key_t_SK_SUN_UNDO: sim_key_t = 111;
pub const sim_key_t_SK_SUN_FRONT: sim_key_t = 112;
pub const sim_key_t_SK_SUN_COPY: sim_key_t = 113;
pub const sim_key_t_SK_SUN_OPEN: sim_key_t = 114;
pub const sim_key_t_SK_SUN_PASTE: sim_key_t = 115;
pub const sim_key_t_SK_SUN_FIND: sim_key_t = 116;
pub const sim_key_t_SK_SUN_CUT: sim_key_t = 117;
pub const sim_key_t_SK_SUN_HELP: sim_key_t = 118;
pub const sim_key_t_SK_SUN_COMPOSE: sim_key_t = 119;
pub const sim_key_t_SK_SUN_META_L: sim_key_t = 120;
pub const sim_key_t_SK_SUN_META_R: sim_key_t = 121;
pub const sim_key_t_SK_SUN_POWER: sim_key_t = 122;
pub const sim_key_t_SK_SUN_AUDIO_D: sim_key_t = 123;
pub const sim_key_t_SK_SUN_AUDIO_U: sim_key_t = 124;
pub const sim_key_t_SK_SUN_AUDIO_M: sim_key_t = 125;
pub const sim_key_t_SK_SUN_EMPTY: sim_key_t = 126;
pub type sim_key_t = ::std::os::raw::c_uint;
pub type component_interface_t = component_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct component_interface {
    pub pre_instantiate:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub post_instantiate: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub create_cell: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub get_slots:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_slot_objects:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_slot_value: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            slot: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub set_slot_value: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            slot: *const ::std::os::raw::c_char,
            value: attr_value_t,
        ),
    >,
    pub has_slot: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, slot: *const ::std::os::raw::c_char) -> bool,
    >,
    pub add_slot: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, slot: *const ::std::os::raw::c_char) -> bool,
    >,
    pub del_slot: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, slot: *const ::std::os::raw::c_char) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_component_interface() {
    const UNINIT: ::std::mem::MaybeUninit<component_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<component_interface>(),
        80usize,
        concat!("Size of: ", stringify!(component_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<component_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(component_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_instantiate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(pre_instantiate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_instantiate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(post_instantiate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_cell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(create_cell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_slots) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(get_slots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_slot_objects) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(get_slot_objects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_slot_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(get_slot_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_slot_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(set_slot_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_slot) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(has_slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_slot) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(add_slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_slot) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(component_interface),
            "::",
            stringify!(del_slot)
        )
    );
}
pub const connector_direction_t_Sim_Connector_Direction_Up: connector_direction_t = 0;
pub const connector_direction_t_Sim_Connector_Direction_Down: connector_direction_t = 1;
pub const connector_direction_t_Sim_Connector_Direction_Any: connector_direction_t = 2;
#[doc = "<add id=\"connector_interface_t\">\n<name index=\"true\">connector_interface_t</name>\n\nThe <iface>connector</iface> interface must be implemented by\nconnector objects. The interface describes the connector and how it\ncan be connected to other connectors. A connector is used for\nconnecting component objects. The connector is just a proxy for the\nconnection, the connector uses the <iface>component_connector</iface>\ninterface in the components to setup the connection.\n\nThe <fun>type</fun> function returns the connector type as a\nstring. Two connectors can only be connected if the type is\nidentical.\n\nA hotpluggable connector returns <tt>true</tt> when calling the\n<fun>hotpluggable</fun> function, otherwise <tt>false</tt>. A\nhotpluggable connector can be connected before or after the\ncomponent is instantiated, an non hotpluggable connector must be\nconnected before the component is instantiated.\n\nThe <fun>required</fun> function returns <tt>true</tt> if the\nconnector must be connected before instantiated, otherwise\n<tt>false</tt>.\n\nA connector can be connected to many connectors, but it is only\nsupported if the <fun>multi</fun> function return <tt>true</tt>. It\nis not recommended that a connector support multi connections. A\ncomponent can instead dynamically create connectors when needed.\n\nA connector has a direction; <em>up</em>, <em>down</em> or\n<em>any</em>. The direction decides in which order the connectors\nin a component tree are connected and the structure of the tree.\n\nConnections are setup in two steps. The first step is to add the\nconnection, which is done using the <fun>add_destination</fun>\nfunction. Adding a connection can fail for several reasons and it\nis implementation dependent how the connection can fail. A\nconnection can for instance fail because the destination object\nrequires something that the source component did not pass when\nchecking the connection. Just adding a connection does not mean\nthat the components actually connect. The components have to save\nthe data given with the <fun>add_destination</fun> function. The\nactual setup of the connection is made in the second step when the\n<fun>update</fun> function is called, which finalizes the\nconnection.\n\nThe <fun>add_destination</fun> and <fun>remove_destination</fun>\nfunctions sets the state of the connection. It is first when the\n<fun>update</fun> function is called when the connection is\nfinalized. Both <fun>add_destination</fun> and\n<fun>remove_destination</fun> returns <tt>true</tt> if the call was\nsuccessful otherwise they return <tt>false</tt>.\n\nParameters to the <fun>add_destination</fun> function are the own\nobject <param>obj</param> and the destination object\n<param>dst_obj</param>. The destination object must be a port\nobject and it must implement the <iface>connector</iface>\ninterface.\n\nThe <fun>update</fun> function is called when the component should\nupdate its current connection status. The status of the connection\nhas previously been set using the <fun>add_destination</fun>\nor/and <fun>remove_destination</fun> functions.\n\nThe <fun>destination</fun> function returns a list of port objects\nthat the its connected to. The <fun>destination</fun> function\nreturns the state of the connection not the finalized state,\ni.e. the state of the connection before <fun>update</fun>\nfunctional call.\n\nThe <fun>check</fun>, <fun>connect</fun>, and <fun>disconnect</fun>\nfunctions initiates a connection setup via the connector object. The\nconnector will forward the setup to the components affected by the\nconnection via the <iface>component_connector</iface> interface.\n\nThe <fun>deletion_requested</fun> function is called after disconnecting\ncomponents. A dynamic connector might want to return True in order to be\ndeleted just after the disconnection.\n\n<insert-until text=\"// ADD INTERFACE connector_interface\"/>\n</add>\n\n<add id=\"connector_interface_exec_context\">\nGlobal Context for all methods.\n</add>"]
pub type connector_direction_t = ::std::os::raw::c_uint;
pub type connector_interface_t = connector_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct connector_interface {
    pub type_: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut ::std::os::raw::c_char,
    >,
    pub hotpluggable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub required: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub multi: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub direction: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> connector_direction_t,
    >,
    pub add_destination: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, connector: *mut conf_object_t) -> bool,
    >,
    pub remove_destination: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, connector: *mut conf_object_t) -> bool,
    >,
    #[doc = " list of\nconnector objects"]
    pub destination:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub update: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub check: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, attr: attr_value_t) -> bool,
    >,
    pub connect:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, attr: attr_value_t)>,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub deletion_requested:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
}
#[test]
fn bindgen_test_layout_connector_interface() {
    const UNINIT: ::std::mem::MaybeUninit<connector_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<connector_interface>(),
        104usize,
        concat!("Size of: ", stringify!(connector_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<connector_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(connector_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hotpluggable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(hotpluggable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(required)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multi) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(multi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_destination) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(add_destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_destination) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(remove_destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deletion_requested) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(connector_interface),
            "::",
            stringify!(deletion_requested)
        )
    );
}
pub type component_connector_interface_t = component_connector_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct component_connector_interface {
    pub get_check_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            connector: *mut conf_object_t,
        ) -> attr_value_t,
    >,
    pub get_connect_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            connector: *mut conf_object_t,
        ) -> attr_value_t,
    >,
    pub check: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            connector: *mut conf_object_t,
            attr: attr_value_t,
        ) -> bool,
    >,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            connector: *mut conf_object_t,
            attr: attr_value_t,
        ),
    >,
    pub disconnect: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, connector: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_component_connector_interface() {
    const UNINIT: ::std::mem::MaybeUninit<component_connector_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<component_connector_interface>(),
        40usize,
        concat!("Size of: ", stringify!(component_connector_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<component_connector_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(component_connector_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_check_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(component_connector_interface),
            "::",
            stringify!(get_check_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connect_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(component_connector_interface),
            "::",
            stringify!(get_connect_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(component_connector_interface),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(component_connector_interface),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(component_connector_interface),
            "::",
            stringify!(disconnect)
        )
    );
}
pub type disk_component_interface_t = disk_component_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct disk_component_interface {
    pub size: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint64>,
}
#[test]
fn bindgen_test_layout_disk_component_interface() {
    const UNINIT: ::std::mem::MaybeUninit<disk_component_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<disk_component_interface>(),
        8usize,
        concat!("Size of: ", stringify!(disk_component_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<disk_component_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(disk_component_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_component_interface),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " <add-type id=\"instruction_trace_callback_t def\"></add-type>"]
pub type instruction_trace_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        tracer_data: *mut lang_void,
        cpu: *mut conf_object_t,
        la: linear_address_t,
        va: logical_address_t,
        pa: physical_address_t,
        opcode: byte_string_t,
    ),
>;
pub type exec_trace_interface_t = exec_trace_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct exec_trace_interface {
    pub register_tracer: ::std::option::Option<
        unsafe extern "C" fn(
            cpu_obj: *mut conf_object_t,
            tracer: instruction_trace_callback_t,
            tracer_data: *mut lang_void,
        ),
    >,
    pub unregister_tracer: ::std::option::Option<
        unsafe extern "C" fn(
            cpu_obj: *mut conf_object_t,
            tracer: instruction_trace_callback_t,
            tracer_data: *mut lang_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_exec_trace_interface() {
    const UNINIT: ::std::mem::MaybeUninit<exec_trace_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exec_trace_interface>(),
        16usize,
        concat!("Size of: ", stringify!(exec_trace_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<exec_trace_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(exec_trace_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_tracer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exec_trace_interface),
            "::",
            stringify!(register_tracer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_tracer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exec_trace_interface),
            "::",
            stringify!(unregister_tracer)
        )
    );
}
#[doc = " Model uses the Standard Device Model"]
pub const concurrency_mode_t_Sim_Concurrency_Mode_Serialized: concurrency_mode_t = 1;
#[doc = " Model uses the Threaded Device Model.\nDirect memory pages are protected against concurrency."]
pub const concurrency_mode_t_Sim_Concurrency_Mode_Serialized_Memory: concurrency_mode_t = 2;
#[doc = " Model uses the Threaded Device Model.\nConcurrency can be observed on direct memory pages"]
pub const concurrency_mode_t_Sim_Concurrency_Mode_Full: concurrency_mode_t = 4;
#[doc = " <add-type id=\"concurrency_mode_t def\"></add-type>"]
pub type concurrency_mode_t = ::std::os::raw::c_uint;
pub type concurrency_mode_interface_t = concurrency_mode_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct concurrency_mode_interface {
    pub supported_modes:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> concurrency_mode_t>,
    pub current_mode:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> concurrency_mode_t>,
    pub switch_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, mode: concurrency_mode_t),
    >,
}
#[test]
fn bindgen_test_layout_concurrency_mode_interface() {
    const UNINIT: ::std::mem::MaybeUninit<concurrency_mode_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<concurrency_mode_interface>(),
        24usize,
        concat!("Size of: ", stringify!(concurrency_mode_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<concurrency_mode_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(concurrency_mode_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_modes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(concurrency_mode_interface),
            "::",
            stringify!(supported_modes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(concurrency_mode_interface),
            "::",
            stringify!(current_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switch_mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(concurrency_mode_interface),
            "::",
            stringify!(switch_mode)
        )
    );
}
pub type concurrency_group_interface_t = concurrency_group_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct concurrency_group_interface {
    pub serialized_memory_group: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            group_index: ::std::os::raw::c_uint,
        ) -> attr_value_t,
    >,
    pub execution_group: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            group_index: ::std::os::raw::c_uint,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_concurrency_group_interface() {
    const UNINIT: ::std::mem::MaybeUninit<concurrency_group_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<concurrency_group_interface>(),
        16usize,
        concat!("Size of: ", stringify!(concurrency_group_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<concurrency_group_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(concurrency_group_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialized_memory_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(concurrency_group_interface),
            "::",
            stringify!(serialized_memory_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execution_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(concurrency_group_interface),
            "::",
            stringify!(execution_group)
        )
    );
}
extern "C" {
    #[doc = " ADD INTERFACE concurrency_group_interface_t"]
    pub fn VT_update_thread_domain_assignments();
}
#[doc = " No instruction fetch sent to memory hierarchy"]
pub const instruction_fetch_mode_t_Instruction_Fetch_None: instruction_fetch_mode_t = 0;
#[doc = " Memory hierarchy gets fetch for each cache line access"]
pub const instruction_fetch_mode_t_Instruction_Fetch_Cache_Access_Trace: instruction_fetch_mode_t =
    1;
#[doc = " Memory hierarchy gets fetch for each instruction fetch. Only\nx86/x86-64"]
pub const instruction_fetch_mode_t_Instruction_Fetch_Trace: instruction_fetch_mode_t = 2;
#[doc = "<add id=\"instruction_fetch_interface_t\">\n\nThe <iface>instruction_fetch</iface> interface is implemented by\nprocessors. The interface controls how instruction fetches should\nbe modeled.\n\nThe <fun>get_mode</fun> and <fun>set_mode</fun> functions get and\nset the instruction fetch mode. There are three available\nmodes. All modes are not supported by all processor types. The\n<em>instruction_fetch_none</em> mode is the least accurate but the\nfastest mode. The other modes are more accurate but slower.\n\nThe <fun>get_line_size</fun> and <fun>set_line_size</fun> functions\nget and set the fetch size on each instruction fetch. This is often\nrelated to cache line size or similar. The line size must be power\nof 2.\n\n<insert-until text=\"// ADD INTERFACE instruction_fetch_interface_t\"/>\n\n</add>\n<add id=\"instruction_fetch_interface_exec_context\">\n<table border=\"false\">\n<tr><td><fun>get_mode</fun></td><td>Cell Context</td></tr>\n<tr><td><fun>set_mode</fun></td><td>Global Context</td></tr>\n<tr><td><fun>get_line_size</fun></td><td>Cell Context</td></tr>\n<tr><td><fun>set_line_size</fun></td><td>Global Context</td></tr>\n</table>\n</add>"]
pub type instruction_fetch_mode_t = ::std::os::raw::c_uint;
pub type instruction_fetch_interface_t = instruction_fetch_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instruction_fetch_interface {
    pub get_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> instruction_fetch_mode_t,
    >,
    pub set_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, mode: instruction_fetch_mode_t),
    >,
    pub get_line_size: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub set_line_size: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, size: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_instruction_fetch_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instruction_fetch_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instruction_fetch_interface>(),
        32usize,
        concat!("Size of: ", stringify!(instruction_fetch_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<instruction_fetch_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(instruction_fetch_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_fetch_interface),
            "::",
            stringify!(get_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_fetch_interface),
            "::",
            stringify!(set_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_line_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_fetch_interface),
            "::",
            stringify!(get_line_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_line_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_fetch_interface),
            "::",
            stringify!(set_line_size)
        )
    );
}
pub type step_interface_t = step_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct step_interface {
    pub get_step_count:
        ::std::option::Option<unsafe extern "C" fn(queue: *mut conf_object_t) -> pc_step_t>,
    pub post_step: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            steps: pc_step_t,
            user_data: *mut lang_void,
        ),
    >,
    pub cancel_step: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ),
    >,
    pub find_next_step: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut conf_object_t,
            evclass: *mut event_class_t,
            obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ) -> pc_step_t,
    >,
    pub events:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub advance: ::std::option::Option<
        unsafe extern "C" fn(queue: *mut conf_object_t, steps: pc_step_t) -> pc_step_t,
    >,
}
#[test]
fn bindgen_test_layout_step_interface() {
    const UNINIT: ::std::mem::MaybeUninit<step_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<step_interface>(),
        48usize,
        concat!("Size of: ", stringify!(step_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<step_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(step_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_step_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(step_interface),
            "::",
            stringify!(get_step_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_step) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(step_interface),
            "::",
            stringify!(post_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(step_interface),
            "::",
            stringify!(cancel_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_next_step) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(step_interface),
            "::",
            stringify!(find_next_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(step_interface),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advance) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(step_interface),
            "::",
            stringify!(advance)
        )
    );
}
#[doc = "<add id=\"step_cycle_ratio_interface_t\">\n\nThe <iface>step_cycle_ratio</iface> interface is implemented by\nprocessors that support a changeable ratio between steps and\ncycles. The <cmd>set-step-rate</cmd> command uses this interface to\nset the ratio between steps and cycles.\n\nThe <fun>set_ratio</fun> sets the ratio between <arg>steps</arg> and\n<arg>cycles</arg>. Note that the introduction of stall cycles can\nskew the ratio. The <fun>get_ratio</fun> simply returns the current\nratio.\n\nThe <arg>cycles</arg> and <arg>step</arg> arguments must be in the range\n[1..128] and <arg>cycles</arg> must be a power of two. Implementers of this\ninterface may choose to ignore other values of <arg>cycles</arg> and\n<arg>step</arg> and may log an error.\n\n<insert-until text=\"// ADD INTERFACE step_cycle_ratio_interface_t\"/>\n</add>\n<add id=\"step_cycle_ratio_interface_exec_context\">\nCell Context for all methods.\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct step_cycle_ratio_t {
    pub steps: uint32,
    pub cycles: uint32,
}
#[test]
fn bindgen_test_layout_step_cycle_ratio_t() {
    const UNINIT: ::std::mem::MaybeUninit<step_cycle_ratio_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<step_cycle_ratio_t>(),
        8usize,
        concat!("Size of: ", stringify!(step_cycle_ratio_t))
    );
    assert_eq!(
        ::std::mem::align_of::<step_cycle_ratio_t>(),
        4usize,
        concat!("Alignment of ", stringify!(step_cycle_ratio_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).steps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(step_cycle_ratio_t),
            "::",
            stringify!(steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycles) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(step_cycle_ratio_t),
            "::",
            stringify!(cycles)
        )
    );
}
pub type step_cycle_ratio_interface_t = step_cycle_ratio_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct step_cycle_ratio_interface {
    pub get_ratio:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> step_cycle_ratio_t>,
    pub set_ratio: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, steps: uint32, cycles: uint32),
    >,
}
#[test]
fn bindgen_test_layout_step_cycle_ratio_interface() {
    const UNINIT: ::std::mem::MaybeUninit<step_cycle_ratio_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<step_cycle_ratio_interface>(),
        16usize,
        concat!("Size of: ", stringify!(step_cycle_ratio_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<step_cycle_ratio_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(step_cycle_ratio_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_ratio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(step_cycle_ratio_interface),
            "::",
            stringify!(get_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_ratio) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(step_cycle_ratio_interface),
            "::",
            stringify!(set_ratio)
        )
    );
}
pub type stall_interface_t = stall_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct stall_interface {
    pub get_stall_cycles:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cycles_t>,
    pub set_stall_cycles:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, cycles: cycles_t)>,
    pub get_total_stall_cycles:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cycles_t>,
}
#[test]
fn bindgen_test_layout_stall_interface() {
    const UNINIT: ::std::mem::MaybeUninit<stall_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stall_interface>(),
        24usize,
        concat!("Size of: ", stringify!(stall_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<stall_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(stall_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_stall_cycles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stall_interface),
            "::",
            stringify!(get_stall_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_stall_cycles) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stall_interface),
            "::",
            stringify!(set_stall_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_total_stall_cycles) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stall_interface),
            "::",
            stringify!(get_total_stall_cycles)
        )
    );
}
pub type step_info_interface_t = step_info_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct step_info_interface {
    pub get_halt_steps:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> pc_step_t>,
    pub set_halt_steps:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, steps: pc_step_t)>,
    pub get_ffwd_steps:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> pc_step_t>,
    pub set_ffwd_steps:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, steps: pc_step_t)>,
    pub get_ma_steps:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> pc_step_t>,
    pub set_ma_steps:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, steps: pc_step_t)>,
}
#[test]
fn bindgen_test_layout_step_info_interface() {
    const UNINIT: ::std::mem::MaybeUninit<step_info_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<step_info_interface>(),
        48usize,
        concat!("Size of: ", stringify!(step_info_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<step_info_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(step_info_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_halt_steps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(step_info_interface),
            "::",
            stringify!(get_halt_steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_halt_steps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(step_info_interface),
            "::",
            stringify!(set_halt_steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_ffwd_steps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(step_info_interface),
            "::",
            stringify!(get_ffwd_steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_ffwd_steps) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(step_info_interface),
            "::",
            stringify!(set_ffwd_steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_ma_steps) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(step_info_interface),
            "::",
            stringify!(get_ma_steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_ma_steps) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(step_info_interface),
            "::",
            stringify!(set_ma_steps)
        )
    );
}
pub type mmc_interface_t = mmc_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mmc_interface {
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cmd: uint8,
            args: uint32,
            response: buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, data: buffer_t) -> ::std::os::raw::c_int,
    >,
    pub write_data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, data: bytes_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_mmc_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mmc_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mmc_interface>(),
        24usize,
        concat!("Size of: ", stringify!(mmc_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mmc_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mmc_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_command) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmc_interface),
            "::",
            stringify!(send_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mmc_interface),
            "::",
            stringify!(read_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mmc_interface),
            "::",
            stringify!(write_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_list_t {
    pub size: ::std::os::raw::c_int,
    pub used: ::std::os::raw::c_int,
    pub elements: *mut *mut conf_object_t,
}
#[test]
fn bindgen_test_layout_cpu_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_list_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_list_t>(),
        16usize,
        concat!("Size of: ", stringify!(cpu_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_list_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_list_t),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_list_t),
            "::",
            stringify!(elements)
        )
    );
}
impl Default for cpu_list_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cpu_group_interface_t = cpu_group_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpu_group_interface {
    pub get_cpu_list: ::std::option::Option<
        unsafe extern "C" fn(cpu_group: *mut conf_object_t) -> *const cpu_list_t,
    >,
}
#[test]
fn bindgen_test_layout_cpu_group_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_group_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_group_interface>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_group_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_group_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_group_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cpu_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_group_interface),
            "::",
            stringify!(get_cpu_list)
        )
    );
}
pub type jit_control_interface_t = jit_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct jit_control_interface {
    pub set_compile_enable:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, enabled: bool)>,
}
#[test]
fn bindgen_test_layout_jit_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<jit_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<jit_control_interface>(),
        8usize,
        concat!("Size of: ", stringify!(jit_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<jit_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(jit_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_compile_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jit_control_interface),
            "::",
            stringify!(set_compile_enable)
        )
    );
}
pub type register_view_interface_t = register_view_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct register_view_interface {
    pub description: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *const ::std::os::raw::c_char,
    >,
    pub big_endian_bitorder:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub number_of_registers: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_uint,
    >,
    #[doc = " Returns the static information about a register in the list\n[NAME, DESC, SIZE, OFFSET, BITFIELDS, BIG_ENDIAN_BYTE_ORDER].\nAll but the two last\nelement in the list are required and the client should\ntolerate if more than 6 elements are presented in the list.\nNAME must be a valid identifier. DESC is a short description\nof the register. SIZE is the number of bytes of the register,\ncould only be 1, 2, 4, or 8. OFFSET is the offset into the bank\nand can be Nil denoting non-memory-mapped registers.\nBITFIELDS is optional and if present, is a list where each\nelement itself being a list of [NAME, DESC, LSB, MSB] where\nNAME and DESC is the identifier and description of the field\nand LSB and MSB are the least significant and the most significant\nbit in little-endian bitorder. MSB is optional and if omitted,\nis assumed to be the same as LSB, i.e., the bitfield specifies\na single bit.\nBIG_ENDIAN_BYTE_ORDER is an optional boolean value, assumed to be\nFalse if omitted. It controls the byte order of the register's\nmemory-mapped representation; the byte at OFFSET is the\nmost significant byte if BIG_ENDIAN_BYTE_ORDER is True, and\nthe least significant byte otherwise."]
    pub register_info: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg: ::std::os::raw::c_uint) -> attr_value_t,
    >,
    #[doc = " Get the current value of a register, must be side-effect free."]
    pub get_register_value: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg: ::std::os::raw::c_uint) -> uint64,
    >,
    #[doc = " Set the current value of a register, must be side-effect free except\nfrom updating the value."]
    pub set_register_value: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg: ::std::os::raw::c_uint, val: uint64),
    >,
}
#[test]
fn bindgen_test_layout_register_view_interface() {
    const UNINIT: ::std::mem::MaybeUninit<register_view_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<register_view_interface>(),
        48usize,
        concat!("Size of: ", stringify!(register_view_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<register_view_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(register_view_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_interface),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).big_endian_bitorder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_interface),
            "::",
            stringify!(big_endian_bitorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_of_registers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_interface),
            "::",
            stringify!(number_of_registers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_interface),
            "::",
            stringify!(register_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_register_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_interface),
            "::",
            stringify!(get_register_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_register_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_interface),
            "::",
            stringify!(set_register_value)
        )
    );
}
pub type freerun_interface_t = freerun_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct freerun_interface {
    pub enabled: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub advance_clock: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ps_limit: int64,
            steps: int64,
            idle: bool,
        ) -> int64,
    >,
    pub start_clock: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub stop_clock: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub current_itime:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint64>,
}
#[test]
fn bindgen_test_layout_freerun_interface() {
    const UNINIT: ::std::mem::MaybeUninit<freerun_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<freerun_interface>(),
        40usize,
        concat!("Size of: ", stringify!(freerun_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<freerun_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(freerun_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freerun_interface),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advance_clock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(freerun_interface),
            "::",
            stringify!(advance_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_clock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(freerun_interface),
            "::",
            stringify!(start_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_clock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(freerun_interface),
            "::",
            stringify!(stop_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_itime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(freerun_interface),
            "::",
            stringify!(current_itime)
        )
    );
}
pub type processor_info_interface_t = processor_info_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct processor_info_interface {
    pub disassemble: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            address: generic_address_t,
            instruction_data: attr_value_t,
            sub_operation: ::std::os::raw::c_int,
        ) -> tuple_int_string_t,
    >,
    pub set_program_counter:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, pc: logical_address_t)>,
    pub get_program_counter:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> logical_address_t>,
    pub logical_to_physical: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            address: logical_address_t,
            access_type: access_t,
        ) -> physical_block_t,
    >,
    pub enable_processor: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub disable_processor: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_enabled: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_endian:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cpu_endian_t>,
    pub get_physical_memory:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub get_logical_address_width: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_physical_address_width: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub architecture: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_processor_info_interface() {
    const UNINIT: ::std::mem::MaybeUninit<processor_info_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<processor_info_interface>(),
        96usize,
        concat!("Size of: ", stringify!(processor_info_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<processor_info_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(processor_info_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disassemble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(disassemble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_program_counter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(set_program_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_program_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(get_program_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_to_physical) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(logical_to_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_processor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(enable_processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_processor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(disable_processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_enabled) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(get_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_endian) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(get_endian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_physical_memory) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(get_physical_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_logical_address_width) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(get_logical_address_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_physical_address_width) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(get_physical_address_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_interface),
            "::",
            stringify!(architecture)
        )
    );
}
pub type processor_info_v2_interface_t = processor_info_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct processor_info_v2_interface {
    pub disassemble: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            address: generic_address_t,
            instruction_data: attr_value_t,
            sub_operation: ::std::os::raw::c_int,
        ) -> tuple_int_string_t,
    >,
    pub set_program_counter:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, pc: logical_address_t)>,
    pub get_program_counter:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> logical_address_t>,
    pub logical_to_physical: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            address: logical_address_t,
            access_type: access_t,
        ) -> physical_block_t,
    >,
    pub get_processor_mode:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> processor_mode_t>,
    pub enable_processor: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub disable_processor: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_enabled: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_endian:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cpu_endian_t>,
    pub get_physical_memory:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub get_logical_address_width: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_physical_address_width: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub architecture: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_processor_info_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<processor_info_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<processor_info_v2_interface>(),
        104usize,
        concat!("Size of: ", stringify!(processor_info_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<processor_info_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(processor_info_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disassemble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(disassemble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_program_counter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(set_program_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_program_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_program_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_to_physical) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(logical_to_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_processor_mode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_processor_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_processor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(enable_processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_processor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(disable_processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_enabled) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_endian) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_endian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_physical_memory) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_physical_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_logical_address_width) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_logical_address_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_physical_address_width) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(get_physical_address_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_info_v2_interface),
            "::",
            stringify!(architecture)
        )
    );
}
pub type processor_endian_interface_t = processor_endian_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct processor_endian_interface {
    pub get_instruction_endian:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cpu_endian_t>,
    pub get_data_endian:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cpu_endian_t>,
}
#[test]
fn bindgen_test_layout_processor_endian_interface() {
    const UNINIT: ::std::mem::MaybeUninit<processor_endian_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<processor_endian_interface>(),
        16usize,
        concat!("Size of: ", stringify!(processor_endian_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<processor_endian_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(processor_endian_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_instruction_endian) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_endian_interface),
            "::",
            stringify!(get_instruction_endian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_data_endian) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_endian_interface),
            "::",
            stringify!(get_data_endian)
        )
    );
}
pub type processor_cli_interface_t = processor_cli_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct processor_cli_interface {
    pub get_disassembly: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            addr_prefix: *const ::std::os::raw::c_char,
            address: generic_address_t,
            print_cpu: bool,
            mnemonic: *const ::std::os::raw::c_char,
        ) -> tuple_int_string_t,
    >,
    pub get_pregs: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, all: bool) -> *mut ::std::os::raw::c_char,
    >,
    pub get_diff_regs:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_pending_exception_string: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut ::std::os::raw::c_char,
    >,
    pub get_address_prefix: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut ::std::os::raw::c_char,
    >,
    pub translate_to_physical: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            prefix: *const ::std::os::raw::c_char,
            address: generic_address_t,
        ) -> physical_block_t,
    >,
}
#[test]
fn bindgen_test_layout_processor_cli_interface() {
    const UNINIT: ::std::mem::MaybeUninit<processor_cli_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<processor_cli_interface>(),
        48usize,
        concat!("Size of: ", stringify!(processor_cli_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<processor_cli_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(processor_cli_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_disassembly) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_cli_interface),
            "::",
            stringify!(get_disassembly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_pregs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_cli_interface),
            "::",
            stringify!(get_pregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_diff_regs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_cli_interface),
            "::",
            stringify!(get_diff_regs)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_pending_exception_string) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_cli_interface),
            "::",
            stringify!(get_pending_exception_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_address_prefix) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_cli_interface),
            "::",
            stringify!(get_address_prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).translate_to_physical) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_cli_interface),
            "::",
            stringify!(translate_to_physical)
        )
    );
}
#[doc = "<add id=\"opcode_info_interface_t\">\n\nThe <iface>opcode_info</iface> interface is implemented by\nprocessors that need to communicate information about the encoding\nof instructions to the GUI.\n\nThe <fun>get_opcode_length</fun> function returns information about\ninstruction encoding in the current operating mode of the\nprocessor. The <fun>min_alignment</fun> field indicates the\nsmallest allowed alignment of instructions, typically 4 for regular\nRISC architectures. The <fun>max_length</fun> field specifies the\nmaximum instruction length in bytes. The <fun>avg_length</fun> is\nan approximation of the average instruction size.\n\n<insert-until text=\"// ADD INTERFACE opcode_info_interface_t\"/>\n</add>\n<add id=\"opcode_info_interface_exec_context\">\nCell Context for all methods.\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct opcode_length_info_t {
    pub min_alignment: ::std::os::raw::c_int,
    pub max_length: ::std::os::raw::c_int,
    pub avg_length: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_opcode_length_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<opcode_length_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<opcode_length_info_t>(),
        12usize,
        concat!("Size of: ", stringify!(opcode_length_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opcode_length_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(opcode_length_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opcode_length_info_t),
            "::",
            stringify!(min_alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opcode_length_info_t),
            "::",
            stringify!(max_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avg_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opcode_length_info_t),
            "::",
            stringify!(avg_length)
        )
    );
}
pub type opcode_info_interface_t = opcode_info_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct opcode_info_interface {
    pub get_opcode_length_info: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> opcode_length_info_t,
    >,
}
#[test]
fn bindgen_test_layout_opcode_info_interface() {
    const UNINIT: ::std::mem::MaybeUninit<opcode_info_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<opcode_info_interface>(),
        8usize,
        concat!("Size of: ", stringify!(opcode_info_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<opcode_info_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(opcode_info_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_opcode_length_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opcode_info_interface),
            "::",
            stringify!(get_opcode_length_info)
        )
    );
}
pub type processor_gui_interface_t = processor_gui_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct processor_gui_interface {
    pub dummy: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_processor_gui_interface() {
    const UNINIT: ::std::mem::MaybeUninit<processor_gui_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<processor_gui_interface>(),
        8usize,
        concat!("Size of: ", stringify!(processor_gui_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<processor_gui_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(processor_gui_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(processor_gui_interface),
            "::",
            stringify!(dummy)
        )
    );
}
pub type exception_interface_t = exception_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct exception_interface {
    pub get_number: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            exc: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_source: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            exc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub all_exceptions:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_exception_interface() {
    const UNINIT: ::std::mem::MaybeUninit<exception_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exception_interface>(),
        32usize,
        concat!("Size of: ", stringify!(exception_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<exception_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(exception_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_interface),
            "::",
            stringify!(get_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_interface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_interface),
            "::",
            stringify!(get_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_exceptions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_interface),
            "::",
            stringify!(all_exceptions)
        )
    );
}
pub type instrumentation_order_interface_t = instrumentation_order_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instrumentation_order_interface {
    #[doc = " Returns an object list in the connection order"]
    pub get_connections:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub move_before: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut conf_object_t,
            connection: *mut conf_object_t,
            before: *mut conf_object_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_instrumentation_order_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instrumentation_order_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instrumentation_order_interface>(),
        16usize,
        concat!("Size of: ", stringify!(instrumentation_order_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<instrumentation_order_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(instrumentation_order_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connections) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_order_interface),
            "::",
            stringify!(get_connections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_before) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_order_interface),
            "::",
            stringify!(move_before)
        )
    );
}
pub type callback_info_interface_t = callback_info_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct callback_info_interface {
    pub get_callbacks:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_callback_info_interface() {
    const UNINIT: ::std::mem::MaybeUninit<callback_info_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<callback_info_interface>(),
        8usize,
        concat!("Size of: ", stringify!(callback_info_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<callback_info_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_info_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_callbacks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_info_interface),
            "::",
            stringify!(get_callbacks)
        )
    );
}
pub type vga_text_interface_t = vga_text_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vga_text_interface {
    pub add_string_notification: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            substring: *mut ::std::os::raw::c_char,
            sample_interval: f64,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_vga_text_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vga_text_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vga_text_interface>(),
        8usize,
        concat!("Size of: ", stringify!(vga_text_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vga_text_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vga_text_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_string_notification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_text_interface),
            "::",
            stringify!(add_string_notification)
        )
    );
}
pub type vga_text_info_interface_t = vga_text_info_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vga_text_info_interface {
    pub text_mode: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub font_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            width: *mut ::std::os::raw::c_int,
            height: *mut ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub screen_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            columns: *mut ::std::os::raw::c_int,
            rows: *mut ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            text: *mut uint8,
            line_lengths: *mut uint8,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_vga_text_info_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vga_text_info_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vga_text_info_interface>(),
        32usize,
        concat!("Size of: ", stringify!(vga_text_info_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vga_text_info_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vga_text_info_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_text_info_interface),
            "::",
            stringify!(text_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_text_info_interface),
            "::",
            stringify!(font_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screen_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_text_info_interface),
            "::",
            stringify!(screen_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_text_info_interface),
            "::",
            stringify!(text)
        )
    );
}
pub type vga_text_update_interface_t = vga_text_update_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vga_text_update_interface {
    pub write: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_char),
    >,
}
#[test]
fn bindgen_test_layout_vga_text_update_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vga_text_update_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vga_text_update_interface>(),
        8usize,
        concat!("Size of: ", stringify!(vga_text_update_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vga_text_update_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vga_text_update_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vga_text_update_interface),
            "::",
            stringify!(write)
        )
    );
}
pub type data_profiler_interface_t = data_profiler_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct data_profiler_interface {
    #[doc = " computes the sum of all counters in an address range, from start to\nend, inclusive. This function is deprecated; you should use the\nfunctions of the address_profiler interface instead."]
    pub accum_in_range: ::std::option::Option<
        unsafe extern "C" fn(profiler: *mut conf_object_t, start: uint64, end: uint64) -> uint64,
    >,
    #[doc = " write the profiling data to a file"]
    pub save: ::std::option::Option<
        unsafe extern "C" fn(profiler: *mut conf_object_t, file: *const ::std::os::raw::c_char),
    >,
    #[doc = " read profiling data from a file, and adds it to whatever data was\nalready present in the profiler."]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(profiler: *mut conf_object_t, file: *const ::std::os::raw::c_char),
    >,
    #[doc = " resets all counters in the profiler to zero."]
    pub clear: ::std::option::Option<unsafe extern "C" fn(profiler: *mut conf_object_t)>,
    #[doc = " actually returns a prof_data_t*"]
    pub get_prof_data: ::std::option::Option<
        unsafe extern "C" fn(profiler: *mut conf_object_t) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_data_profiler_interface() {
    const UNINIT: ::std::mem::MaybeUninit<data_profiler_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<data_profiler_interface>(),
        40usize,
        concat!("Size of: ", stringify!(data_profiler_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<data_profiler_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(data_profiler_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accum_in_range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(data_profiler_interface),
            "::",
            stringify!(accum_in_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(data_profiler_interface),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(data_profiler_interface),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(data_profiler_interface),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_prof_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(data_profiler_interface),
            "::",
            stringify!(get_prof_data)
        )
    );
}
pub type register_view_read_only_interface_t = register_view_read_only_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct register_view_read_only_interface {
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg: ::std::os::raw::c_uint) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_register_view_read_only_interface() {
    const UNINIT: ::std::mem::MaybeUninit<register_view_read_only_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<register_view_read_only_interface>(),
        8usize,
        concat!("Size of: ", stringify!(register_view_read_only_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<register_view_read_only_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(register_view_read_only_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(register_view_read_only_interface),
            "::",
            stringify!(is_read_only)
        )
    );
}
#[doc = " <add id=\"service routine function\">\n<insert-upto text=\";\"/><ndx>service_routine_t</ndx>\n</add>"]
pub type service_routine_t = ::std::option::Option<
    unsafe extern "C" fn(
        cpu: *mut conf_object_t,
        arg: uint64,
        user_data: *mut lang_void,
    ) -> exception_type_t,
>;
#[doc = " <add id=\"instruction info\">\n<insert-upto text=\"instruction_info_t;\"/>\n<ndx>instruction_info_t</ndx>\n\n<var>ii_ServiceRoutine</var> is a pointer to a function that will\nbe called by Simics every time the instruction is executed. It has\nthe following prototype:\n\n<insert id=\"service routine function\"/>\n\nThe service routine function should return an exception when it is\nfinished to signal its status. If no exception occurs\n<const>Sim_PE_No_Exception</const> should be returned.\n\nSee <type>exception_type_t</type> in\n<file>src/include/simics/base/memory.h</file> for the different\nexceptions available.\n\nA special return value, <const>Sim_PE_Default_Semantics</const>, can be\nreturned; this signals Simics to run the default semantics for the\ninstruction. This is useful if the semantics of an instruction\nshould be changed but the user routine does not want to handle it all\nthe time.\n\nNote that in a shared memory multiprocessor, the CPU\nused in decoding may differ from the CPU that executes the\ninstruction, since the decoded instructions may be cached.\n\n<var>ii_Arg</var> is the argument <var>arg</var> that will be\npassed on to the service routine function. Op code bit-fields for\nthe instruction such as register numbers or intermediate values can\nbe stored here. The <var>ii_UserData</var> field can also be used\nto pass information to the service routine if more data is needed.\n\n<var>ii_Type</var> is either <pp>UD_IT_SEQUENTIAL</pp> or\n<pp>UD_IT_CONTROL_FLOW</pp>.  A sequential type means that the\ninstruction does not perform any branches and the update of the\nprogram counter(s) is handled by Simics. In a control flow\ninstruction on the other hand it is up to the user to set the\nprogram counter(s).\n\n<var>ii_LogicalAddress</var> and <var>ii_PhysicalAddress</var>\nholds the logical and physical addresses of the instruction to be\ndecoded.\n\n</add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instruction_info {
    pub ii_ServiceRoutine: service_routine_t,
    pub ii_Arg: uint64,
    pub ii_Type: ::std::os::raw::c_uint,
    pub ii_UserData: *mut lang_void,
    pub ii_LogicalAddress: logical_address_t,
    pub ii_PhysicalAddress: physical_address_t,
}
#[test]
fn bindgen_test_layout_instruction_info() {
    const UNINIT: ::std::mem::MaybeUninit<instruction_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instruction_info>(),
        48usize,
        concat!("Size of: ", stringify!(instruction_info))
    );
    assert_eq!(
        ::std::mem::align_of::<instruction_info>(),
        8usize,
        concat!("Alignment of ", stringify!(instruction_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ii_ServiceRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_info),
            "::",
            stringify!(ii_ServiceRoutine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ii_Arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_info),
            "::",
            stringify!(ii_Arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ii_Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_info),
            "::",
            stringify!(ii_Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ii_UserData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_info),
            "::",
            stringify!(ii_UserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ii_LogicalAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_info),
            "::",
            stringify!(ii_LogicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ii_PhysicalAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(instruction_info),
            "::",
            stringify!(ii_PhysicalAddress)
        )
    );
}
impl Default for instruction_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"instruction info\">\n<insert-upto text=\"instruction_info_t;\"/>\n<ndx>instruction_info_t</ndx>\n\n<var>ii_ServiceRoutine</var> is a pointer to a function that will\nbe called by Simics every time the instruction is executed. It has\nthe following prototype:\n\n<insert id=\"service routine function\"/>\n\nThe service routine function should return an exception when it is\nfinished to signal its status. If no exception occurs\n<const>Sim_PE_No_Exception</const> should be returned.\n\nSee <type>exception_type_t</type> in\n<file>src/include/simics/base/memory.h</file> for the different\nexceptions available.\n\nA special return value, <const>Sim_PE_Default_Semantics</const>, can be\nreturned; this signals Simics to run the default semantics for the\ninstruction. This is useful if the semantics of an instruction\nshould be changed but the user routine does not want to handle it all\nthe time.\n\nNote that in a shared memory multiprocessor, the CPU\nused in decoding may differ from the CPU that executes the\ninstruction, since the decoded instructions may be cached.\n\n<var>ii_Arg</var> is the argument <var>arg</var> that will be\npassed on to the service routine function. Op code bit-fields for\nthe instruction such as register numbers or intermediate values can\nbe stored here. The <var>ii_UserData</var> field can also be used\nto pass information to the service routine if more data is needed.\n\n<var>ii_Type</var> is either <pp>UD_IT_SEQUENTIAL</pp> or\n<pp>UD_IT_CONTROL_FLOW</pp>.  A sequential type means that the\ninstruction does not perform any branches and the update of the\nprogram counter(s) is handled by Simics. In a control flow\ninstruction on the other hand it is up to the user to set the\nprogram counter(s).\n\n<var>ii_LogicalAddress</var> and <var>ii_PhysicalAddress</var>\nholds the logical and physical addresses of the instruction to be\ndecoded.\n\n</add>"]
pub type instruction_info_t = instruction_info;
#[doc = " <add id=\"user decoder\">\n<insert-upto text=\"decoder_t;\"/>\n<ndx>decoder_t</ndx>\n\nThe <fun>decode</fun> function is called to decode an instruction\npointed to by <param>code</param>.  The first byte corresponds to\nthe lowest address of the instruction in the simulated\nmemory. <param>valid_bytes</param> tells how many bytes can be\nread. The CPU is given in the <param>cpu</param> parameter.  When\nthe decoder has successfully decoded an instruction, it should set\nthe <var>ii_ServiceRoutine</var>, the <var>ii_Arg</var>, and the\n<var>ii_Type</var> members of the <param>ii</param> structure (see\nbelow), and returns the number of bytes used in the decoding.  If\nit does not apply to the given instruction, it should return zero.\nIf the decoder needs more data than <param>valid_bytes</param> it\nshould return a negative number corresponding to the total number\nof bytes it will need to continue the decoding. The underlying\narchitecture limits the number of bytes that can be requested,\ne.g. no more than 4 bytes can be requested on most RISC\narchitectures. Simics will call the decoder again when more bytes\nare available. This process is repeated until the decoder accepts\nor rejects the instruction.  A decoder should never request more\ndata than it needs. For example, if an instructions can be rejected\nby looking at the first byte, the decoder should never ask for more\nbytes.\n\nThe <type>instruction_info_t</type> is defined as follows:\n\n<insert id=\"instruction info\"/>\n\nThe <fun>disassemble</fun> function is called to disassemble an\ninstruction.  It uses the same <param>code</param>,\n<param>valid_bytes</param>, and <param>cpu</param> parameters as\nthe <fun>decode</fun> function. If the disassembly is valid, then\nthe string part of the returned <tt>tuple_int_string_t</tt> struct\nshould be a MALLOCed string with the disassembly and the integer\npart should be its length in bytes.  The caller is responsible for\nfreeing the disassembly string. The string member should be NULL\nand the integer part should be zero if the disassembly is not\nvalid.  If the disassemble function needs more data than\n<param>valid_bytes</param> it should return a negative number in\nthe integer part in the same way as the <fun>decode</fun> function,\nand set the string part to NULL.\n\nThe <fun>flush</fun> function is called to free any memory\nallocated when decoding an instruction and any user data associated\nwith the instruction.  It should return zero if it does not\nrecognize the instruction, and non-zero if it has accepted it.\nUsually, the way to recognize if a decoded instruction is the right\none to flush is to compare <tt>ii->ii_ServiceRoutine</tt> with the\nfunction that was set in the <param>decode</param> function. Note\nthat the <param>cpu</param> parameter is the processor that caused\nthe flush. It is more or less an arbitrary processor and should be\nignored.\n\nIn addition to the function pointers, the\n<type>decoder_t</type> structure contains a\n<var>user_data</var> pointer that is passed to all the\nfunctions.  This can be used for passing any data to the decoder\nfunctions.\n\n</add>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct decoder_t {
    pub user_data: *mut ::std::os::raw::c_void,
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            code: *mut uint8,
            valid_bytes: ::std::os::raw::c_int,
            cpu: *mut conf_object_t,
            ii: *mut instruction_info_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub disassemble: ::std::option::Option<
        unsafe extern "C" fn(
            code: *mut uint8,
            valid_bytes: ::std::os::raw::c_int,
            cpu: *mut conf_object_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> tuple_int_string_t,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            ii: *mut instruction_info_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_decoder_t() {
    const UNINIT: ::std::mem::MaybeUninit<decoder_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<decoder_t>(),
        32usize,
        concat!("Size of: ", stringify!(decoder_t))
    );
    assert_eq!(
        ::std::mem::align_of::<decoder_t>(),
        8usize,
        concat!("Alignment of ", stringify!(decoder_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decoder_t),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decoder_t),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disassemble) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(decoder_t),
            "::",
            stringify!(disassemble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(decoder_t),
            "::",
            stringify!(flush)
        )
    );
}
impl Default for decoder_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type decoder_interface_t = decoder_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct decoder_interface {
    pub register_decoder: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, decoder: *mut decoder_t),
    >,
    pub unregister_decoder: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, decoder: *mut decoder_t),
    >,
}
#[test]
fn bindgen_test_layout_decoder_interface() {
    const UNINIT: ::std::mem::MaybeUninit<decoder_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<decoder_interface>(),
        16usize,
        concat!("Size of: ", stringify!(decoder_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<decoder_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(decoder_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_decoder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decoder_interface),
            "::",
            stringify!(register_decoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_decoder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decoder_interface),
            "::",
            stringify!(unregister_decoder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monitored_attribute {
    _unused: [u8; 0],
}
#[doc = "This is a collection of API calls that allows a customized connection\nbetween frontend extensions and custom target modules.\n\nThe function <fun>register_monitored_attribute</fun> should be called by an\nobject that wishes to communicate the value of an attribute to a frontend\nplug-in. The <param>attr_obj</param> and <param>attr_name</param> parameters\nindicate the attribute to communicate.  The function returns a handle that will\nbe used to refer to this instance of the attribute. The function should be\ncalled before the object is configured, typically from the\n<fun>finalize_instance</fun> method.\n\nAfter an object has registered an attribute with\n<fun>register_monitored_attribute</fun>, the object should call the\nfunction <fun>monitored_attribute_changed</fun> with the returned\nattribute ID whenever the value of that attribute changes, including\nfrom the attribute setter."]
pub type attribute_id_t = monitored_attribute;
pub type attribute_monitor_interface_t = attribute_monitor_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct attribute_monitor_interface {
    pub register_monitored_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            attr_obj: *mut conf_object_t,
            attr_name: *const ::std::os::raw::c_char,
        ) -> *mut attribute_id_t,
    >,
    pub monitored_attribute_changed: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: *mut attribute_id_t),
    >,
}
#[test]
fn bindgen_test_layout_attribute_monitor_interface() {
    const UNINIT: ::std::mem::MaybeUninit<attribute_monitor_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attribute_monitor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(attribute_monitor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<attribute_monitor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(attribute_monitor_interface))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_monitored_attribute) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_monitor_interface),
            "::",
            stringify!(register_monitored_attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitored_attribute_changed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_monitor_interface),
            "::",
            stringify!(monitored_attribute_changed)
        )
    );
}
pub type context_handler_interface_t = context_handler_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct context_handler_interface {
    pub get_current_context:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub set_current_context: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_context_handler_interface() {
    const UNINIT: ::std::mem::MaybeUninit<context_handler_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<context_handler_interface>(),
        16usize,
        concat!("Size of: ", stringify!(context_handler_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<context_handler_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(context_handler_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_current_context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(context_handler_interface),
            "::",
            stringify!(get_current_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_current_context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(context_handler_interface),
            "::",
            stringify!(set_current_context)
        )
    );
}
extern "C" {
    pub fn SIM_register_context_handler(
        cls: *mut conf_class_t,
        iface: *const context_handler_interface_t,
    ) -> ::std::os::raw::c_int;
}
pub type data_profiler_flush_t = ::std::option::Option<
    unsafe extern "C" fn(profiler: *mut conf_object_t, param: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn VT_profiler_add_flush(
        dp: *mut conf_object_t,
        flush_fun: data_profiler_flush_t,
        flush_param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VT_profiler_remove_flush(
        dp: *mut conf_object_t,
        flush_fun: data_profiler_flush_t,
        flush_param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VT_prof_data_inc_pc(prof: *mut prof_data_t, cpu: *mut conf_object_t);
}
pub const event_queue_type_Sim_Queue_Step: event_queue_type = 0;
pub const event_queue_type_Sim_Queue_Time: event_queue_type = 1;
#[doc = " only used to index the event_desc attribute in processors"]
pub type event_queue_type = ::std::os::raw::c_uint;
#[doc = " only used to index the event_desc attribute in processors"]
pub use self::event_queue_type as event_queue_type_t;
#[doc = " Access from a mfspr/mtspr instruction"]
pub const gen_spr_access_type_t_Sim_Gen_Spr_Instruction_Access: gen_spr_access_type_t = 0;
#[doc = " Access through attribute"]
pub const gen_spr_access_type_t_Sim_Gen_Spr_Attribute_Access: gen_spr_access_type_t = 1;
#[doc = " Access through int_register interface"]
pub const gen_spr_access_type_t_Sim_Gen_Spr_Int_Register_Access: gen_spr_access_type_t = 2;
#[doc = " For compatibility with former PPC-only implementation"]
pub const gen_spr_access_type_t_Sim_PPC_Spr_Instruction_Access: gen_spr_access_type_t = 0;
#[doc = " For compatibility with former PPC-only implementation"]
pub const gen_spr_access_type_t_Sim_PPC_Spr_Attribute_Access: gen_spr_access_type_t = 1;
#[doc = " For compatibility with former PPC-only implementation"]
pub const gen_spr_access_type_t_Sim_PPC_Spr_Int_Register_Access: gen_spr_access_type_t = 2;
#[doc = " <add-type id=\"gen_spr_access_type_t def\"></add-type>"]
pub type gen_spr_access_type_t = ::std::os::raw::c_uint;
#[doc = " SPR access was OK"]
pub const gen_spr_ret_t_Sim_Gen_Spr_Ok: gen_spr_ret_t = 0;
#[doc = " SPR access should trigger illegal insn exc"]
pub const gen_spr_ret_t_Sim_Gen_Spr_Illegal: gen_spr_ret_t = 1;
#[doc = " SPR access should trigger privilege exc"]
pub const gen_spr_ret_t_Sim_Gen_Spr_Privilege: gen_spr_ret_t = 2;
#[doc = " SPR access suspends the processor"]
pub const gen_spr_ret_t_Sim_Gen_Spr_Processor_Sleeps: gen_spr_ret_t = 3;
#[doc = " For compatibility with former PPC-only implementation"]
pub const gen_spr_ret_t_Sim_PPC_Spr_Ok: gen_spr_ret_t = 0;
#[doc = " For compatibility with former PPC-only implementation"]
pub const gen_spr_ret_t_Sim_PPC_Spr_Illegal: gen_spr_ret_t = 1;
#[doc = " For compatibility with former PPC-only implementation"]
pub const gen_spr_ret_t_Sim_PPC_Spr_Privilege: gen_spr_ret_t = 2;
#[doc = " <add-type id=\"gen_spr_ret_t def\"></add-type>"]
pub type gen_spr_ret_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"gen_spr_user_getter_func_t def\"></add-type>"]
pub type gen_spr_user_getter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        cpu: *mut conf_object_t,
        spr_number: int64,
        type_: gen_spr_access_type_t,
        user_data: *mut lang_void,
    ) -> gen_spr_ret_t,
>;
#[doc = " <add-type id=\"gen_spr_user_setter_func_t def\"></add-type>"]
pub type gen_spr_user_setter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        cpu: *mut conf_object_t,
        spr_number: int64,
        value: uint64,
        type_: gen_spr_access_type_t,
        user_data: *mut lang_void,
    ) -> gen_spr_ret_t,
>;
extern "C" {
    #[doc = " aliases kept for binary compatibility; to be removed in the next version"]
    pub fn VT_clear_augmentation_bit(page_data: *mut uint8, pofs: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn VT_get_augmentation_bit(
        page_data: *mut uint8,
        pofs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_set_augmentation_bit(page_data: *mut uint8, pofs: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SIM_flush_I_STC_logical(
        cpu: *mut conf_object_t,
        vaddr: logical_address_t,
        length: logical_address_t,
    );
}
extern "C" {
    pub fn SIM_flush_D_STC_logical(
        cpu: *mut conf_object_t,
        vaddr: logical_address_t,
        length: logical_address_t,
    );
}
extern "C" {
    pub fn SIM_flush_I_STC_physical(
        cpu: *mut conf_object_t,
        paddr: physical_address_t,
        length: physical_address_t,
    );
}
extern "C" {
    pub fn SIM_flush_D_STC_physical(
        cpu: *mut conf_object_t,
        paddr: physical_address_t,
        length: physical_address_t,
        read_or_write: read_or_write_t,
    );
}
extern "C" {
    pub fn SIM_STC_flush_cache(cpu: *mut conf_object_t);
}
extern "C" {
    pub fn VT_new_code_block(start: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn VT_check_async_events() -> bool;
}
extern "C" {
    pub fn VT_check_async_events_from_cell(cell: *mut conf_object_t) -> bool;
}
extern "C" {
    pub fn VT_unrestricted_sync_point(obj: *mut conf_object_t);
}
extern "C" {
    pub fn VT_stop_event_processing(obj: *mut conf_object_t);
}
extern "C" {
    pub fn VT_async_events_pending() -> bool;
}
extern "C" {
    pub fn VT_async_events_pending_in_cell(cell: *mut conf_object_t) -> bool;
}
extern "C" {
    pub fn VT_local_async_events_pending(obj: *mut conf_object_t) -> bool;
}
extern "C" {
    pub fn VT_global_async_events_pending() -> bool;
}
extern "C" {
    pub fn VT_register_async_notifier(
        obj: *mut conf_object_t,
        wakeup: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    );
}
extern "C" {
    pub fn VT_unregister_async_notifier(
        obj: *mut conf_object_t,
        wakeup: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    );
}
pub type breakpoint_interface_t = breakpoint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_interface {
    pub insert_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut conf_object_t,
            caller: *mut conf_object_t,
            handle: breakpoint_handle_t,
            access: access_t,
            start: generic_address_t,
            end: generic_address_t,
        ),
    >,
    pub remove_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(object: *mut conf_object_t, handle: breakpoint_handle_t),
    >,
    pub get_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: breakpoint_handle_t,
        ) -> breakpoint_info_t,
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_interface>(),
        24usize,
        concat!("Size of: ", stringify!(breakpoint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).insert_breakpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_interface),
            "::",
            stringify!(insert_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_breakpoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_interface),
            "::",
            stringify!(remove_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_breakpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_interface),
            "::",
            stringify!(get_breakpoint)
        )
    );
}
pub type breakpoint_change_interface_t = breakpoint_change_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_change_interface {
    pub breakpoint_added: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bp_obj: *mut conf_object_t,
            handle: breakpoint_handle_t,
        ),
    >,
    pub breakpoint_removed: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bp_obj: *mut conf_object_t,
            handle: breakpoint_handle_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_change_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_change_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_change_interface>(),
        16usize,
        concat!("Size of: ", stringify!(breakpoint_change_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_change_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_change_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).breakpoint_added) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_change_interface),
            "::",
            stringify!(breakpoint_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).breakpoint_removed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_change_interface),
            "::",
            stringify!(breakpoint_removed)
        )
    );
}
pub type breakpoint_query_interface_t = breakpoint_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_query_interface {
    pub get_breakpoints: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            read_write_execute: access_t,
            start: generic_address_t,
            end: generic_address_t,
        ) -> breakpoint_set_t,
    >,
    pub free_breakpoint_set: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, set: *mut breakpoint_set_t),
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_query_interface>(),
        16usize,
        concat!("Size of: ", stringify!(breakpoint_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_breakpoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_query_interface),
            "::",
            stringify!(get_breakpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_breakpoint_set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_query_interface),
            "::",
            stringify!(free_breakpoint_set)
        )
    );
}
pub type breakpoint_query_v2_interface_t = breakpoint_query_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_query_v2_interface {
    pub get_breakpoints: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            read_write_execute: access_t,
            start: generic_address_t,
            end: generic_address_t,
        ) -> breakpoint_set_t,
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_query_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_query_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_query_v2_interface>(),
        8usize,
        concat!("Size of: ", stringify!(breakpoint_query_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_query_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_query_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_breakpoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_query_v2_interface),
            "::",
            stringify!(get_breakpoints)
        )
    );
}
pub type breakpoint_trigger_interface_t = breakpoint_trigger_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_trigger_interface {
    pub trigger_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator_obj: *mut conf_object_t,
            handle: breakpoint_handle_t,
            address: generic_address_t,
            size: generic_address_t,
            access: access_t,
            data: *mut uint8,
        ),
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_trigger_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_trigger_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_trigger_interface>(),
        8usize,
        concat!("Size of: ", stringify!(breakpoint_trigger_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_trigger_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_trigger_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger_breakpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_trigger_interface),
            "::",
            stringify!(trigger_breakpoint)
        )
    );
}
pub const virtual_breakpoint_flags_t_Virtual_Breakpoint_Flag_Linear: virtual_breakpoint_flags_t = 1;
#[doc = " <add-type id=\"virtual_breakpoint_flags_t\"><ndx>virtual_breakpoint_flags_t</ndx></add-type>"]
pub type virtual_breakpoint_flags_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct virtual_data_bp_handle {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"virtual_data_bp_handle_t\"><ndx>virtual_data_bp_handle_t</ndx></add-type>"]
pub type virtual_data_bp_handle_t = virtual_data_bp_handle;
pub type virtual_data_breakpoint_interface_t = virtual_data_breakpoint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct virtual_data_breakpoint_interface {
    pub add_read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            first: generic_address_t,
            last: generic_address_t,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    initiator: *mut conf_object_t,
                    address: generic_address_t,
                    size: ::std::os::raw::c_uint,
                ),
            >,
            data: cbdata_register_t,
            flags: uint32,
        ) -> *mut virtual_data_bp_handle_t,
    >,
    pub add_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            first: generic_address_t,
            last: generic_address_t,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    initiator: *mut conf_object_t,
                    address: generic_address_t,
                    value: bytes_t,
                ),
            >,
            data: cbdata_register_t,
            flags: uint32,
        ) -> *mut virtual_data_bp_handle_t,
    >,
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bp_handle: *mut virtual_data_bp_handle_t),
    >,
}
#[test]
fn bindgen_test_layout_virtual_data_breakpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<virtual_data_breakpoint_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<virtual_data_breakpoint_interface>(),
        24usize,
        concat!("Size of: ", stringify!(virtual_data_breakpoint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<virtual_data_breakpoint_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(virtual_data_breakpoint_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(virtual_data_breakpoint_interface),
            "::",
            stringify!(add_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(virtual_data_breakpoint_interface),
            "::",
            stringify!(add_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(virtual_data_breakpoint_interface),
            "::",
            stringify!(remove)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct virtual_instr_bp_handle {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"virtual_instr_bp_handle_t\"><ndx>virtual_instr_bp_handle_t</ndx></add-type>"]
pub type virtual_instr_bp_handle_t = virtual_instr_bp_handle;
pub type virtual_instruction_breakpoint_interface_t = virtual_instruction_breakpoint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct virtual_instruction_breakpoint_interface {
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            first: generic_address_t,
            last: generic_address_t,
            filter: ::std::option::Option<
                unsafe extern "C" fn(
                    filter_data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    opcode: bytes_t,
                ) -> bool,
            >,
            filter_data: cbdata_register_t,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    callback_data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    address: generic_address_t,
                    size: ::std::os::raw::c_uint,
                ),
            >,
            callback_data: cbdata_register_t,
            flags: uint32,
        ) -> *mut virtual_instr_bp_handle_t,
    >,
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bp_handle: *mut virtual_instr_bp_handle_t),
    >,
}
#[test]
fn bindgen_test_layout_virtual_instruction_breakpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<virtual_instruction_breakpoint_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<virtual_instruction_breakpoint_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(virtual_instruction_breakpoint_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<virtual_instruction_breakpoint_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(virtual_instruction_breakpoint_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(virtual_instruction_breakpoint_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(virtual_instruction_breakpoint_interface),
            "::",
            stringify!(remove)
        )
    );
}
extern "C" {
    #[doc = " ADD INTERFACE virtual_instruction_breakpoint"]
    pub fn VT_step_stamp(step_obj: *mut conf_object_t) -> int128;
}
extern "C" {
    pub fn SIM_native_path(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_lookup_file(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIM_add_directory(directory: *const ::std::os::raw::c_char, prepend: bool);
}
extern "C" {
    pub fn SIM_clear_directories();
}
extern "C" {
    pub fn SIM_get_directories() -> attr_value_t;
}
extern "C" {
    pub fn VT_get_saved_cwd() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VT_logical_file_size(filename: *const ::std::os::raw::c_char) -> int64;
}
pub const description_type_t_Description_Type_Group: description_type_t = 0;
pub const description_type_t_Description_Type_Int_Reg: description_type_t = 1;
pub const description_type_t_Description_Type_Float_Reg: description_type_t = 2;
pub const description_type_t_Description_Type_Fields_Reg: description_type_t = 3;
pub const description_type_t_Description_Type_Int_Field: description_type_t = 4;
pub const description_type_t_Description_Type_Float_Field: description_type_t = 5;
#[doc = " <add-type id=\"description_type_t def\"><ndx>description_type_t</ndx></add-type>"]
pub type description_type_t = ::std::os::raw::c_uint;
#[doc = " No special role for the register."]
pub const reg_role_t_Reg_Role_None: reg_role_t = 0;
#[doc = " The register is the program counter."]
pub const reg_role_t_Reg_Role_Program_Counter: reg_role_t = 1;
#[doc = " <add-type id=\"reg_role_t def\"><ndx>reg_role_t</ndx></add-type>"]
pub type reg_role_t = ::std::os::raw::c_uint;
pub const reg_bitorder_t_Reg_Bitorder_Little_Endian: reg_bitorder_t = 0;
pub const reg_bitorder_t_Reg_Bitorder_Big_Endian: reg_bitorder_t = 1;
#[doc = " <add-type id=\"reg_bitorder_t def\"><ndx>reg_bitorder_t</ndx></add-type>"]
pub type reg_bitorder_t = ::std::os::raw::c_uint;
#[doc = " Describes a named value. */\n/* <add-type id=\"named_value_t def\"><ndx>named_value_t</ndx></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct named_value_t {
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    #[doc = " Little endian byte order"]
    pub value: bytes_t,
}
#[test]
fn bindgen_test_layout_named_value_t() {
    const UNINIT: ::std::mem::MaybeUninit<named_value_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<named_value_t>(),
        32usize,
        concat!("Size of: ", stringify!(named_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<named_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(named_value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(named_value_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(named_value_t),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(named_value_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for named_value_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"description_t def\"><ndx>description_t</ndx></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct description_t {
    #[doc = " Common fields"]
    pub type_: description_type_t,
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    #[doc = " id used by dwarf for this register\nor -1 if no such id is defined. This\nis ABI specific, but the CPU will\ngive the ids for the most common ABI\nfor that architecture."]
    pub dwarf_id: int16,
    #[doc = " Bitorder convention used in the\ndocumentation for this register or\nfield."]
    pub bitorder: reg_bitorder_t,
    #[doc = " Role of this register in the ABI/HW."]
    pub role: reg_role_t,
    #[doc = " True if the register is memory mapped."]
    pub memory_mapped: bool,
    #[doc = " Offset into the bank for memory mapped\nregisters."]
    pub offset: uint64,
    #[doc = " True if Core_Control_Register_Write and\nCore_Control_Register_Read are triggered\nwhen this register is written or read."]
    pub catchable: bool,
    #[doc = " Most and least significant bit of the\nregister or field. Always given in le\nbitorder. For groups msb == -1 and\nlsb == 0."]
    pub msb: ::std::os::raw::c_int,
    #[doc = " Most and least significant bit of the\nregister or field. Always given in le\nbitorder. For groups msb == -1 and\nlsb == 0."]
    pub lsb: ::std::os::raw::c_int,
    #[doc = " Number of bits in the register, or the\nregister this field is a part of."]
    pub regsize: ::std::os::raw::c_int,
    #[doc = " For registers and fields the id to pass\nto the get and set methods to access the\nregister's value. Fields have the same\nreg_id as the register they are a part\nof. Not valid for groups."]
    pub reg_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_description_t() {
    const UNINIT: ::std::mem::MaybeUninit<description_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<description_t>(),
        72usize,
        concat!("Size of: ", stringify!(description_t))
    );
    assert_eq!(
        ::std::mem::align_of::<description_t>(),
        8usize,
        concat!("Alignment of ", stringify!(description_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwarf_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(dwarf_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitorder) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(bitorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_mapped) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(memory_mapped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).catchable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(catchable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msb) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(msb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lsb) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsize) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(regsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(description_t),
            "::",
            stringify!(reg_id)
        )
    );
}
impl Default for description_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type describe_registers_interface_t = describe_registers_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct describe_registers_interface {
    pub first_child: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            parent: *const description_t,
        ) -> *const description_t,
    >,
    pub next_description: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            prev: *const description_t,
        ) -> *const description_t,
    >,
    pub free_description: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, desc: *const description_t),
    >,
    pub first_named_value: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            parent: *const description_t,
        ) -> *const named_value_t,
    >,
    pub next_named_value: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            prev: *const named_value_t,
        ) -> *const named_value_t,
    >,
    pub free_named_value: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, nv: *const named_value_t),
    >,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            reg_id: ::std::os::raw::c_int,
            dest: buffer_t,
        ),
    >,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            reg_id: ::std::os::raw::c_int,
            value: bytes_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_describe_registers_interface() {
    const UNINIT: ::std::mem::MaybeUninit<describe_registers_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<describe_registers_interface>(),
        64usize,
        concat!("Size of: ", stringify!(describe_registers_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<describe_registers_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(describe_registers_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(next_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(free_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_named_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(first_named_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_named_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(next_named_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_named_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(free_named_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(describe_registers_interface),
            "::",
            stringify!(set)
        )
    );
}
pub type transaction_interface_t = transaction_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct transaction_interface {
    pub issue: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            t: *mut transaction_t,
            addr: uint64,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_transaction_interface() {
    const UNINIT: ::std::mem::MaybeUninit<transaction_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<transaction_interface>(),
        8usize,
        concat!("Size of: ", stringify!(transaction_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<transaction_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(transaction_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).issue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(transaction_interface),
            "::",
            stringify!(issue)
        )
    );
}
pub type cdrom_media_interface_t = cdrom_media_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cdrom_media_interface {
    pub read_toc: ::std::option::Option<
        unsafe extern "C" fn(
            media: *mut conf_object_t,
            buf: *mut uint8,
            msf: ::std::os::raw::c_int,
            start_track: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub capacity: ::std::option::Option<unsafe extern "C" fn(media: *mut conf_object_t) -> uint32>,
    pub read_block: ::std::option::Option<
        unsafe extern "C" fn(
            media: *mut conf_object_t,
            buf: *mut uint8,
            lba: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_raw_block: ::std::option::Option<
        unsafe extern "C" fn(
            media: *mut conf_object_t,
            buf: *mut uint8,
            lba: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub insert: ::std::option::Option<
        unsafe extern "C" fn(media: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub eject: ::std::option::Option<unsafe extern "C" fn(media: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_cdrom_media_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cdrom_media_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cdrom_media_interface>(),
        48usize,
        concat!("Size of: ", stringify!(cdrom_media_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cdrom_media_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cdrom_media_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_toc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdrom_media_interface),
            "::",
            stringify!(read_toc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdrom_media_interface),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_block) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cdrom_media_interface),
            "::",
            stringify!(read_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_raw_block) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cdrom_media_interface),
            "::",
            stringify!(read_raw_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).insert) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cdrom_media_interface),
            "::",
            stringify!(insert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cdrom_media_interface),
            "::",
            stringify!(eject)
        )
    );
}
pub type memory_profiler_interface_t = memory_profiler_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct memory_profiler_interface {
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            access: read_or_write_t,
        ) -> *mut conf_object_t,
    >,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            access: read_or_write_t,
            prof: *mut conf_object_t,
        ) -> bool,
    >,
    pub get_granularity_log2: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_memory_profiler_interface() {
    const UNINIT: ::std::mem::MaybeUninit<memory_profiler_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<memory_profiler_interface>(),
        24usize,
        concat!("Size of: ", stringify!(memory_profiler_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<memory_profiler_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(memory_profiler_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_profiler_interface),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_profiler_interface),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_granularity_log2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_profiler_interface),
            "::",
            stringify!(get_granularity_log2)
        )
    );
}
pub type co_execute_interface_t = co_execute_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct co_execute_interface {
    pub start_thread: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            entry: ::std::option::Option<unsafe extern "C" fn(arg: *mut lang_void)>,
            arg: *mut lang_void,
        ),
    >,
    pub yield_: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_co_execute_interface() {
    const UNINIT: ::std::mem::MaybeUninit<co_execute_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<co_execute_interface>(),
        16usize,
        concat!("Size of: ", stringify!(co_execute_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<co_execute_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(co_execute_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(co_execute_interface),
            "::",
            stringify!(start_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(co_execute_interface),
            "::",
            stringify!(yield_)
        )
    );
}
pub type synchronous_mode_interface_t = synchronous_mode_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct synchronous_mode_interface {
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub leave: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_synchronous_mode_interface() {
    const UNINIT: ::std::mem::MaybeUninit<synchronous_mode_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<synchronous_mode_interface>(),
        16usize,
        concat!("Size of: ", stringify!(synchronous_mode_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<synchronous_mode_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(synchronous_mode_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(synchronous_mode_interface),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leave) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(synchronous_mode_interface),
            "::",
            stringify!(leave)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bank_access {
    _unused: [u8; 0],
}
#[doc = " <add-type id=\"bank_access_t\">\n\nHandle used to monitor and modify the state of register accesses using the\n<iface>bank_before_read_interface_t</iface>,\n<iface>bank_after_read_interface_t</iface>,\n<iface>bank_before_write_interface_t</iface>, and\n<iface>bank_after_write_interface_t</iface> interfaces.\n</add-type>"]
pub type bank_access_t = bank_access;
#[doc = " <add-type id=\"bank_callback_handle_t\">\n\nUnique handle associated with a callback registered through the\n<iface>bank_instrumentation_subscribe_interface_t</iface> interface.\n</add-type>"]
pub type bank_callback_handle_t = usize;
pub type bank_before_read_interface_t = bank_before_read_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bank_before_read_interface {
    pub offset: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub size: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub set_offset: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t, offset: physical_address_t),
    >,
    pub inquire: ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t)>,
    pub initiator: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_bank_before_read_interface() {
    const UNINIT: ::std::mem::MaybeUninit<bank_before_read_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bank_before_read_interface>(),
        40usize,
        concat!("Size of: ", stringify!(bank_before_read_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<bank_before_read_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(bank_before_read_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_read_interface),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_read_interface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_read_interface),
            "::",
            stringify!(set_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inquire) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_read_interface),
            "::",
            stringify!(inquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_read_interface),
            "::",
            stringify!(initiator)
        )
    );
}
pub type bank_after_read_interface_t = bank_after_read_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bank_after_read_interface {
    pub offset: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub size: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub missed: ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t) -> bool>,
    pub value: ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t) -> uint64>,
    pub set_missed:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t, missed: bool)>,
    pub set_value:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t, value: uint64)>,
    pub initiator: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_bank_after_read_interface() {
    const UNINIT: ::std::mem::MaybeUninit<bank_after_read_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bank_after_read_interface>(),
        56usize,
        concat!("Size of: ", stringify!(bank_after_read_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<bank_after_read_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(bank_after_read_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(missed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_missed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(set_missed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_read_interface),
            "::",
            stringify!(initiator)
        )
    );
}
pub type bank_before_write_interface_t = bank_before_write_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bank_before_write_interface {
    pub offset: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub size: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub value: ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t) -> uint64>,
    pub suppress: ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t)>,
    pub set_offset: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t, offset: physical_address_t),
    >,
    pub set_value:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t, value: uint64)>,
    pub initiator: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_bank_before_write_interface() {
    const UNINIT: ::std::mem::MaybeUninit<bank_before_write_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bank_before_write_interface>(),
        56usize,
        concat!("Size of: ", stringify!(bank_before_write_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<bank_before_write_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(bank_before_write_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(suppress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(set_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_before_write_interface),
            "::",
            stringify!(initiator)
        )
    );
}
pub type bank_after_write_interface_t = bank_after_write_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bank_after_write_interface {
    pub offset: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub size: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> physical_address_t,
    >,
    pub missed: ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t) -> bool>,
    pub set_missed:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut bank_access_t, missed: bool)>,
    pub initiator: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut bank_access_t) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_bank_after_write_interface() {
    const UNINIT: ::std::mem::MaybeUninit<bank_after_write_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bank_after_write_interface>(),
        40usize,
        concat!("Size of: ", stringify!(bank_after_write_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<bank_after_write_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(bank_after_write_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_write_interface),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_write_interface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_write_interface),
            "::",
            stringify!(missed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_missed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_write_interface),
            "::",
            stringify!(set_missed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_after_write_interface),
            "::",
            stringify!(initiator)
        )
    );
}
#[doc = " <add-type id=\"before_read_callback_t\"></add-type>"]
pub type before_read_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut conf_object_t,
        access: *mut bank_before_read_interface_t,
        handle: *mut bank_access_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add-type id=\"after_read_callback_t\"></add-type>"]
pub type after_read_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut conf_object_t,
        access: *mut bank_after_read_interface_t,
        handle: *mut bank_access_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add-type id=\"before_write_callback_t\"></add-type>"]
pub type before_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut conf_object_t,
        access: *mut bank_before_write_interface_t,
        handle: *mut bank_access_t,
        user_data: *mut lang_void,
    ),
>;
#[doc = " <add-type id=\"after_write_callback_t\"></add-type>"]
pub type after_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut conf_object_t,
        access: *mut bank_after_write_interface_t,
        handle: *mut bank_access_t,
        user_data: *mut lang_void,
    ),
>;
pub type bank_instrumentation_subscribe_interface_t = bank_instrumentation_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bank_instrumentation_subscribe_interface {
    pub register_before_read: ::std::option::Option<
        unsafe extern "C" fn(
            bank: *mut conf_object_t,
            connection: *mut conf_object_t,
            offset: uint64,
            size: uint64,
            before_read: before_read_callback_t,
            user_data: *mut lang_void,
        ) -> bank_callback_handle_t,
    >,
    pub register_after_read: ::std::option::Option<
        unsafe extern "C" fn(
            bank: *mut conf_object_t,
            connection: *mut conf_object_t,
            offset: uint64,
            size: uint64,
            after_read: after_read_callback_t,
            user_data: *mut lang_void,
        ) -> bank_callback_handle_t,
    >,
    pub register_before_write: ::std::option::Option<
        unsafe extern "C" fn(
            bank: *mut conf_object_t,
            connection: *mut conf_object_t,
            offset: uint64,
            size: uint64,
            before_write: before_write_callback_t,
            user_data: *mut lang_void,
        ) -> bank_callback_handle_t,
    >,
    pub register_after_write: ::std::option::Option<
        unsafe extern "C" fn(
            bank: *mut conf_object_t,
            connection: *mut conf_object_t,
            offset: uint64,
            size: uint64,
            after_write: after_write_callback_t,
            user_data: *mut lang_void,
        ) -> bank_callback_handle_t,
    >,
    pub remove_callback: ::std::option::Option<
        unsafe extern "C" fn(bank: *mut conf_object_t, callback: bank_callback_handle_t),
    >,
    pub remove_connection_callbacks: ::std::option::Option<
        unsafe extern "C" fn(bank: *mut conf_object_t, connection: *mut conf_object_t),
    >,
    pub enable_connection_callbacks: ::std::option::Option<
        unsafe extern "C" fn(bank: *mut conf_object_t, connection: *mut conf_object_t),
    >,
    pub disable_connection_callbacks: ::std::option::Option<
        unsafe extern "C" fn(bank: *mut conf_object_t, connection: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_bank_instrumentation_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<bank_instrumentation_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bank_instrumentation_subscribe_interface>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(bank_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<bank_instrumentation_subscribe_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(bank_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_before_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(register_before_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_after_read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(register_after_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_before_write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(register_before_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_after_write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(register_after_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(remove_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_connection_callbacks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(remove_connection_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_connection_callbacks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(enable_connection_callbacks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disable_connection_callbacks) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_instrumentation_subscribe_interface),
            "::",
            stringify!(disable_connection_callbacks)
        )
    );
}
pub type cycle_event_interface_t = cycle_event_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cycle_event_interface {
    pub cycles: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> cycles_t>,
    pub post: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            evclass: *const event_class_t,
            ev_obj: *mut conf_object_t,
            cycles: cycles_t,
            param: *mut lang_void,
        ),
    >,
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            evclass: *const event_class_t,
            ev_obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ),
    >,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            evclass: *const event_class_t,
            ev_obj: *mut conf_object_t,
            pred: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut lang_void,
                    match_data: *mut lang_void,
                ) -> ::std::os::raw::c_int,
            >,
            match_data: *mut lang_void,
        ) -> cycles_t,
    >,
    pub events:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_cycle_event_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cycle_event_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cycle_event_interface>(),
        40usize,
        concat!("Size of: ", stringify!(cycle_event_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cycle_event_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cycle_event_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_interface),
            "::",
            stringify!(cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_interface),
            "::",
            stringify!(post)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_interface),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_interface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_event_interface),
            "::",
            stringify!(events)
        )
    );
}
pub type cycle_control_interface_t = cycle_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cycle_control_interface {
    pub stop: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub start: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub set_cycle_count:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, cycle_count: cycles_t)>,
}
#[test]
fn bindgen_test_layout_cycle_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cycle_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cycle_control_interface>(),
        24usize,
        concat!("Size of: ", stringify!(cycle_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cycle_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cycle_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_control_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_control_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cycle_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cycle_control_interface),
            "::",
            stringify!(set_cycle_count)
        )
    );
}
pub type temporal_state_interface_t = temporal_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct temporal_state_interface {
    pub save:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut lang_void>,
    pub merge: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, prev: *mut lang_void, killed: *mut lang_void),
    >,
    pub prepare_restore: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub finish_restore:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, state: *mut lang_void)>,
}
#[test]
fn bindgen_test_layout_temporal_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<temporal_state_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<temporal_state_interface>(),
        32usize,
        concat!("Size of: ", stringify!(temporal_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<temporal_state_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(temporal_state_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(temporal_state_interface),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).merge) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(temporal_state_interface),
            "::",
            stringify!(merge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepare_restore) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(temporal_state_interface),
            "::",
            stringify!(prepare_restore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish_restore) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(temporal_state_interface),
            "::",
            stringify!(finish_restore)
        )
    );
}
pub type event_delta_interface_t = event_delta_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct event_delta_interface {
    pub set_delta: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            event_handler_obj: *mut conf_object_t,
            next_event_ec: *const event_class_t,
            delta: uint64,
        ) -> uint64,
    >,
    pub get_delta: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            event_handler_obj: *mut conf_object_t,
        ) -> uint64,
    >,
}
#[test]
fn bindgen_test_layout_event_delta_interface() {
    const UNINIT: ::std::mem::MaybeUninit<event_delta_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_delta_interface>(),
        16usize,
        concat!("Size of: ", stringify!(event_delta_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<event_delta_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(event_delta_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_delta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_delta_interface),
            "::",
            stringify!(set_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_delta) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_delta_interface),
            "::",
            stringify!(get_delta)
        )
    );
}
pub type event_handler_interface_t = event_handler_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct event_handler_interface {
    pub handle_event: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_event_handler_interface() {
    const UNINIT: ::std::mem::MaybeUninit<event_handler_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_handler_interface>(),
        16usize,
        concat!("Size of: ", stringify!(event_handler_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<event_handler_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(event_handler_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_handler_interface),
            "::",
            stringify!(handle_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_handler_interface),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gfx_breakpoint {
    pub id: ::std::os::raw::c_int,
    pub enabled: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub minx: uint32,
    pub miny: uint32,
    pub maxx: uint32,
    pub maxy: uint32,
    pub data: *mut uint8,
    pub next: *mut gfx_breakpoint,
    pub prev: *mut gfx_breakpoint,
}
#[test]
fn bindgen_test_layout_gfx_breakpoint() {
    const UNINIT: ::std::mem::MaybeUninit<gfx_breakpoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gfx_breakpoint>(),
        56usize,
        concat!("Size of: ", stringify!(gfx_breakpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<gfx_breakpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(gfx_breakpoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miny) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(maxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_breakpoint),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for gfx_breakpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gfx_breakpoint_t = gfx_breakpoint;
pub type video_interface_t = video_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct video_interface {
    pub get_breakpoint_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            minx: ::std::os::raw::c_int,
            miny: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            format: *mut uint32,
            bytes: *mut uint32,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub check_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            breakpts: *mut gfx_breakpoint,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_video_interface() {
    const UNINIT: ::std::mem::MaybeUninit<video_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_interface>(),
        16usize,
        concat!("Size of: ", stringify!(video_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<video_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(video_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_breakpoint_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_interface),
            "::",
            stringify!(get_breakpoint_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_breakpoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_interface),
            "::",
            stringify!(check_breakpoint)
        )
    );
}
pub type direct_memory_interface_t = direct_memory_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_interface {
    pub get_handle: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            requester: *mut conf_object_t,
            subsystem: uint64,
            offs: uint64,
            size: ::std::os::raw::c_uint,
        ) -> direct_memory_handle_t,
    >,
    pub request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: direct_memory_handle_t,
            permission: access_t,
            inhibit: access_t,
        ) -> direct_memory_t,
    >,
    pub revoke: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            access: access_t,
            permission: access_t,
            inhibit: access_t,
        ),
    >,
    pub get_user_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: direct_memory_handle_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub set_user_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: direct_memory_handle_t,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: direct_memory_handle_t),
    >,
    pub ack: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: direct_memory_ack_id_t),
    >,
}
#[test]
fn bindgen_test_layout_direct_memory_interface() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_interface>(),
        56usize,
        concat!("Size of: ", stringify!(direct_memory_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(get_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revoke) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(revoke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_user_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(get_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(set_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_interface),
            "::",
            stringify!(ack)
        )
    );
}
pub type direct_memory_lookup_interface_t = direct_memory_lookup_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_lookup_interface {
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            requester: *mut conf_object_t,
            addr: physical_address_t,
            size: ::std::os::raw::c_uint,
            access: access_t,
        ) -> direct_memory_lookup_t,
    >,
}
#[test]
fn bindgen_test_layout_direct_memory_lookup_interface() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_lookup_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_lookup_interface>(),
        8usize,
        concat!("Size of: ", stringify!(direct_memory_lookup_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_lookup_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_lookup_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_interface),
            "::",
            stringify!(lookup)
        )
    );
}
pub type direct_memory_lookup_v2_interface_t = direct_memory_lookup_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_lookup_v2_interface {
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            transaction: *mut transaction_t,
            addr: physical_address_t,
            access: access_t,
        ) -> direct_memory_lookup_t,
    >,
}
#[test]
fn bindgen_test_layout_direct_memory_lookup_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_lookup_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_lookup_v2_interface>(),
        8usize,
        concat!("Size of: ", stringify!(direct_memory_lookup_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_lookup_v2_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(direct_memory_lookup_v2_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_lookup_v2_interface),
            "::",
            stringify!(lookup)
        )
    );
}
pub type direct_memory_update_interface_t = direct_memory_update_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_update_interface {
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target: *mut conf_object_t,
            handle: direct_memory_handle_t,
            id: direct_memory_ack_id_t,
        ),
    >,
    pub update_permission: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target: *mut conf_object_t,
            handle: direct_memory_handle_t,
            lost_access: access_t,
            lost_permission: access_t,
            lost_inhibit: access_t,
            id: direct_memory_ack_id_t,
        ),
    >,
    pub conflicting_access: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target: *mut conf_object_t,
            handle: direct_memory_handle_t,
            conflicting_permission: access_t,
            id: direct_memory_ack_id_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_direct_memory_update_interface() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_update_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_update_interface>(),
        24usize,
        concat!("Size of: ", stringify!(direct_memory_update_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_update_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_update_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_update_interface),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_permission) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_update_interface),
            "::",
            stringify!(update_permission)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conflicting_access) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_update_interface),
            "::",
            stringify!(conflicting_access)
        )
    );
}
pub type direct_memory_flush_interface_t = direct_memory_flush_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_flush_interface {
    pub revoke: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            base: uint64,
            size: uint64,
            access: access_t,
            perm: access_t,
            inhibit: access_t,
        ),
    >,
    pub set_access_bits: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            requester: *mut conf_object_t,
            base: uint64,
            size: uint64,
            access: access_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_direct_memory_flush_interface() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_flush_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_flush_interface>(),
        16usize,
        concat!("Size of: ", stringify!(direct_memory_flush_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_flush_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_flush_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revoke) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_flush_interface),
            "::",
            stringify!(revoke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_access_bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_flush_interface),
            "::",
            stringify!(set_access_bits)
        )
    );
}
pub type direct_memory_tags_interface_t = direct_memory_tags_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct direct_memory_tags_interface {
    pub get_tags_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: direct_memory_handle_t,
        ) -> direct_memory_tags_t,
    >,
}
#[test]
fn bindgen_test_layout_direct_memory_tags_interface() {
    const UNINIT: ::std::mem::MaybeUninit<direct_memory_tags_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<direct_memory_tags_interface>(),
        8usize,
        concat!("Size of: ", stringify!(direct_memory_tags_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<direct_memory_tags_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(direct_memory_tags_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_tags_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(direct_memory_tags_interface),
            "::",
            stringify!(get_tags_data)
        )
    );
}
pub type dummy_memory_page_interface_t = dummy_memory_page_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_memory_page_interface {
    pub dummy: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_dummy_memory_page_interface() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_memory_page_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_memory_page_interface>(),
        8usize,
        concat!("Size of: ", stringify!(dummy_memory_page_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_memory_page_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(dummy_memory_page_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_memory_page_interface),
            "::",
            stringify!(dummy)
        )
    );
}
pub const state_save_kind_t_Sim_State_Default: state_save_kind_t = 1;
#[doc = " not actually used - kept for source compatibility"]
pub type state_save_kind_t = ::std::os::raw::c_uint;
pub type save_state_interface_t = save_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct save_state_interface {
    #[doc = " return the CVS version of the object"]
    pub get_version:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object) -> ::std::os::raw::c_int>,
    #[doc = " return the size needed for the current state"]
    pub get_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " return the alignment needed for the structure"]
    pub get_align: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " save the state in dest. dest must contains enough space\n(get_size with the same parameter should return the size needed)"]
    pub save_state: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            dest: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " load the state from src"]
    pub load_state: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            src: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " compare the state and return 0 if the same"]
    pub compare_state: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            src: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " compare the state and return 0 if the same. print out\nall/the difference according to flags"]
    pub print_state: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            src: *mut ::std::os::raw::c_void,
            symnames: ::std::os::raw::c_int,
            diff: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " host-endian functions (eventually faster, not mandatory)"]
    pub save_state_he: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            dest: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub load_state_he: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            src: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub compare_state_he: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            src: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub print_state_he: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object,
            stype: state_save_kind_t,
            src: *mut ::std::os::raw::c_void,
            symnames: ::std::os::raw::c_int,
            diff: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_save_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<save_state_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<save_state_interface>(),
        88usize,
        concat!("Size of: ", stringify!(save_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<save_state_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(save_state_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(get_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_align) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(get_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(save_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(load_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compare_state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(compare_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).print_state) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(print_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_state_he) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(save_state_he)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_state_he) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(load_state_he)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compare_state_he) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(compare_state_he)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).print_state_he) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(save_state_interface),
            "::",
            stringify!(print_state_he)
        )
    );
}
pub type simulator_cache_interface_t = simulator_cache_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct simulator_cache_interface {
    pub flush: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_simulator_cache_interface() {
    const UNINIT: ::std::mem::MaybeUninit<simulator_cache_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simulator_cache_interface>(),
        8usize,
        concat!("Size of: ", stringify!(simulator_cache_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<simulator_cache_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(simulator_cache_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simulator_cache_interface),
            "::",
            stringify!(flush)
        )
    );
}
pub type packet_interface_t = packet_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct packet_interface {
    pub transfer:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, data: bytes_t)>,
}
#[test]
fn bindgen_test_layout_packet_interface() {
    const UNINIT: ::std::mem::MaybeUninit<packet_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packet_interface>(),
        8usize,
        concat!("Size of: ", stringify!(packet_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<packet_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(packet_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_interface),
            "::",
            stringify!(transfer)
        )
    );
}
pub type device_identification_interface_t = device_identification_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct device_identification_interface {
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            key: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_key: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            index: ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_device_identification_interface() {
    const UNINIT: ::std::mem::MaybeUninit<device_identification_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<device_identification_interface>(),
        16usize,
        concat!("Size of: ", stringify!(device_identification_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<device_identification_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(device_identification_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identification_interface),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identification_interface),
            "::",
            stringify!(get_key)
        )
    );
}
pub type execute_interface_t = execute_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct execute_interface {
    pub run: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub switch_in: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub switch_out: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_execute_interface() {
    const UNINIT: ::std::mem::MaybeUninit<execute_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<execute_interface>(),
        32usize,
        concat!("Size of: ", stringify!(execute_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<execute_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(execute_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_interface),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switch_in) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_interface),
            "::",
            stringify!(switch_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switch_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_interface),
            "::",
            stringify!(switch_out)
        )
    );
}
pub type cell_inspection_interface_t = cell_inspection_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cell_inspection_interface {
    pub set_current_processor_obj: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu_obj: *mut conf_object_t),
    >,
    pub set_current_step_obj: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, step_obj: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_cell_inspection_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cell_inspection_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cell_inspection_interface>(),
        16usize,
        concat!("Size of: ", stringify!(cell_inspection_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cell_inspection_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cell_inspection_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_current_processor_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cell_inspection_interface),
            "::",
            stringify!(set_current_processor_obj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_current_step_obj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cell_inspection_interface),
            "::",
            stringify!(set_current_step_obj)
        )
    );
}
pub type execute_control_interface_t = execute_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct execute_control_interface {
    pub message_pending: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub yield_request: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_execute_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<execute_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<execute_control_interface>(),
        16usize,
        concat!("Size of: ", stringify!(execute_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<execute_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(execute_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_pending) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_control_interface),
            "::",
            stringify!(message_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yield_request) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_control_interface),
            "::",
            stringify!(yield_request)
        )
    );
}
pub type hap_listen_interface_t = hap_listen_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hap_listen_interface {
    pub occurred: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            origin: *mut conf_object_t,
            hap: hap_type_t,
            value: int64,
            ap: *mut __va_list_tag,
            always: bool,
        ),
    >,
}
#[test]
fn bindgen_test_layout_hap_listen_interface() {
    const UNINIT: ::std::mem::MaybeUninit<hap_listen_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hap_listen_interface>(),
        8usize,
        concat!("Size of: ", stringify!(hap_listen_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<hap_listen_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(hap_listen_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).occurred) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hap_listen_interface),
            "::",
            stringify!(occurred)
        )
    );
}
pub const cache_control_operation_t_Cache_Control_Nop: cache_control_operation_t = 0;
pub const cache_control_operation_t_Cache_Control_Fetch_Line: cache_control_operation_t = 1;
pub const cache_control_operation_t_Cache_Control_Invalidate_Line: cache_control_operation_t = 2;
pub const cache_control_operation_t_Cache_Control_Copyback_Line: cache_control_operation_t = 3;
pub const cache_control_operation_t_Cache_Control_Invalidate_Cache: cache_control_operation_t = 4;
pub type cache_control_operation_t = ::std::os::raw::c_uint;
pub type cache_control_interface_t = cache_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cache_control_interface {
    #[doc = " Returns the number of cycles until the operation is complete."]
    pub cache_control: ::std::option::Option<
        unsafe extern "C" fn(
            cache: *mut conf_object_t,
            op: cache_control_operation_t,
            mem_op: *mut generic_transaction_t,
        ) -> cycles_t,
    >,
}
#[test]
fn bindgen_test_layout_cache_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<cache_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cache_control_interface>(),
        8usize,
        concat!("Size of: ", stringify!(cache_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<cache_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(cache_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_control) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cache_control_interface),
            "::",
            stringify!(cache_control)
        )
    );
}
extern "C" {
    pub fn VT_ctx_set_on_context_handler(
        obj: *mut conf_object_t,
        c_handler: *mut conf_object_t,
        bp_flags: uint32,
    );
}
extern "C" {
    pub fn VT_ctx_remove_from_context_handler(
        obj: *mut conf_object_t,
        c_handler: *mut conf_object_t,
    );
}
pub type timing_model_interface_t = timing_model_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timing_model_interface {
    pub operate: ::std::option::Option<
        unsafe extern "C" fn(
            mem_hier: *mut conf_object_t,
            space: *mut conf_object_t,
            map_list: *mut map_list_t,
            mem_op: *mut generic_transaction_t,
        ) -> cycles_t,
    >,
}
#[test]
fn bindgen_test_layout_timing_model_interface() {
    const UNINIT: ::std::mem::MaybeUninit<timing_model_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timing_model_interface>(),
        8usize,
        concat!("Size of: ", stringify!(timing_model_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<timing_model_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(timing_model_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_model_interface),
            "::",
            stringify!(operate)
        )
    );
}
pub type snoop_memory_interface_t = snoop_memory_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct snoop_memory_interface {
    pub operate: ::std::option::Option<
        unsafe extern "C" fn(
            mem_hier: *mut conf_object_t,
            space: *mut conf_object_t,
            map_list: *mut map_list_t,
            mem_op: *mut generic_transaction_t,
        ) -> cycles_t,
    >,
}
#[test]
fn bindgen_test_layout_snoop_memory_interface() {
    const UNINIT: ::std::mem::MaybeUninit<snoop_memory_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<snoop_memory_interface>(),
        8usize,
        concat!("Size of: ", stringify!(snoop_memory_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<snoop_memory_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(snoop_memory_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(snoop_memory_interface),
            "::",
            stringify!(operate)
        )
    );
}
#[doc = " ADD INTERFACE timing_model_interface\n ADD INTERFACE snoop_memory_interface"]
pub type operate_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        mem_hier: *mut conf_object_t,
        space: *mut conf_object_t,
        map_list: *mut map_list_t,
        mem_op: *mut generic_transaction_t,
    ) -> cycles_t,
>;
pub type uint64_state_interface_t = uint64_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct uint64_state_interface {
    pub set: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, level: uint64)>,
}
#[test]
fn bindgen_test_layout_uint64_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<uint64_state_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint64_state_interface>(),
        8usize,
        concat!("Size of: ", stringify!(uint64_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<uint64_state_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(uint64_state_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint64_state_interface),
            "::",
            stringify!(set)
        )
    );
}
pub const abs_pointer_buttons_t_Abs_Pointer_Button_Left: abs_pointer_buttons_t = 32;
pub const abs_pointer_buttons_t_Abs_Pointer_Button_Right: abs_pointer_buttons_t = 16;
pub const abs_pointer_buttons_t_Abs_Pointer_Button_Middle: abs_pointer_buttons_t = 8;
#[doc = " <add id=\"abs_pointer_interface_t\">\n\nInterface implemented by tablet devices. Used by consoles to send touchpad\nevents to the controller. The <fun>set_state</fun> function is called when\nsomething changes in the console. The coordinates are given as scaled\nabsolute scaled values, where (0, 0) is the upper-left corner and (0xffff,\n0xffff) is the lower-right corner.\n\n<insert-until text=\"// ADD INTERFACE abs_pointer_interface\"/>\n\n</add>\n<add id=\"abs_pointer_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type abs_pointer_buttons_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct abs_pointer_state_t {
    pub buttons: abs_pointer_buttons_t,
    pub x: uint16,
    pub y: uint16,
    pub z: uint16,
}
#[test]
fn bindgen_test_layout_abs_pointer_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<abs_pointer_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<abs_pointer_state_t>(),
        12usize,
        concat!("Size of: ", stringify!(abs_pointer_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<abs_pointer_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(abs_pointer_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_state_t),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_state_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_state_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_state_t),
            "::",
            stringify!(z)
        )
    );
}
impl Default for abs_pointer_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type abs_pointer_interface_t = abs_pointer_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct abs_pointer_interface {
    pub set_state: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, state: abs_pointer_state_t),
    >,
}
#[test]
fn bindgen_test_layout_abs_pointer_interface() {
    const UNINIT: ::std::mem::MaybeUninit<abs_pointer_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<abs_pointer_interface>(),
        8usize,
        concat!("Size of: ", stringify!(abs_pointer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<abs_pointer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(abs_pointer_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_interface),
            "::",
            stringify!(set_state)
        )
    );
}
pub type abs_pointer_activate_interface_t = abs_pointer_activate_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct abs_pointer_activate_interface {
    pub enable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub disable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_abs_pointer_activate_interface() {
    const UNINIT: ::std::mem::MaybeUninit<abs_pointer_activate_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<abs_pointer_activate_interface>(),
        16usize,
        concat!("Size of: ", stringify!(abs_pointer_activate_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<abs_pointer_activate_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(abs_pointer_activate_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_activate_interface),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(abs_pointer_activate_interface),
            "::",
            stringify!(disable)
        )
    );
}
pub const ireg_info_t_Sim_RegInfo_Catchable: ireg_info_t = 0;
#[doc = " used in register_info() interface function */\n/* <add id=\"ireg_info_t\"><ndx>ireg_info_t</ndx><insert-upto text=\";\"/></add>"]
pub type ireg_info_t = ::std::os::raw::c_uint;
pub type int_register_interface_t = int_register_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct int_register_interface {
    pub get_number: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            reg: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg: ::std::os::raw::c_int) -> uint64,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg: ::std::os::raw::c_int, val: uint64),
    >,
    pub all_registers:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub register_info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            reg: ::std::os::raw::c_int,
            info: ireg_info_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_int_register_interface() {
    const UNINIT: ::std::mem::MaybeUninit<int_register_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int_register_interface>(),
        48usize,
        concat!("Size of: ", stringify!(int_register_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<int_register_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(int_register_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int_register_interface),
            "::",
            stringify!(get_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int_register_interface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(int_register_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(int_register_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_registers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(int_register_interface),
            "::",
            stringify!(all_registers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(int_register_interface),
            "::",
            stringify!(register_info)
        )
    );
}
#[doc = " run in global context"]
pub const exec_mode_t_Sim_EM_Global: exec_mode_t = 0;
#[doc = " run in standalone thread"]
pub const exec_mode_t_Sim_EM_Thread: exec_mode_t = 1;
#[doc = " TODO: these constants should likely migrate to simics/simulator/callbacks.h."]
pub type exec_mode_t = ::std::os::raw::c_uint;
pub type external_connection_ctl_interface_t = external_connection_ctl_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct external_connection_ctl_interface {
    #[doc = " Call this with a NULL cookie to indicate non-acceptance.\nIf blocking_read is true then this connection will\nuse blocking reads, i.e. calls to read will not return until the\ncomplete buffer has been filled."]
    pub accept: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            id: uint64,
            cookie: *mut lang_void,
            blocking_read: bool,
        ),
    >,
    #[doc = " Return number of bytes read, -1 on error,\nor -2 if there is no data and the read would have blocked\n(only possible if non-blocking reads are used)."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cookie: *mut lang_void,
            buffer: buffer_t,
        ) -> isize,
    >,
    #[doc = " Return number of bytes written, or -1 on error."]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cookie: *mut lang_void,
            bytes: bytes_t,
        ) -> isize,
    >,
    pub write_async: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void, bytes: bytes_t),
    >,
    #[doc = " Indicate if an error was detected during read/write."]
    pub has_error: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void) -> bool,
    >,
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cookie: *mut lang_void,
            notify_mode: notify_mode_t,
            exec_mode: exec_mode_t,
            active: bool,
        ),
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void),
    >,
}
#[test]
fn bindgen_test_layout_external_connection_ctl_interface() {
    const UNINIT: ::std::mem::MaybeUninit<external_connection_ctl_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<external_connection_ctl_interface>(),
        56usize,
        concat!("Size of: ", stringify!(external_connection_ctl_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<external_connection_ctl_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(external_connection_ctl_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_async) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(write_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(has_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_ctl_interface),
            "::",
            stringify!(close)
        )
    );
}
pub type external_connection_events_interface_t = external_connection_events_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct external_connection_events_interface {
    pub on_accept: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, server: *mut conf_object_t, id: uint64),
    >,
    pub on_input: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void),
    >,
    pub can_write: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void),
    >,
}
#[test]
fn bindgen_test_layout_external_connection_events_interface() {
    const UNINIT: ::std::mem::MaybeUninit<external_connection_events_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<external_connection_events_interface>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(external_connection_events_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<external_connection_events_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(external_connection_events_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_accept) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_events_interface),
            "::",
            stringify!(on_accept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_events_interface),
            "::",
            stringify!(on_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(external_connection_events_interface),
            "::",
            stringify!(can_write)
        )
    );
}
pub type tcp_connection_info_interface_t = tcp_connection_info_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tcp_connection_info_interface {
    pub remote_port: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void) -> uint16,
    >,
    pub remote_ip: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cookie: *mut lang_void) -> bytes_t,
    >,
}
#[test]
fn bindgen_test_layout_tcp_connection_info_interface() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_connection_info_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_connection_info_interface>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_connection_info_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_connection_info_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_connection_info_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_connection_info_interface),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_connection_info_interface),
            "::",
            stringify!(remote_ip)
        )
    );
}
#[doc = " Read is an instruction fetch."]
pub const ram_operation_flags_t_Sim_Ram_Op_Fetch: ram_operation_flags_t = 1;
#[doc = " Operation should not cause\natomic reservations to be lost."]
pub const ram_operation_flags_t_Sim_Ram_Op_Non_Coherent: ram_operation_flags_t = 2;
#[doc = " <add id=\"ram_interface_t\">\n<ndx>ram_operation_flags_t</ndx>\n\nThe <iface>ram</iface> interface is implemented by classes that provide\nrandom access read/write memory. The <iface>rom</iface> interface is\nidentical to <iface>ram</iface> but provides read only memory (writes are\ndropped by the memory system).\n\nBoth the ram and rom interfaces are Simics internal, and should not be used\nby user-defined classes.\n\nThe <fun>get_page</fun> method is obsolete and should not be implemented.\n\nThe <fun>fill</fun> method fills a range with a specified byte value.\n\nThe <fun>read</fun> method reads a number of bytes from address\n<param>addr</param> into the buffer <param>data</param>. The number of\nbytes read is given by the buffer size.\n\nThe <fun>write</fun> method writes the bytes in <param>data</param> to\naddress <param>addr</param>.\n\nThe <fun>touch</fun> method is similar to the <fun>read</fun> and\n<fun>write</fun> methods, except that no data is actually transferred; the\nmethod triggers side effects like revoking conflicting direct-memory\npermissions from affected pages. The <param>rw</param> argument determines\nwhether the operation is a handled as a read or as a write.\n\nThe <param>flags</param> argument is a bitmask which modify the behavior\nof <fun>read</fun>, <fun>write</fun> and <fun>touch</fun> operations in\nvarious ways.\n\nThe <fun>size</fun> method returns the memory size in bytes; that is, the\nhighest usable address plus one.\n\n<insert-until text=\"// ADD INTERFACE ram_interface\"/>\n</add>\n<add id=\"ram_interface_exec_context\">\nCell Context for all methods.\n</add>\n<add id=\"rom_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type ram_operation_flags_t = ::std::os::raw::c_uint;
pub type ram_interface_t = ram_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ram_interface {
    #[doc = " The get_page is method is obsolete and should be left\nunimplemented."]
    pub get_page: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, addr: physical_address_t) -> *mut page_t,
    >,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            start: physical_address_t,
            length: uint64,
            value: uint8,
        ),
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: uint64,
            data: buffer_t,
            flags: ram_operation_flags_t,
        ) -> exception_type_t,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: uint64,
            data: bytes_t,
            flags: ram_operation_flags_t,
        ) -> exception_type_t,
    >,
    pub touch: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: uint64,
            size: uint64,
            rw: read_or_write_t,
            flags: ram_operation_flags_t,
        ) -> exception_type_t,
    >,
    pub size: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint64>,
}
#[test]
fn bindgen_test_layout_ram_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ram_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ram_interface>(),
        48usize,
        concat!("Size of: ", stringify!(ram_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ram_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ram_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_page) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_interface),
            "::",
            stringify!(get_page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_interface),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).touch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_interface),
            "::",
            stringify!(touch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_interface),
            "::",
            stringify!(size)
        )
    );
}
pub type rom_interface_t = ram_interface_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ram_callback_entry {
    _unused: [u8; 0],
}
pub type ram_cb_handle_t = ram_callback_entry;
#[doc = " <add id=\"access_filter_cb_t DOC\">\n<ndx>access_filter_cb_t</ndx>\n<name index=\"true\">access_filter_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">access_filter_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"access_filter_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<fun>register_direct_memory_filter_cb</fun> method in the\n<iface>ram_access_subscribe_interface_t</iface> interfaces to get a callback\nwhen a direct page is cached in the CPU. The <param>obj</param> is the\nobject that registered the callback, and the <param>cpu</param> is the\nprocessor which cached the direct page. The target object of the direct page\nlookup is passed in the <param>target</param> argument, typically a ram\nobject. The <param>offset</param>, <param>size</param> and\n<param>access</param> are the ram offset, the size of the cached page,\nand the access type, respectively. The <param>user_data</param> is the user\ndata for the callback. To allow caching of a page, the corresponding bits in\nan <type>access_t</type> should be returned. If 0 is returned the page will\nbe not be cached.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"access_filter_cb_t\"></add-type>"]
pub type access_filter_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        ram: *mut conf_object_t,
        initiator: *mut conf_object_t,
        offset: uint64,
        size: ::std::os::raw::c_uint,
        access: access_t,
        user_data: *mut lang_void,
    ) -> access_t,
>;
#[doc = " <add id=\"ram_access_cb_t DOC\">\n<ndx>ram_access_cb_t</ndx>\n<name index=\"true\">ram_access_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">ram_access_cb_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"ram_access_cb_t\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nInstrumentation callback function registered through the\n<fun>register_access_before_cb</fun> or <fun>register_access_after_cb</fun>\nmethods in the <iface>ram_access_subscribe_interface_t</iface> interface to\nget a callback when a ram/rom object is accessed. <param>obj</param> is the\nobject that registered the callback, and the <param>ram</param> is the\nram/rom object that is accessed. The <param>ram_offset</param> is the offset\nin the ram/rom object where the transaction hits. The <param>t</param>\nargument is a pointer to the <type>transaction_t</type> that is\nperformed. See the access primitives of the <type>transaction_t</type> type\nto see how to examine and modify the transaction. Depending on if the\nregister function is of before or after type, the transaction will be, or\nalready has been completed, at the time of this callback. This places\nrestrictions on what can be done with the transaction.\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"ram_access_cb_t\"></add-type>"]
pub type ram_access_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        ram: *mut conf_object_t,
        ram_offset: uint64,
        t: *mut transaction_t,
        user_data: *mut lang_void,
    ),
>;
pub type ram_access_subscribe_interface_t = ram_access_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ram_access_subscribe_interface {
    pub remove_callback: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: *mut ram_cb_handle_t),
    >,
    pub enable_callback: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: *mut ram_cb_handle_t),
    >,
    pub disable_callback: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: *mut ram_cb_handle_t),
    >,
    pub register_access_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            conn_obj: *mut conf_object_t,
            cb: ram_access_cb_t,
            data: *mut lang_void,
        ) -> *mut ram_cb_handle_t,
    >,
    pub register_access_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            conn_obj: *mut conf_object_t,
            cb: ram_access_cb_t,
            data: *mut lang_void,
        ) -> *mut ram_cb_handle_t,
    >,
    pub register_access_filter_cb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: access_filter_cb_t,
            data: *mut lang_void,
        ) -> *mut ram_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_ram_access_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ram_access_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ram_access_subscribe_interface>(),
        48usize,
        concat!("Size of: ", stringify!(ram_access_subscribe_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ram_access_subscribe_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ram_access_subscribe_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_access_subscribe_interface),
            "::",
            stringify!(remove_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_access_subscribe_interface),
            "::",
            stringify!(enable_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_access_subscribe_interface),
            "::",
            stringify!(disable_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_access_before_cb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_access_subscribe_interface),
            "::",
            stringify!(register_access_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_access_after_cb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_access_subscribe_interface),
            "::",
            stringify!(register_access_after_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_access_filter_cb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ram_access_subscribe_interface),
            "::",
            stringify!(register_access_filter_cb)
        )
    );
}
pub type keyboard_interface_t = keyboard_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct keyboard_interface {
    pub keyboard_event: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            key_up: ::std::os::raw::c_int,
            key: uint8,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_keyboard_interface() {
    const UNINIT: ::std::mem::MaybeUninit<keyboard_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<keyboard_interface>(),
        8usize,
        concat!("Size of: ", stringify!(keyboard_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<keyboard_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(keyboard_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyboard_interface),
            "::",
            stringify!(keyboard_event)
        )
    );
}
pub type keyboard_console_interface_t = keyboard_console_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct keyboard_console_interface {
    pub keyboard_ready: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_keyboard_console_interface() {
    const UNINIT: ::std::mem::MaybeUninit<keyboard_console_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<keyboard_console_interface>(),
        8usize,
        concat!("Size of: ", stringify!(keyboard_console_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<keyboard_console_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(keyboard_console_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_ready) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyboard_console_interface),
            "::",
            stringify!(keyboard_ready)
        )
    );
}
pub type kbd_console_interface_t = kbd_console_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct kbd_console_interface {
    pub keyboard_ready: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_kbd_console_interface() {
    const UNINIT: ::std::mem::MaybeUninit<kbd_console_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kbd_console_interface>(),
        8usize,
        concat!("Size of: ", stringify!(kbd_console_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<kbd_console_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(kbd_console_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_ready) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kbd_console_interface),
            "::",
            stringify!(keyboard_ready)
        )
    );
}
pub type mouse_interface_t = mouse_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mouse_interface {
    pub mouse_event: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            xmicro: ::std::os::raw::c_int,
            ymicro: ::std::os::raw::c_int,
            z: ::std::os::raw::c_int,
            buttons: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_mouse_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mouse_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mouse_interface>(),
        8usize,
        concat!("Size of: ", stringify!(mouse_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mouse_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mouse_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouse_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mouse_interface),
            "::",
            stringify!(mouse_event)
        )
    );
}
pub type frequency_interface_t = frequency_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct frequency_interface {
    pub get: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> f64>,
}
#[test]
fn bindgen_test_layout_frequency_interface() {
    const UNINIT: ::std::mem::MaybeUninit<frequency_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frequency_interface>(),
        8usize,
        concat!("Size of: ", stringify!(frequency_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<frequency_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(frequency_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frequency_interface),
            "::",
            stringify!(get)
        )
    );
}
pub type frequency_listener_interface_t = frequency_listener_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct frequency_listener_interface {
    pub set: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, numerator: uint64, denominator: uint64),
    >,
}
#[test]
fn bindgen_test_layout_frequency_listener_interface() {
    const UNINIT: ::std::mem::MaybeUninit<frequency_listener_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frequency_listener_interface>(),
        8usize,
        concat!("Size of: ", stringify!(frequency_listener_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<frequency_listener_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(frequency_listener_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frequency_listener_interface),
            "::",
            stringify!(set)
        )
    );
}
pub type scale_factor_listener_interface_t = scale_factor_listener_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct scale_factor_listener_interface {
    pub set: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, numerator: uint64, denominator: uint64),
    >,
}
#[test]
fn bindgen_test_layout_scale_factor_listener_interface() {
    const UNINIT: ::std::mem::MaybeUninit<scale_factor_listener_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<scale_factor_listener_interface>(),
        8usize,
        concat!("Size of: ", stringify!(scale_factor_listener_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<scale_factor_listener_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(scale_factor_listener_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scale_factor_listener_interface),
            "::",
            stringify!(set)
        )
    );
}
pub type simple_dispatcher_interface_t = simple_dispatcher_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct simple_dispatcher_interface {
    pub subscribe: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            listener: *mut conf_object_t,
            listener_port: *const ::std::os::raw::c_char,
        ),
    >,
    pub unsubscribe: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            listener: *mut conf_object_t,
            listener_port: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_simple_dispatcher_interface() {
    const UNINIT: ::std::mem::MaybeUninit<simple_dispatcher_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simple_dispatcher_interface>(),
        16usize,
        concat!("Size of: ", stringify!(simple_dispatcher_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<simple_dispatcher_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(simple_dispatcher_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simple_dispatcher_interface),
            "::",
            stringify!(subscribe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsubscribe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(simple_dispatcher_interface),
            "::",
            stringify!(unsubscribe)
        )
    );
}
#[doc = " <add-type id=\"interrupt_ack_interface_t|interrupt_cpu_interface_t\">\nThe <tt>interrupt_ack_fn_t</tt> function is called by an interrupt target\nto ack an interrupt. Returns the interrupt vector.\n<ndx>interrupt_ack_fn_t</ndx>\n</add-type>"]
pub type interrupt_ack_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut conf_object_t) -> ::std::os::raw::c_int>;
pub type interrupt_ack_interface_t = interrupt_ack_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interrupt_ack_interface {
    pub raise_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cb: interrupt_ack_fn_t,
            ack_obj: *mut conf_object_t,
        ),
    >,
    pub lower_interrupt: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cb: interrupt_ack_fn_t),
    >,
}
#[test]
fn bindgen_test_layout_interrupt_ack_interface() {
    const UNINIT: ::std::mem::MaybeUninit<interrupt_ack_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interrupt_ack_interface>(),
        16usize,
        concat!("Size of: ", stringify!(interrupt_ack_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<interrupt_ack_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(interrupt_ack_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raise_interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_ack_interface),
            "::",
            stringify!(raise_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_interrupt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_ack_interface),
            "::",
            stringify!(lower_interrupt)
        )
    );
}
pub type interrupt_cpu_interface_t = interrupt_cpu_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interrupt_cpu_interface {
    pub ack: interrupt_ack_fn_t,
}
#[test]
fn bindgen_test_layout_interrupt_cpu_interface() {
    const UNINIT: ::std::mem::MaybeUninit<interrupt_cpu_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interrupt_cpu_interface>(),
        8usize,
        concat!("Size of: ", stringify!(interrupt_cpu_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<interrupt_cpu_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(interrupt_cpu_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_cpu_interface),
            "::",
            stringify!(ack)
        )
    );
}
pub type io_memory_interface_t = io_memory_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct io_memory_interface {
    pub _deprecated_map: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            memory_or_io: addr_space_t,
            map_info: map_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub operation: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_op: *mut generic_transaction_t,
            map_info: map_info_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_io_memory_interface() {
    const UNINIT: ::std::mem::MaybeUninit<io_memory_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<io_memory_interface>(),
        16usize,
        concat!("Size of: ", stringify!(io_memory_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<io_memory_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(io_memory_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._deprecated_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_memory_interface),
            "::",
            stringify!(_deprecated_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_memory_interface),
            "::",
            stringify!(operation)
        )
    );
}
#[doc = " obsolete typedefs kept for compatibility"]
pub type map_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        memory_or_io: addr_space_t,
        map_info: map_info_t,
    ) -> ::std::os::raw::c_int,
>;
pub type operation_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        mem_op: *mut generic_transaction_t,
        map_info: map_info_t,
    ) -> exception_type_t,
>;
extern "C" {
    pub fn VT_io_memory_operation(
        obj: *mut conf_object_t,
        iface: *mut io_memory_interface_t,
        memop: *mut generic_transaction_t,
        data: bytes_t,
        info: map_info_t,
    ) -> bytes_t;
}
pub type map_demap_interface_t = map_demap_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct map_demap_interface {
    #[doc = " old-style"]
    pub add_map: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            target: *mut conf_object_t,
            map_info: map_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub remove_map: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            function: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_default: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            target: *mut conf_object_t,
            map_info: map_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub remove_default: ::std::option::Option<unsafe extern "C" fn(space: *mut conf_object_t)>,
    #[doc = " new-style"]
    pub map_simple: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            dev_port: *const ::std::os::raw::c_char,
            map_info: map_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub map_bridge: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            dev_port: *const ::std::os::raw::c_char,
            target: *mut conf_object_t,
            target_port: *const ::std::os::raw::c_char,
            map_info: map_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub unmap: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            dev_port: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub unmap_address: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            dev: *mut conf_object_t,
            base: physical_address_t,
            dev_port: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_map_demap_interface() {
    const UNINIT: ::std::mem::MaybeUninit<map_demap_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<map_demap_interface>(),
        64usize,
        concat!("Size of: ", stringify!(map_demap_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<map_demap_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(map_demap_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(add_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(remove_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_default) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(add_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_default) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(remove_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_simple) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(map_simple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_bridge) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(map_bridge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmap) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(unmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmap_address) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(map_demap_interface),
            "::",
            stringify!(unmap_address)
        )
    );
}
pub type memory_space_interface_t = memory_space_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct memory_space_interface {
    pub space_lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mop: *mut generic_transaction_t,
            mapinfo: map_info_t,
        ) -> *mut map_list_t,
    >,
    pub access: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mop: *mut generic_transaction_t,
        ) -> exception_type_t,
    >,
    pub access_simple: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: physical_address_t,
            buf: *mut uint8,
            len: physical_address_t,
            type_: read_or_write_t,
            endian: endianness_t,
        ) -> exception_type_t,
    >,
    pub access_simple_inq: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: physical_address_t,
            buf: *mut uint8,
            len: physical_address_t,
            type_: read_or_write_t,
            endian: endianness_t,
        ) -> exception_type_t,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: physical_address_t,
            length: ::std::os::raw::c_int,
            inquiry: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: physical_address_t,
            data: attr_value_t,
            inquiry: ::std::os::raw::c_int,
        ) -> exception_type_t,
    >,
    pub timing_model_operate: ::std::option::Option<
        unsafe extern "C" fn(
            space: *mut conf_object_t,
            mop: *mut generic_transaction_t,
        ) -> cycles_t,
    >,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            start: physical_address_t,
            size: uint64,
            value: uint8,
            inquiry: bool,
        ) -> uint64,
    >,
}
#[test]
fn bindgen_test_layout_memory_space_interface() {
    const UNINIT: ::std::mem::MaybeUninit<memory_space_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<memory_space_interface>(),
        64usize,
        concat!("Size of: ", stringify!(memory_space_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<memory_space_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(memory_space_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space_lookup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(space_lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_simple) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(access_simple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_simple_inq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(access_simple_inq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing_model_operate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(timing_model_operate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_space_interface),
            "::",
            stringify!(fill)
        )
    );
}
pub type port_space_interface_t = port_space_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct port_space_interface {
    pub port_operation: ::std::option::Option<
        unsafe extern "C" fn(
            pspace_obj: *mut conf_object_t,
            mop: *mut generic_transaction_t,
            map_info: map_info_t,
        ) -> exception_type_t,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: physical_address_t,
            length: ::std::os::raw::c_int,
            inquiry: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            addr: physical_address_t,
            data: attr_value_t,
            inquiry: ::std::os::raw::c_int,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_port_space_interface() {
    const UNINIT: ::std::mem::MaybeUninit<port_space_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<port_space_interface>(),
        24usize,
        concat!("Size of: ", stringify!(port_space_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<port_space_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(port_space_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port_space_interface),
            "::",
            stringify!(port_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(port_space_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(port_space_interface),
            "::",
            stringify!(write)
        )
    );
}
pub type translate_interface_t = translate_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct translate_interface {
    pub translate: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_op: *mut generic_transaction_t,
            mapinfo: map_info_t,
        ) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_translate_interface() {
    const UNINIT: ::std::mem::MaybeUninit<translate_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<translate_interface>(),
        8usize,
        concat!("Size of: ", stringify!(translate_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<translate_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(translate_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).translate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(translate_interface),
            "::",
            stringify!(translate)
        )
    );
}
pub type bridge_interface_t = bridge_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct bridge_interface {
    pub not_taken: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            src_space: *mut conf_object_t,
            dst_space: *mut conf_object_t,
            ex: exception_type_t,
            mem_op: *mut generic_transaction_t,
            mapinfo: map_info_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_bridge_interface() {
    const UNINIT: ::std::mem::MaybeUninit<bridge_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bridge_interface>(),
        8usize,
        concat!("Size of: ", stringify!(bridge_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<bridge_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(bridge_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).not_taken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bridge_interface),
            "::",
            stringify!(not_taken)
        )
    );
}
pub type signal_interface_t = signal_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct signal_interface {
    pub signal_raise: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub signal_lower: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_signal_interface() {
    const UNINIT: ::std::mem::MaybeUninit<signal_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<signal_interface>(),
        16usize,
        concat!("Size of: ", stringify!(signal_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_raise) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_interface),
            "::",
            stringify!(signal_raise)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_lower) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_interface),
            "::",
            stringify!(signal_lower)
        )
    );
}
pub type multi_level_signal_interface_t = multi_level_signal_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct multi_level_signal_interface {
    pub signal_level_change:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, level: uint64)>,
    pub signal_current_level:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, level: uint64)>,
}
#[test]
fn bindgen_test_layout_multi_level_signal_interface() {
    const UNINIT: ::std::mem::MaybeUninit<multi_level_signal_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<multi_level_signal_interface>(),
        16usize,
        concat!("Size of: ", stringify!(multi_level_signal_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<multi_level_signal_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(multi_level_signal_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_level_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_level_signal_interface),
            "::",
            stringify!(signal_level_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_current_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_level_signal_interface),
            "::",
            stringify!(signal_current_level)
        )
    );
}
pub type pulse_interface_t = pulse_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pulse_interface {
    pub pulse: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_pulse_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pulse_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pulse_interface>(),
        8usize,
        concat!("Size of: ", stringify!(pulse_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pulse_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pulse_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pulse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pulse_interface),
            "::",
            stringify!(pulse)
        )
    );
}
#[doc = " <add-type id=\"mips_memory_transaction_t def\">\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_memory_transaction {
    #[doc = " generic transaction"]
    pub s: generic_transaction_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_mips_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<mips_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_memory_transaction>(),
        112usize,
        concat!("Size of: ", stringify!(mips_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(mips_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_memory_transaction),
            "::",
            stringify!(s)
        )
    );
}
impl Default for mips_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl mips_memory_transaction {
    #[inline]
    pub fn cache_coherency(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cache_coherency(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache_coherency: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let cache_coherency: u32 = unsafe { ::std::mem::transmute(cache_coherency) };
            cache_coherency as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " <add-type id=\"mips_memory_transaction_t def\">\n</add-type>"]
pub type mips_memory_transaction_t = mips_memory_transaction;
extern "C" {
    pub fn SIM_mips_mem_trans_from_generic(
        mop: *mut generic_transaction_t,
    ) -> *mut mips_memory_transaction_t;
}
pub type mips_interface_t = mips_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_interface {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mips_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mips_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_interface>(),
        4usize,
        concat!("Size of: ", stringify!(mips_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_interface>(),
        4usize,
        concat!("Alignment of ", stringify!(mips_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_interface),
            "::",
            stringify!(dummy)
        )
    );
}
pub type mips_coprocessor_interface_t = mips_coprocessor_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_coprocessor_interface {
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            reg: uint32,
            sel: uint32,
        ) -> uint64,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            value: uint64,
            reg: uint32,
            sel: uint32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_mips_coprocessor_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mips_coprocessor_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_coprocessor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(mips_coprocessor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_coprocessor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mips_coprocessor_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_coprocessor_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_coprocessor_interface),
            "::",
            stringify!(write_register)
        )
    );
}
pub type fmn_station_control_interface_t = fmn_station_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct fmn_station_control_interface {
    pub send_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            rt_value: uint64,
        ) -> uint64,
    >,
    pub load_message: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, thread_id: uint32, bucket: uint8),
    >,
    pub wait: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            vector: uint8,
        ) -> ::std::os::raw::c_int,
    >,
    pub sync:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, thread_id: uint32)>,
}
#[test]
fn bindgen_test_layout_fmn_station_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<fmn_station_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fmn_station_control_interface>(),
        32usize,
        concat!("Size of: ", stringify!(fmn_station_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<fmn_station_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(fmn_station_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_interface),
            "::",
            stringify!(send_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_interface),
            "::",
            stringify!(load_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_interface),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_interface),
            "::",
            stringify!(sync)
        )
    );
}
pub type fmn_station_control_v2_interface_t = fmn_station_control_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct fmn_station_control_v2_interface {
    pub send_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            rt_value: uint64,
        ) -> uint64,
    >,
    pub load_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            rt_value: uint64,
        ) -> uint64,
    >,
    pub wait: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            thread_id: uint32,
            rt_value: uint64,
        ) -> ::std::os::raw::c_int,
    >,
    pub sync:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, thread_id: uint32)>,
}
#[test]
fn bindgen_test_layout_fmn_station_control_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<fmn_station_control_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fmn_station_control_v2_interface>(),
        32usize,
        concat!("Size of: ", stringify!(fmn_station_control_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<fmn_station_control_v2_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fmn_station_control_v2_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_v2_interface),
            "::",
            stringify!(send_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_v2_interface),
            "::",
            stringify!(load_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_v2_interface),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fmn_station_control_v2_interface),
            "::",
            stringify!(sync)
        )
    );
}
pub type mips_cache_instruction_interface_t = mips_cache_instruction_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_cache_instruction_interface {
    pub cache_instruction: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut conf_object_t,
            cpu: *mut conf_object_t,
            op: uint32,
            vaddr: logical_address_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_mips_cache_instruction_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mips_cache_instruction_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_cache_instruction_interface>(),
        8usize,
        concat!("Size of: ", stringify!(mips_cache_instruction_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_cache_instruction_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mips_cache_instruction_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_instruction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_cache_instruction_interface),
            "::",
            stringify!(cache_instruction)
        )
    );
}
pub type mips_ite_interface_t = mips_ite_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_ite_interface {
    pub set_dtag_lo:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint32)>,
    pub get_dtag_lo: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub get_errctl: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub block_tc: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub gated_exception: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub current_tc_num: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub unblock_tc: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, tc_num: ::std::os::raw::c_int),
    >,
    pub is_big_endian: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
}
#[test]
fn bindgen_test_layout_mips_ite_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mips_ite_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_ite_interface>(),
        64usize,
        concat!("Size of: ", stringify!(mips_ite_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_ite_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mips_ite_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_dtag_lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(set_dtag_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_dtag_lo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(get_dtag_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_errctl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(get_errctl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_tc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(block_tc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gated_exception) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(gated_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_tc_num) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(current_tc_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unblock_tc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(unblock_tc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_big_endian) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_ite_interface),
            "::",
            stringify!(is_big_endian)
        )
    );
}
pub type mips_eic_interface_t = mips_eic_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_eic_interface {
    pub cpu_pending_irqs:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, cause: uint32)>,
    pub requested_ipl:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub requested_offset:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub requested_vect_num:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub reg_set: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub handled: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_mips_eic_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mips_eic_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_eic_interface>(),
        48usize,
        concat!("Size of: ", stringify!(mips_eic_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_eic_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mips_eic_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_pending_irqs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_eic_interface),
            "::",
            stringify!(cpu_pending_irqs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requested_ipl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_eic_interface),
            "::",
            stringify!(requested_ipl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requested_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_eic_interface),
            "::",
            stringify!(requested_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requested_vect_num) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_eic_interface),
            "::",
            stringify!(requested_vect_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_set) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_eic_interface),
            "::",
            stringify!(reg_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handled) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_eic_interface),
            "::",
            stringify!(handled)
        )
    );
}
pub type mips_exception_query_interface_t = mips_exception_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mips_exception_query_interface {
    pub return_pc: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut exception_handle_t,
        ) -> logical_address_t,
    >,
}
#[test]
fn bindgen_test_layout_mips_exception_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mips_exception_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mips_exception_query_interface>(),
        8usize,
        concat!("Size of: ", stringify!(mips_exception_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_exception_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mips_exception_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_pc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_exception_query_interface),
            "::",
            stringify!(return_pc)
        )
    );
}
pub type sh_interrupt_interface_t = sh_interrupt_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sh_interrupt_interface {
    pub change_pending: ::std::option::Option<
        unsafe extern "C" fn(
            cpu_obj: *mut conf_object_t,
            level: ::std::os::raw::c_int,
            intevt: uint32,
            mod_imask_flag: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sh_interrupt_interface() {
    const UNINIT: ::std::mem::MaybeUninit<sh_interrupt_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sh_interrupt_interface>(),
        8usize,
        concat!("Size of: ", stringify!(sh_interrupt_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<sh_interrupt_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(sh_interrupt_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_pending) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh_interrupt_interface),
            "::",
            stringify!(change_pending)
        )
    );
}
pub const x86_access_type_X86_Other: x86_access_type = 0;
pub const x86_access_type_X86_Vanilla: x86_access_type = 1;
pub const x86_access_type_X86_Instruction: x86_access_type = 2;
pub const x86_access_type_X86_Clflush: x86_access_type = 3;
pub const x86_access_type_X86_Fpu_Env: x86_access_type = 4;
pub const x86_access_type_X86_Fpu_State: x86_access_type = 5;
pub const x86_access_type_X86_Idt: x86_access_type = 6;
pub const x86_access_type_X86_Gdt: x86_access_type = 7;
pub const x86_access_type_X86_Ldt: x86_access_type = 8;
pub const x86_access_type_X86_Task_Segment: x86_access_type = 9;
pub const x86_access_type_X86_Task_Switch: x86_access_type = 10;
pub const x86_access_type_X86_Far_Call_Parameter: x86_access_type = 11;
pub const x86_access_type_X86_Stack: x86_access_type = 12;
pub const x86_access_type_X86_Pml4: x86_access_type = 13;
pub const x86_access_type_X86_Pdp: x86_access_type = 14;
pub const x86_access_type_X86_Pd: x86_access_type = 15;
pub const x86_access_type_X86_Pt: x86_access_type = 16;
pub const x86_access_type_X86_Sse: x86_access_type = 17;
pub const x86_access_type_X86_Fpu: x86_access_type = 18;
pub const x86_access_type_X86_Access_Simple: x86_access_type = 19;
pub const x86_access_type_X86_Microcode_Update: x86_access_type = 20;
pub const x86_access_type_X86_Non_Temporal: x86_access_type = 21;
pub const x86_access_type_X86_Prefetch_3DNow: x86_access_type = 22;
pub const x86_access_type_X86_Prefetchw_3DNow: x86_access_type = 23;
pub const x86_access_type_X86_Prefetch_T0: x86_access_type = 24;
pub const x86_access_type_X86_Prefetch_T1: x86_access_type = 25;
pub const x86_access_type_X86_Prefetch_T2: x86_access_type = 26;
pub const x86_access_type_X86_Prefetch_NTA: x86_access_type = 27;
pub const x86_access_type_X86_Loadall: x86_access_type = 28;
pub const x86_access_type_X86_Atomic_Info: x86_access_type = 29;
pub const x86_access_type_X86_Cmpxchg16b: x86_access_type = 30;
pub const x86_access_type_X86_Smm_State: x86_access_type = 31;
pub const x86_access_type_X86_Vmcs: x86_access_type = 32;
pub const x86_access_type_X86_Vmx_IO_Bitmap: x86_access_type = 33;
pub const x86_access_type_X86_Vmx_Vapic: x86_access_type = 34;
pub const x86_access_type_X86_Vmx_Msr: x86_access_type = 35;
pub const x86_access_type_X86_Vmx_Msr_Bitmaps: x86_access_type = 36;
pub const x86_access_type_X86_Pml4e: x86_access_type = 37;
pub const x86_access_type_X86_Pdpte: x86_access_type = 38;
pub const x86_access_type_X86_Pde: x86_access_type = 39;
pub const x86_access_type_X86_Pte: x86_access_type = 40;
pub const x86_access_type_X86_Invept_Descriptor: x86_access_type = 41;
pub const x86_access_type_X86_Shadow_Stack: x86_access_type = 42;
pub const x86_access_type_X86_Invvpid_Descriptor: x86_access_type = 43;
pub const x86_access_type_X86_Processor_Trace: x86_access_type = 44;
pub const x86_access_type_X86_Pml5: x86_access_type = 45;
pub const x86_access_type_X86_Pml5e: x86_access_type = 46;
pub const x86_access_type_X86_Pdp_Pae: x86_access_type = 47;
pub const x86_access_type_X86_Vmx_EPTP_List: x86_access_type = 48;
pub const x86_access_type_X86_Vmx_VE_Info: x86_access_type = 49;
pub const x86_access_type_X86_Sppt: x86_access_type = 50;
pub const x86_access_type_X86_Pml_Log: x86_access_type = 51;
pub const x86_access_type_X86_Pebs: x86_access_type = 52;
pub const x86_access_type_X86_Vmx_Pasid_Translation: x86_access_type = 53;
pub const x86_access_type_X86_Stack_Explicit: x86_access_type = 54;
pub const x86_access_type_X86_Mtt_Metadata: x86_access_type = 55;
pub const x86_access_type_X86_Prefetch_Other: x86_access_type = 56;
pub const x86_access_type_X86_Access_Type_Last: x86_access_type = 57;
#[doc = " <add-type id=\"x86_access_type_t\">\nSee online help for expanded output of this type:\napi-help x86_access_type_t\n</add-type>"]
pub type x86_access_type = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"x86_access_type_t\">\nSee online help for expanded output of this type:\napi-help x86_access_type_t\n</add-type>"]
pub use self::x86_access_type as x86_access_type_t;
pub type x86_access_type_interface_t = x86_access_type_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_access_type_interface {
    pub get_enum_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            at: x86_access_type_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_short_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            at: x86_access_type_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            at: x86_access_type_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub implicit: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, at: x86_access_type_t) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_x86_access_type_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_access_type_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_access_type_interface>(),
        32usize,
        concat!("Size of: ", stringify!(x86_access_type_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_access_type_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_access_type_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_enum_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_access_type_interface),
            "::",
            stringify!(get_enum_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_short_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_access_type_interface),
            "::",
            stringify!(get_short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_access_type_interface),
            "::",
            stringify!(get_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implicit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_access_type_interface),
            "::",
            stringify!(implicit)
        )
    );
}
pub const x86_memory_type_t_X86_None: x86_memory_type_t = 0;
#[doc = " UC"]
pub const x86_memory_type_t_X86_Strong_Uncacheable: x86_memory_type_t = 1;
#[doc = " UC-"]
pub const x86_memory_type_t_X86_Uncacheable: x86_memory_type_t = 2;
#[doc = " WC"]
pub const x86_memory_type_t_X86_Write_Combining: x86_memory_type_t = 3;
#[doc = " WT"]
pub const x86_memory_type_t_X86_Write_Through: x86_memory_type_t = 4;
#[doc = " WB"]
pub const x86_memory_type_t_X86_Write_Back: x86_memory_type_t = 5;
#[doc = " WP"]
pub const x86_memory_type_t_X86_Write_Protected: x86_memory_type_t = 6;
#[doc = " <add-type id=\"x86_memory_type_t\"> </add-type>"]
pub type x86_memory_type_t = ::std::os::raw::c_uint;
pub const x86_sync_instruction_type_t_X86_SFence: x86_sync_instruction_type_t = 1;
pub const x86_sync_instruction_type_t_X86_LFence: x86_sync_instruction_type_t = 2;
pub const x86_sync_instruction_type_t_X86_MFence: x86_sync_instruction_type_t = 3;
#[doc = " <add-type id=\"x86_sync_instruction_type_t def\"></add-type>"]
pub type x86_sync_instruction_type_t = ::std::os::raw::c_uint;
pub const x86_register_id_t_X86_Reg_Id_Rax: x86_register_id_t = 0;
pub const x86_register_id_t_X86_Reg_Id_Rcx: x86_register_id_t = 1;
pub const x86_register_id_t_X86_Reg_Id_Rdx: x86_register_id_t = 2;
pub const x86_register_id_t_X86_Reg_Id_Rbx: x86_register_id_t = 3;
pub const x86_register_id_t_X86_Reg_Id_Rsp: x86_register_id_t = 4;
pub const x86_register_id_t_X86_Reg_Id_Rbp: x86_register_id_t = 5;
pub const x86_register_id_t_X86_Reg_Id_Rsi: x86_register_id_t = 6;
pub const x86_register_id_t_X86_Reg_Id_Rdi: x86_register_id_t = 7;
pub const x86_register_id_t_X86_Reg_Id_R8: x86_register_id_t = 8;
pub const x86_register_id_t_X86_Reg_Id_R9: x86_register_id_t = 9;
pub const x86_register_id_t_X86_Reg_Id_R10: x86_register_id_t = 10;
pub const x86_register_id_t_X86_Reg_Id_R11: x86_register_id_t = 11;
pub const x86_register_id_t_X86_Reg_Id_R12: x86_register_id_t = 12;
pub const x86_register_id_t_X86_Reg_Id_R13: x86_register_id_t = 13;
pub const x86_register_id_t_X86_Reg_Id_R14: x86_register_id_t = 14;
pub const x86_register_id_t_X86_Reg_Id_R15: x86_register_id_t = 15;
pub const x86_register_id_t_X86_Reg_Id_Xmm0: x86_register_id_t = 16;
pub const x86_register_id_t_X86_Reg_Id_Xmm1: x86_register_id_t = 17;
pub const x86_register_id_t_X86_Reg_Id_Xmm2: x86_register_id_t = 18;
pub const x86_register_id_t_X86_Reg_Id_Xmm3: x86_register_id_t = 19;
pub const x86_register_id_t_X86_Reg_Id_Xmm4: x86_register_id_t = 20;
pub const x86_register_id_t_X86_Reg_Id_Xmm5: x86_register_id_t = 21;
pub const x86_register_id_t_X86_Reg_Id_Xmm6: x86_register_id_t = 22;
pub const x86_register_id_t_X86_Reg_Id_Xmm7: x86_register_id_t = 23;
pub const x86_register_id_t_X86_Reg_Id_Xmm8: x86_register_id_t = 24;
pub const x86_register_id_t_X86_Reg_Id_Xmm9: x86_register_id_t = 25;
pub const x86_register_id_t_X86_Reg_Id_Xmm10: x86_register_id_t = 26;
pub const x86_register_id_t_X86_Reg_Id_Xmm11: x86_register_id_t = 27;
pub const x86_register_id_t_X86_Reg_Id_Xmm12: x86_register_id_t = 28;
pub const x86_register_id_t_X86_Reg_Id_Xmm13: x86_register_id_t = 29;
pub const x86_register_id_t_X86_Reg_Id_Xmm14: x86_register_id_t = 30;
pub const x86_register_id_t_X86_Reg_Id_Xmm15: x86_register_id_t = 31;
pub const x86_register_id_t_X86_Reg_Id_Mm0: x86_register_id_t = 32;
pub const x86_register_id_t_X86_Reg_Id_Mm1: x86_register_id_t = 33;
pub const x86_register_id_t_X86_Reg_Id_Mm2: x86_register_id_t = 34;
pub const x86_register_id_t_X86_Reg_Id_Mm3: x86_register_id_t = 35;
pub const x86_register_id_t_X86_Reg_Id_Mm4: x86_register_id_t = 36;
pub const x86_register_id_t_X86_Reg_Id_Mm5: x86_register_id_t = 37;
pub const x86_register_id_t_X86_Reg_Id_Mm6: x86_register_id_t = 38;
pub const x86_register_id_t_X86_Reg_Id_Mm7: x86_register_id_t = 39;
#[doc = " this is RIP"]
pub const x86_register_id_t_X86_Reg_Id_PC: x86_register_id_t = 40;
#[doc = " integer condition code flags"]
pub const x86_register_id_t_X86_Reg_Id_CF: x86_register_id_t = 41;
#[doc = " DST field used to cache PF flag"]
pub const x86_register_id_t_X86_Reg_Id_DST: x86_register_id_t = 42;
pub const x86_register_id_t_X86_Reg_Id_AF: x86_register_id_t = 43;
pub const x86_register_id_t_X86_Reg_Id_ZF: x86_register_id_t = 44;
pub const x86_register_id_t_X86_Reg_Id_SF: x86_register_id_t = 45;
pub const x86_register_id_t_X86_Reg_Id_OF: x86_register_id_t = 46;
pub const x86_register_id_t_X86_Reg_Id_DF: x86_register_id_t = 47;
#[doc = " the whole 32 bits eflags"]
pub const x86_register_id_t_X86_Reg_Id_EFLAGS: x86_register_id_t = 48;
#[doc = " floating point cc flags"]
pub const x86_register_id_t_X86_Reg_Id_C0: x86_register_id_t = 49;
pub const x86_register_id_t_X86_Reg_Id_C1: x86_register_id_t = 50;
pub const x86_register_id_t_X86_Reg_Id_C2: x86_register_id_t = 51;
pub const x86_register_id_t_X86_Reg_Id_C3: x86_register_id_t = 52;
#[doc = " floating point stack top"]
pub const x86_register_id_t_X86_Reg_Id_Top: x86_register_id_t = 53;
#[doc = " dummy number that can be used"]
pub const x86_register_id_t_X86_Reg_Id_Not_Used: x86_register_id_t = 54;
#[doc = " keep this one last"]
pub const x86_register_id_t_X86_Reg_Id_Local_Max: x86_register_id_t = 55;
#[doc = " <add-type id=\"x86_register_id type\"><ndx>x86_register_id_t</ndx>\n</add-type>"]
pub type x86_register_id_t = ::std::os::raw::c_uint;
pub const x86_memory_or_io_t_X86_Memory: x86_memory_or_io_t = 0;
pub const x86_memory_or_io_t_X86_IO: x86_memory_or_io_t = 1;
#[doc = " <add-type id=\"x86_memory_or_io_t\"> </add-type>"]
pub type x86_memory_or_io_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"x86_memory_transaction_t def\">\n<insert-until text=\"// JDOCU INSERT-UNTIL x86_memory_transaction_t\"/>\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_memory_transaction {
    #[doc = " Superclass"]
    pub s: generic_transaction_t,
    pub linear_address: linear_address_t,
    pub guest_physical_address: physical_address_t,
    #[doc = " segment number"]
    pub segnum: uint16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mode: processor_mode_t,
    pub access_type: x86_access_type_t,
    pub pat_type: x86_memory_type_t,
    pub mtrr_type: x86_memory_type_t,
    pub effective_type: x86_memory_type_t,
    #[doc = " used for -stall"]
    pub sequence_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_x86_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<x86_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_memory_transaction>(),
        152usize,
        concat!("Size of: ", stringify!(x86_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_address) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(linear_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guest_physical_address) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(guest_physical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segnum) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(segnum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pat_type) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(pat_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtrr_type) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(mtrr_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).effective_type) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(effective_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_transaction),
            "::",
            stringify!(sequence_number)
        )
    );
}
impl Default for x86_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl x86_memory_transaction {
    #[inline]
    pub fn access_linear(&self) -> uint16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_access_linear(&mut self, val: uint16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io(&self) -> uint16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_io(&mut self, val: uint16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fault_as_if_write(&self) -> uint16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fault_as_if_write(&mut self, val: uint16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn guest_phys_valid(&self) -> uint16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_guest_phys_valid(&mut self, val: uint16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        access_linear: uint16,
        io: uint16,
        fault_as_if_write: uint16,
        guest_phys_valid: uint16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let access_linear: u16 = unsafe { ::std::mem::transmute(access_linear) };
            access_linear as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io: u16 = unsafe { ::std::mem::transmute(io) };
            io as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fault_as_if_write: u16 = unsafe { ::std::mem::transmute(fault_as_if_write) };
            fault_as_if_write as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let guest_phys_valid: u16 = unsafe { ::std::mem::transmute(guest_phys_valid) };
            guest_phys_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " <add id=\"x86_memory_transaction_t def\">\n<insert-until text=\"// JDOCU INSERT-UNTIL x86_memory_transaction_t\"/>\n</add-type>"]
pub type x86_memory_transaction_t = x86_memory_transaction;
extern "C" {
    #[doc = " JDOCU INSERT-UNTIL x86_memory_transaction_t"]
    pub fn SIM_x86_mem_trans_from_generic(
        mop: *mut generic_transaction_t,
    ) -> *mut x86_memory_transaction_t;
}
#[doc = " old alias for compatibility, deprecated"]
pub type p2_memory_transaction_t = x86_memory_transaction;
#[doc = " <add id=\"x86_tlb_interface_t\">\nThe x86 tlb interface is used for communication between an x86 cpu\nand its TLB. The TLB is implemented as a separate class for greater\nflexibility. The TLB object does no memory operations itself.\n\n<ndx>tagged_physical_address_t</ndx>\n<insert-until text=\"// ADD INTERFACE x86_tlb_interface\"/>\n\nAll functions in the interface get the <i>object</i> implementing\nthe interface as their first parameter.\n\n<b>flush_all</b> is called when all TLB entries should be\nflushed. If <i>keep_global_entries</i> is set, then TLB entries\nwith their global bit set should not be flushed.\n\n<b>flush_page</b> is invoked when pages containing <i>laddr</i> are\nto be removed from the TLB.\n\n<b>lookup</b> is used by the CPU when a memory access misses the\nSTC. It must return true (non-zero) if and only if the memory\noperation specified by <i>mem_tr</i> hits the TLB and does not\nraise an exception. The <i>mode</i>, <i>linear_address</i> are valid when\nthe method is invoked. The other fields passed through <i>mem_tr</i>\nare undefined. If the method returns true, the\n<i>s.physical_address</i>, <i>pat_type</i>, and <i>mtrr_type</i>\nfields of <i>mem_tr</i> must be updated by <b>lookup</b>.\n\nAn access that misses in <b>lookup</b> but does not raise a fault\nis inserted into the TLB with <b>add</b>. The <i>page_size</i>\nencoding is 0 for 4 kb pages, 1 for 2 Mb pages, and 2 for 4 Mb\npages.\n\n<b>itlb_lookup</b> is a simplified version of <b>lookup</b> used\nonly for instruction TLB lookups. If the lookup is successful\n<i>valid</i> and <i>paddr</i> should be set, otherwise <i>valid</i>\nshould be cleared.\n\n<b>set_pae_mode</b> is invoked when the cpu changes the\nPAE enable bit.\n\nIt class implementing the interface must make sure that only\naddresses mapped in the TLB are present in the STCs.\n\nThis interface may be changed or replaced with an architecture\nindependent interface in future versions of Simics.\n\n</add>\n<add id=\"x86_tlb_interface_exec_context\">\nCell Context for all methods.\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tagged_physical_address_t {
    pub valid: ::std::os::raw::c_int,
    pub paddr: physical_address_t,
}
#[test]
fn bindgen_test_layout_tagged_physical_address_t() {
    const UNINIT: ::std::mem::MaybeUninit<tagged_physical_address_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagged_physical_address_t>(),
        16usize,
        concat!("Size of: ", stringify!(tagged_physical_address_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tagged_physical_address_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tagged_physical_address_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagged_physical_address_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagged_physical_address_t),
            "::",
            stringify!(paddr)
        )
    );
}
pub type x86_tlb_interface_t = x86_tlb_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_interface {
    pub flush_all: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, keep_global_entries: ::std::os::raw::c_int),
    >,
    pub flush_page: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, laddr: linear_address_t),
    >,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_tr: *mut x86_memory_transaction_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mode: processor_mode_t,
            read_or_write: read_or_write_t,
            data_or_instr: data_or_instr_t,
            global_page: ::std::os::raw::c_int,
            pat_type: x86_memory_type_t,
            mtrr_type: x86_memory_type_t,
            laddr: linear_address_t,
            paddr: physical_address_t,
            page_size: ::std::os::raw::c_int,
        ),
    >,
    pub itlb_lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            laddr: linear_address_t,
            mode: processor_mode_t,
        ) -> tagged_physical_address_t,
    >,
    pub set_pae_mode:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, pae_mode: bool)>,
}
#[test]
fn bindgen_test_layout_x86_tlb_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_interface>(),
        48usize,
        concat!("Size of: ", stringify!(x86_tlb_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_tlb_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_all) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_interface),
            "::",
            stringify!(flush_all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_page) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_interface),
            "::",
            stringify!(flush_page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_interface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itlb_lookup) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_interface),
            "::",
            stringify!(itlb_lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_pae_mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_interface),
            "::",
            stringify!(set_pae_mode)
        )
    );
}
#[doc = " ADD INTERFACE x86_tlb_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_attrs_t {
    pub supervisor_access: access_t,
    pub user_access: access_t,
    pub global_page: bool,
    pub pat_type: x86_memory_type_t,
    pub mtrr_type: x86_memory_type_t,
    pub page_size_k: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_x86_tlb_attrs_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_attrs_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_attrs_t>(),
        24usize,
        concat!("Size of: ", stringify!(x86_tlb_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_attrs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(x86_tlb_attrs_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supervisor_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_t),
            "::",
            stringify!(supervisor_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_access) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_t),
            "::",
            stringify!(user_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_page) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_t),
            "::",
            stringify!(global_page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pat_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_t),
            "::",
            stringify!(pat_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtrr_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_t),
            "::",
            stringify!(mtrr_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size_k) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_t),
            "::",
            stringify!(page_size_k)
        )
    );
}
impl Default for x86_tlb_attrs_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_entry_t {
    pub linear_page_start: linear_address_t,
    pub physical_page_start: physical_address_t,
    pub attrs: x86_tlb_attrs_t,
}
#[test]
fn bindgen_test_layout_x86_tlb_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_entry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_entry_t>(),
        40usize,
        concat!("Size of: ", stringify!(x86_tlb_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_tlb_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_page_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_entry_t),
            "::",
            stringify!(linear_page_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_page_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_entry_t),
            "::",
            stringify!(physical_page_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_entry_t),
            "::",
            stringify!(attrs)
        )
    );
}
impl Default for x86_tlb_entry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type x86_tlb_v2_interface_t = x86_tlb_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_v2_interface {
    pub flush_all: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, keep_global_entries: ::std::os::raw::c_int),
    >,
    pub flush_page: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, laddr: linear_address_t),
    >,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_tr: *mut x86_memory_transaction_t,
        ) -> *const x86_tlb_entry_t,
    >,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            laddr: linear_address_t,
            paddr: physical_address_t,
            attrs: x86_tlb_attrs_t,
        ),
    >,
    pub itlb_lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            laddr: linear_address_t,
            mode: processor_mode_t,
        ) -> tagged_physical_address_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_tlb_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_v2_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_v2_interface>(),
        40usize,
        concat!("Size of: ", stringify!(x86_tlb_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_tlb_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_all) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v2_interface),
            "::",
            stringify!(flush_all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_page) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v2_interface),
            "::",
            stringify!(flush_page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v2_interface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v2_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itlb_lookup) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v2_interface),
            "::",
            stringify!(itlb_lookup)
        )
    );
}
#[doc = " <add-type id=\"x86_tlb_attrs_v3_t def\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_attrs_v3_t {
    pub pte_attrs: uint64,
    pub pat_type: x86_memory_type_t,
    pub mtrr_type: x86_memory_type_t,
    pub page_size_k: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_x86_tlb_attrs_v3_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_attrs_v3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_attrs_v3_t>(),
        24usize,
        concat!("Size of: ", stringify!(x86_tlb_attrs_v3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_attrs_v3_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_tlb_attrs_v3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pte_attrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_v3_t),
            "::",
            stringify!(pte_attrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pat_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_v3_t),
            "::",
            stringify!(pat_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtrr_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_v3_t),
            "::",
            stringify!(mtrr_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size_k) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_attrs_v3_t),
            "::",
            stringify!(page_size_k)
        )
    );
}
impl Default for x86_tlb_attrs_v3_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"x86_tlb_entry_v3_t def\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_entry_v3_t {
    pub linear_page_start: linear_address_t,
    pub physical_page_start: physical_address_t,
    pub attrs: x86_tlb_attrs_v3_t,
}
#[test]
fn bindgen_test_layout_x86_tlb_entry_v3_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_entry_v3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_entry_v3_t>(),
        40usize,
        concat!("Size of: ", stringify!(x86_tlb_entry_v3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_entry_v3_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_tlb_entry_v3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_page_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_entry_v3_t),
            "::",
            stringify!(linear_page_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_page_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_entry_v3_t),
            "::",
            stringify!(physical_page_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_entry_v3_t),
            "::",
            stringify!(attrs)
        )
    );
}
impl Default for x86_tlb_entry_v3_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const x86_tlb_inv_t_X86_Tlb_Invalidate_Page: x86_tlb_inv_t = 0;
pub const x86_tlb_inv_t_X86_Tlb_Invalidate_Address_Space: x86_tlb_inv_t = 4;
pub const x86_tlb_inv_t_X86_Tlb_Invalidate_Address_Space_NonGlobal: x86_tlb_inv_t = 1;
pub const x86_tlb_inv_t_X86_Tlb_Invalidate_All: x86_tlb_inv_t = 2;
pub const x86_tlb_inv_t_X86_Tlb_Invalidate_All_NonGlobal: x86_tlb_inv_t = 3;
#[doc = " <add-type id=\"x86_tlb_inv_t def\"> </add-type>"]
pub type x86_tlb_inv_t = ::std::os::raw::c_uint;
pub type x86_tlb_v3_interface_t = x86_tlb_v3_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_tlb_v3_interface {
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            hint: uint64,
            laddr: linear_address_t,
            paddr: physical_address_t,
            attrs: x86_tlb_attrs_v3_t,
        ),
    >,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            hint: uint64,
            mem_tr: *mut x86_memory_transaction_t,
        ) -> *const x86_tlb_entry_v3_t,
    >,
    pub itlb_lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            hint: uint64,
            laddr: linear_address_t,
            mode: processor_mode_t,
        ) -> tagged_physical_address_t,
    >,
    pub invalidate_page: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, hint: uint64, laddr: linear_address_t),
    >,
    pub invalidate: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            type_: uint32,
            hint: uint64,
            la: linear_address_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_x86_tlb_v3_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_tlb_v3_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_tlb_v3_interface>(),
        40usize,
        concat!("Size of: ", stringify!(x86_tlb_v3_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_tlb_v3_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_tlb_v3_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v3_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v3_interface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itlb_lookup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v3_interface),
            "::",
            stringify!(itlb_lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate_page) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v3_interface),
            "::",
            stringify!(invalidate_page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_tlb_v3_interface),
            "::",
            stringify!(invalidate)
        )
    );
}
pub const x86_pin_t_Pin_Init: x86_pin_t = 0;
pub const x86_pin_t_Pin_Smi: x86_pin_t = 1;
pub const x86_pin_t_Pin_Nmi: x86_pin_t = 2;
pub const x86_pin_t_Pin_Ignne: x86_pin_t = 3;
pub const x86_pin_t_Pin_Mcerr: x86_pin_t = 4;
pub const x86_pin_t_Pin_Cmci: x86_pin_t = 5;
#[doc = " <add-type id=\"x86_pin_t\"> </add-type>"]
pub type x86_pin_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tagged_linear_address_t {
    pub valid: bool,
    pub addr: linear_address_t,
}
#[test]
fn bindgen_test_layout_tagged_linear_address_t() {
    const UNINIT: ::std::mem::MaybeUninit<tagged_linear_address_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagged_linear_address_t>(),
        16usize,
        concat!("Size of: ", stringify!(tagged_linear_address_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tagged_linear_address_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tagged_linear_address_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagged_linear_address_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagged_linear_address_t),
            "::",
            stringify!(addr)
        )
    );
}
pub type x86_interface_t = x86_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_interface {
    pub set_pin_status: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pin: x86_pin_t,
            status: ::std::os::raw::c_int,
        ),
    >,
    pub start_up:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, start_address: uint32)>,
    pub interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ack: ::std::option::Option<
                unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
            >,
            data: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub uninterrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ack: ::std::option::Option<
                unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
            >,
        ),
    >,
    pub has_pending_interrupt: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub has_waiting_interrupt: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub logical_to_linear: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            segment: ::std::os::raw::c_int,
            addr: logical_address_t,
        ) -> tagged_linear_address_t,
    >,
    pub linear_to_physical: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            d_or_i: data_or_instr_t,
            addr: linear_address_t,
        ) -> physical_address_t,
    >,
    pub enter_acpi_c2_state: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_x86_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_interface>(),
        72usize,
        concat!("Size of: ", stringify!(x86_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_pin_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(set_pin_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_up) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(start_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uninterrupt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(uninterrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_pending_interrupt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(has_pending_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_waiting_interrupt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(has_waiting_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_to_linear) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(logical_to_linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_to_physical) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(linear_to_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enter_acpi_c2_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_interface),
            "::",
            stringify!(enter_acpi_c2_state)
        )
    );
}
#[doc = " ADD INTERFACE x86_interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpuid_ret_t {
    pub taken: ::std::os::raw::c_int,
    pub out_a: uint64,
    pub out_b: uint64,
    pub out_c: uint64,
    pub out_d: uint64,
}
#[test]
fn bindgen_test_layout_cpuid_ret_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpuid_ret_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpuid_ret_t>(),
        40usize,
        concat!("Size of: ", stringify!(cpuid_ret_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuid_ret_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuid_ret_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).taken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret_t),
            "::",
            stringify!(taken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_a) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret_t),
            "::",
            stringify!(out_a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret_t),
            "::",
            stringify!(out_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_c) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret_t),
            "::",
            stringify!(out_c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_d) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_ret_t),
            "::",
            stringify!(out_d)
        )
    );
}
pub type x86_cpuid_interface_t = x86_cpuid_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_cpuid_interface {
    pub cpuid: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cpu: *mut conf_object_t,
            in_eax: uint32,
            in_ebx: uint32,
            in_ecx: uint32,
            in_edx: uint32,
        ) -> cpuid_ret_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_cpuid_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_cpuid_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_cpuid_interface>(),
        8usize,
        concat!("Size of: ", stringify!(x86_cpuid_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cpuid_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_cpuid_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuid_interface),
            "::",
            stringify!(cpuid)
        )
    );
}
#[doc = " ADD INTERFACE x86_cpuid_interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cpuid_value_t {
    pub a: uint64,
    pub b: uint64,
    pub c: uint64,
    pub d: uint64,
}
#[test]
fn bindgen_test_layout_cpuid_value_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpuid_value_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpuid_value_t>(),
        32usize,
        concat!("Size of: ", stringify!(cpuid_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuid_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuid_value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_value_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_value_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_value_t),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_value_t),
            "::",
            stringify!(d)
        )
    );
}
pub type x86_cpuid_query_interface_t = x86_cpuid_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_cpuid_query_interface {
    pub cpuid_query: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            leaf: uint32,
            subleaf: uint32,
        ) -> cpuid_value_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_cpuid_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_cpuid_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_cpuid_query_interface>(),
        8usize,
        concat!("Size of: ", stringify!(x86_cpuid_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cpuid_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_cpuid_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuid_query) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuid_query_interface),
            "::",
            stringify!(cpuid_query)
        )
    );
}
pub const local_apic_interrupt_t_Apic_CMCI: local_apic_interrupt_t = 752;
pub const local_apic_interrupt_t_Apic_Performance_Counter: local_apic_interrupt_t = 832;
pub const local_apic_interrupt_t_Apic_Thermal_Sensor: local_apic_interrupt_t = 816;
#[doc = " <add-type id=\"local_apic_interrupt_t\"></add-type>"]
pub type local_apic_interrupt_t = ::std::os::raw::c_uint;
pub type apic_cpu_interface_t = apic_cpu_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct apic_cpu_interface {
    pub tpr_r: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint64>,
    pub tpr_w: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, tpr: uint64)>,
    pub local_int: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, int_type: local_apic_interrupt_t),
    >,
    pub power_on: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bsp: bool, apic_id: ::std::os::raw::c_int),
    >,
    pub init: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub enabled_r: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
}
#[test]
fn bindgen_test_layout_apic_cpu_interface() {
    const UNINIT: ::std::mem::MaybeUninit<apic_cpu_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apic_cpu_interface>(),
        48usize,
        concat!("Size of: ", stringify!(apic_cpu_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<apic_cpu_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(apic_cpu_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpr_r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_cpu_interface),
            "::",
            stringify!(tpr_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpr_w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_cpu_interface),
            "::",
            stringify!(tpr_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_int) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_cpu_interface),
            "::",
            stringify!(local_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).power_on) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_cpu_interface),
            "::",
            stringify!(power_on)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_cpu_interface),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled_r) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_cpu_interface),
            "::",
            stringify!(enabled_r)
        )
    );
}
pub type a20_interface_t = a20_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a20_interface {
    pub set_a20_line: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
    pub get_a20_line: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_a20_interface() {
    const UNINIT: ::std::mem::MaybeUninit<a20_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<a20_interface>(),
        16usize,
        concat!("Size of: ", stringify!(a20_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<a20_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(a20_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_a20_line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(a20_interface),
            "::",
            stringify!(set_a20_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_a20_line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(a20_interface),
            "::",
            stringify!(get_a20_line)
        )
    );
}
#[doc = " Access from a rdmsr/wrmsr instruction"]
pub const x86_msr_access_type_t_Sim_X86_Msr_Instruction_Access: x86_msr_access_type_t = 0;
#[doc = " Access through attribute"]
pub const x86_msr_access_type_t_Sim_X86_Msr_Attribute_Access: x86_msr_access_type_t = 1;
#[doc = " Access through int_register interface"]
pub const x86_msr_access_type_t_Sim_X86_Msr_Int_Register_Access: x86_msr_access_type_t = 2;
#[doc = " Access during VMX entry/exit"]
pub const x86_msr_access_type_t_Sim_X86_Msr_VMX_Access: x86_msr_access_type_t = 3;
#[doc = " Architectural access without side effects within the CPU model, only\nreads or writes the register value. However, if it is sent to the\nplatform as a non-inquiry access, that may cause side effects."]
pub const x86_msr_access_type_t_Sim_X86_Msr_Architectural_Access: x86_msr_access_type_t = 4;
#[doc = " <add-type id=\"x86_msr_access_type_t def\"></add-type>"]
pub type x86_msr_access_type_t = ::std::os::raw::c_uint;
#[doc = " Access was OK"]
pub const x86_msr_ret_t_Sim_X86_Msr_Ok: x86_msr_ret_t = 0;
#[doc = " Raise #GP fault"]
pub const x86_msr_ret_t_Sim_X86_Msr_GP_Fault: x86_msr_ret_t = 1;
#[doc = " Pass on to next handler"]
pub const x86_msr_ret_t_Sim_X86_Msr_Not_Handled: x86_msr_ret_t = 2;
#[doc = " <add-type id=\"x86_msr_ret_t def\"></add-type>"]
pub type x86_msr_ret_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"x86_msr_getter_ret_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_msr_getter_ret_t {
    pub status: x86_msr_ret_t,
    pub value: uint64,
}
#[test]
fn bindgen_test_layout_x86_msr_getter_ret_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_msr_getter_ret_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_msr_getter_ret_t>(),
        16usize,
        concat!("Size of: ", stringify!(x86_msr_getter_ret_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_msr_getter_ret_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_msr_getter_ret_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_getter_ret_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_getter_ret_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for x86_msr_getter_ret_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"x86_msr_getter_func_t def\"></add-type>"]
pub type x86_msr_getter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        cpu: *mut conf_object_t,
        number: int64,
        type_: x86_msr_access_type_t,
        user_data: *mut lang_void,
    ) -> x86_msr_getter_ret_t,
>;
#[doc = " <add-type id=\"x86_msr_setter_func_t def\"></add-type>"]
pub type x86_msr_setter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        cpu: *mut conf_object_t,
        spr_number: int64,
        value: uint64,
        type_: x86_msr_access_type_t,
        user_data: *mut lang_void,
    ) -> x86_msr_ret_t,
>;
pub type x86_msr_interface_t = x86_msr_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_msr_interface {
    pub register_handlers: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            number: int64,
            getter: x86_msr_getter_func_t,
            getter_data: *mut lang_void,
            setter: x86_msr_setter_func_t,
            setter_data: *mut lang_void,
            name: *const ::std::os::raw::c_char,
        ),
    >,
    pub unregister_handlers:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, number: int64)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            number: int64,
            type_: x86_msr_access_type_t,
        ) -> x86_msr_getter_ret_t,
    >,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            number: int64,
            value: uint64,
            type_: x86_msr_access_type_t,
        ) -> x86_msr_ret_t,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            number: int64,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_number: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, name: *const ::std::os::raw::c_char) -> int64,
    >,
    pub get_all_valid_numbers:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_x86_msr_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_msr_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_msr_interface>(),
        56usize,
        concat!("Size of: ", stringify!(x86_msr_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_msr_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_msr_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_handlers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(register_handlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_handlers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(unregister_handlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_number) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(get_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_all_valid_numbers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msr_interface),
            "::",
            stringify!(get_all_valid_numbers)
        )
    );
}
pub type x86_cache_flush_interface_t = x86_cache_flush_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_cache_flush_interface {
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu: *mut conf_object_t, writeback: bool),
    >,
}
#[test]
fn bindgen_test_layout_x86_cache_flush_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_cache_flush_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_cache_flush_interface>(),
        8usize,
        concat!("Size of: ", stringify!(x86_cache_flush_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cache_flush_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_cache_flush_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cache_flush_interface),
            "::",
            stringify!(flush)
        )
    );
}
#[doc = " Attribute format:\ntype    bit 0..3\ns       bit 4\ndpl     bit 5..6\np       bit 7\navl     bit 12\nl       bit 13\ndb      bit 14\ng       bit 15\ninvalid bit 16"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct smm_reg_state_t {
    pub gpr: [uint64; 16usize],
    pub seg_sel: [uint16; 6usize],
    pub tr_sel: uint16,
    pub ldtr_sel: uint16,
    pub seg_base: [uint64; 6usize],
    pub tr_base: uint64,
    pub ldtr_base: uint64,
    pub seg_attr: [uint32; 6usize],
    pub tr_attr: uint32,
    pub ldtr_attr: uint32,
    pub seg_limit: [uint32; 6usize],
    pub tr_limit: uint32,
    pub ldtr_limit: uint32,
    pub cr0: uint64,
    pub cr2: uint64,
    pub cr3: uint64,
    pub cr4: uint64,
    pub cr8: uint64,
    pub ia32_efer: uint64,
    pub rip: uint64,
    pub rflags: uint64,
    pub dr: [uint64; 4usize],
    pub dr6: uint64,
    pub dr7: uint64,
    pub smbase: uint32,
    pub idtr_limit: uint16,
    pub gdtr_limit: uint16,
    pub idtr_base: uint64,
    pub gdtr_base: uint64,
    pub activity_hlt: bool,
    pub io_instr_restart: bool,
    pub block_nmi: bool,
    pub vmx_mode: uint8,
    pub ept_is_on: bool,
    pub reserved: [bool; 3usize],
    pub io_rip: uint64,
    pub io_lin_addr: uint64,
    pub io_instr_info: uint32,
    pub reserved2: uint32,
    #[doc = " MPX state"]
    pub bndcfgs: uint64,
    #[doc = " valid only if EPT is on"]
    pub eptp: uint64,
    pub pdpte: [uint64; 4usize],
    pub ssp: uint64,
    pub reserved3: [uint64; 6usize],
}
#[test]
fn bindgen_test_layout_smm_reg_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<smm_reg_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<smm_reg_state_t>(),
        544usize,
        concat!("Size of: ", stringify!(smm_reg_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<smm_reg_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(smm_reg_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(gpr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seg_sel) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(seg_sel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr_sel) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(tr_sel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldtr_sel) as usize - ptr as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ldtr_sel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seg_base) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(seg_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr_base) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(tr_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldtr_base) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ldtr_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seg_attr) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(seg_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr_attr) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(tr_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldtr_attr) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ldtr_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seg_limit) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(seg_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr_limit) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(tr_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldtr_limit) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ldtr_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr0) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(cr0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr2) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr3) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr4) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(cr4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr8) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(cr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ia32_efer) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ia32_efer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rflags) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dr) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(dr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dr6) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(dr6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dr7) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(dr7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smbase) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(smbase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idtr_limit) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(idtr_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gdtr_limit) as usize - ptr as usize },
        390usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(gdtr_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idtr_base) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(idtr_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gdtr_base) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(gdtr_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activity_hlt) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(activity_hlt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_instr_restart) as usize - ptr as usize },
        409usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(io_instr_restart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_nmi) as usize - ptr as usize },
        410usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(block_nmi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmx_mode) as usize - ptr as usize },
        411usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(vmx_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ept_is_on) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ept_is_on)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        413usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_rip) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(io_rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_lin_addr) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(io_lin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_instr_info) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(io_instr_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bndcfgs) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(bndcfgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eptp) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(eptp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdpte) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(pdpte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssp) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(ssp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_reg_state_t),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type x86_smm_state_interface_t = x86_smm_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_smm_state_interface {
    pub get_state: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, state: *mut smm_reg_state_t),
    >,
    pub set_state: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, state: *const smm_reg_state_t),
    >,
    pub smram_read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            smram_offs: ::std::os::raw::c_uint,
            len: ::std::os::raw::c_uint,
        ) -> uint64,
    >,
    pub smram_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            smram_offs: ::std::os::raw::c_uint,
            len: ::std::os::raw::c_uint,
            val: uint64,
        ),
    >,
}
#[test]
fn bindgen_test_layout_x86_smm_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_smm_state_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_smm_state_interface>(),
        32usize,
        concat!("Size of: ", stringify!(x86_smm_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_smm_state_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_smm_state_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_smm_state_interface),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_smm_state_interface),
            "::",
            stringify!(set_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smram_read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_smm_state_interface),
            "::",
            stringify!(smram_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smram_write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_smm_state_interface),
            "::",
            stringify!(smram_write)
        )
    );
}
pub type x86_smm_interface_t = x86_smm_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_smm_interface {
    pub save_state: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu: *mut conf_object_t),
    >,
    pub restore_state: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_x86_smm_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_smm_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_smm_interface>(),
        16usize,
        concat!("Size of: ", stringify!(x86_smm_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_smm_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_smm_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_smm_interface),
            "::",
            stringify!(save_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).restore_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_smm_interface),
            "::",
            stringify!(restore_state)
        )
    );
}
#[doc = " <add-type id=\"x86_xmode_info_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_xmode_info_t {
    pub efer_lma: bool,
    pub cs_l: bool,
    pub cs_d: bool,
    pub ss_b: bool,
}
#[test]
fn bindgen_test_layout_x86_xmode_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_xmode_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_xmode_info_t>(),
        4usize,
        concat!("Size of: ", stringify!(x86_xmode_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_xmode_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(x86_xmode_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).efer_lma) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_xmode_info_t),
            "::",
            stringify!(efer_lma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs_l) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_xmode_info_t),
            "::",
            stringify!(cs_l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs_d) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_xmode_info_t),
            "::",
            stringify!(cs_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_b) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_xmode_info_t),
            "::",
            stringify!(ss_b)
        )
    );
}
#[doc = " x86_seg_reg_t describes a segment register and its hidden fields. If valid\nis false, the segment is unusable and attempts to use it will trigger a\nfault in non-64-bit mode. The meaning of each bit in attr is as follows:\ntype    bit 0..3\nS       bit 4\nDPL     bit 5..6\nP       bit 7\nL       bit 13\nD/B     bit 14\nG       bit 15"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_seg_reg_t {
    pub valid: bool,
    pub sel: uint16,
    pub base: uint64,
    pub attr: uint32,
    pub limit: uint32,
}
#[test]
fn bindgen_test_layout_x86_seg_reg_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_seg_reg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_seg_reg_t>(),
        24usize,
        concat!("Size of: ", stringify!(x86_seg_reg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_seg_reg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_seg_reg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_seg_reg_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sel) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_seg_reg_t),
            "::",
            stringify!(sel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_seg_reg_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_seg_reg_t),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_seg_reg_t),
            "::",
            stringify!(limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_system_seg_reg_t {
    pub base: uint64,
    pub limit: uint16,
}
#[test]
fn bindgen_test_layout_x86_system_seg_reg_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_system_seg_reg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_system_seg_reg_t>(),
        16usize,
        concat!("Size of: ", stringify!(x86_system_seg_reg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_system_seg_reg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_system_seg_reg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_system_seg_reg_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_system_seg_reg_t),
            "::",
            stringify!(limit)
        )
    );
}
pub const x86_system_seg_t_X86_Gdtr: x86_system_seg_t = 0;
pub const x86_system_seg_t_X86_Idtr: x86_system_seg_t = 1;
pub type x86_system_seg_t = ::std::os::raw::c_uint;
pub const x86_cr_t_X86_Cr0: x86_cr_t = 0;
pub const x86_cr_t_X86_Cr2: x86_cr_t = 2;
pub const x86_cr_t_X86_Cr3: x86_cr_t = 3;
pub const x86_cr_t_X86_Cr4: x86_cr_t = 4;
pub const x86_cr_t_X86_Cr8: x86_cr_t = 8;
pub type x86_cr_t = ::std::os::raw::c_uint;
pub const x86_dr_t_X86_Dr0: x86_dr_t = 0;
pub const x86_dr_t_X86_Dr1: x86_dr_t = 1;
pub const x86_dr_t_X86_Dr2: x86_dr_t = 2;
pub const x86_dr_t_X86_Dr3: x86_dr_t = 3;
pub const x86_dr_t_X86_Dr6: x86_dr_t = 6;
pub const x86_dr_t_X86_Dr7: x86_dr_t = 7;
pub type x86_dr_t = ::std::os::raw::c_uint;
pub const x86_xcr_t_X86_Xcr0: x86_xcr_t = 0;
pub type x86_xcr_t = ::std::os::raw::c_uint;
pub const x86_activity_t_X86_Activity_Normal: x86_activity_t = 0;
pub const x86_activity_t_X86_Activity_Hlt: x86_activity_t = 1;
pub const x86_activity_t_X86_Activity_Shutdown: x86_activity_t = 2;
pub const x86_activity_t_X86_Activity_Wait_For_SIPI: x86_activity_t = 3;
pub const x86_activity_t_X86_Activity_Cx_State: x86_activity_t = 4;
pub const x86_activity_t_X86_Activity_MWait: x86_activity_t = 5;
pub const x86_activity_t_X86_Activity_Senter_Sleep_State: x86_activity_t = 6;
pub type x86_activity_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"ymm_reg_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ymm_reg_t {
    pub llo64: uint64,
    pub lhi64: uint64,
    pub hlo64: uint64,
    pub hhi64: uint64,
}
#[test]
fn bindgen_test_layout_ymm_reg_t() {
    const UNINIT: ::std::mem::MaybeUninit<ymm_reg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ymm_reg_t>(),
        32usize,
        concat!("Size of: ", stringify!(ymm_reg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ymm_reg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ymm_reg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).llo64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ymm_reg_t),
            "::",
            stringify!(llo64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lhi64) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ymm_reg_t),
            "::",
            stringify!(lhi64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hlo64) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ymm_reg_t),
            "::",
            stringify!(hlo64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hhi64) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ymm_reg_t),
            "::",
            stringify!(hhi64)
        )
    );
}
#[doc = " <add-type id=\"xmm_reg_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xmm_reg_t {
    pub lo64: uint64,
    pub hi64: uint64,
}
#[test]
fn bindgen_test_layout_xmm_reg_t() {
    const UNINIT: ::std::mem::MaybeUninit<xmm_reg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xmm_reg_t>(),
        16usize,
        concat!("Size of: ", stringify!(xmm_reg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xmm_reg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xmm_reg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xmm_reg_t),
            "::",
            stringify!(lo64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi64) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xmm_reg_t),
            "::",
            stringify!(hi64)
        )
    );
}
pub const x86_exec_mode_t_X86_Exec_Mode_Real: x86_exec_mode_t = 0;
pub const x86_exec_mode_t_X86_Exec_Mode_V86: x86_exec_mode_t = 1;
pub const x86_exec_mode_t_X86_Exec_Mode_Prot: x86_exec_mode_t = 2;
pub const x86_exec_mode_t_X86_Exec_Mode_Compat: x86_exec_mode_t = 3;
pub const x86_exec_mode_t_X86_Exec_Mode_64: x86_exec_mode_t = 4;
#[doc = " <add-type id=\"x86_exec_mode_t\"> </add-type>"]
pub type x86_exec_mode_t = ::std::os::raw::c_uint;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Real_16: x86_detailed_exec_mode_t = 0;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Real_32: x86_detailed_exec_mode_t = 1;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_V86: x86_detailed_exec_mode_t = 2;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Protected_16: x86_detailed_exec_mode_t =
    3;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Protected_32: x86_detailed_exec_mode_t =
    4;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Protected_64: x86_detailed_exec_mode_t =
    5;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Compatibility_16:
    x86_detailed_exec_mode_t = 6;
pub const x86_detailed_exec_mode_t_X86_Detailed_Exec_Mode_Compatibility_32:
    x86_detailed_exec_mode_t = 7;
#[doc = " <add-type id=\"x86_detailed_exec_mode_t\"> </add-type>"]
pub type x86_detailed_exec_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_monitor_info_t {
    pub armed: bool,
    pub address: uint64,
    pub extensions: uint64,
    pub hints: uint64,
}
#[test]
fn bindgen_test_layout_x86_monitor_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_monitor_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_monitor_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(x86_monitor_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_monitor_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_monitor_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).armed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_monitor_info_t),
            "::",
            stringify!(armed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_monitor_info_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_monitor_info_t),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hints) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_monitor_info_t),
            "::",
            stringify!(hints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_mwait_info_t {
    pub extensions: uint64,
    pub hints: uint64,
}
#[test]
fn bindgen_test_layout_x86_mwait_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_mwait_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_mwait_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(x86_mwait_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_mwait_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_mwait_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_mwait_info_t),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hints) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_mwait_info_t),
            "::",
            stringify!(hints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_pending_debug_exc_t {
    pub pending: bool,
    pub pending_dr6: uint64,
}
#[test]
fn bindgen_test_layout_x86_pending_debug_exc_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_pending_debug_exc_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_pending_debug_exc_t>(),
        16usize,
        concat!("Size of: ", stringify!(x86_pending_debug_exc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_pending_debug_exc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_pending_debug_exc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_pending_debug_exc_t),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_dr6) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_pending_debug_exc_t),
            "::",
            stringify!(pending_dr6)
        )
    );
}
#[doc = " <add-type id=\"x86_fpu_reg_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_fpu_reg_t {
    pub low: uint64,
    pub high: uint16,
}
#[test]
fn bindgen_test_layout_x86_fpu_reg_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_fpu_reg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_fpu_reg_t>(),
        16usize,
        concat!("Size of: ", stringify!(x86_fpu_reg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_fpu_reg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_fpu_reg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_reg_t),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_reg_t),
            "::",
            stringify!(high)
        )
    );
}
#[doc = " <add-type id=\"x86_fpu_env_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_fpu_env_t {
    pub cw: uint16,
    pub sw: uint16,
    pub tag: uint16,
    pub opc: uint16,
    pub last_instr_ptr: uint64,
    pub last_operand_ptr: uint64,
    pub last_instr_sel: uint16,
    pub last_operand_sel: uint16,
    pub pad: uint32,
}
#[test]
fn bindgen_test_layout_x86_fpu_env_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_fpu_env_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_fpu_env_t>(),
        32usize,
        concat!("Size of: ", stringify!(x86_fpu_env_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_fpu_env_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_fpu_env_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(cw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opc) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(opc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_instr_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(last_instr_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_operand_ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(last_operand_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_instr_sel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(last_instr_sel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_operand_sel) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(last_operand_sel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_fpu_env_t),
            "::",
            stringify!(pad)
        )
    );
}
pub const x86_seg_t_X86_Seg_ES: x86_seg_t = 0;
pub const x86_seg_t_X86_Seg_CS: x86_seg_t = 1;
pub const x86_seg_t_X86_Seg_SS: x86_seg_t = 2;
pub const x86_seg_t_X86_Seg_DS: x86_seg_t = 3;
pub const x86_seg_t_X86_Seg_FS: x86_seg_t = 4;
pub const x86_seg_t_X86_Seg_GS: x86_seg_t = 5;
pub const x86_seg_t_X86_Seg_LDTR: x86_seg_t = 6;
pub const x86_seg_t_X86_Seg_TR: x86_seg_t = 7;
pub const x86_seg_t_X86_Seg_None: x86_seg_t = 8;
#[doc = " <add-type id=\"x86_seg_t\"> </add-type>"]
pub type x86_seg_t = ::std::os::raw::c_uint;
pub const x86_intstate_t_X86_Intstate_Not_Blocking: x86_intstate_t = 0;
pub const x86_intstate_t_X86_Intstate_Blocking_INT_Sti: x86_intstate_t = 1;
pub const x86_intstate_t_X86_Intstate_Blocking_INT_Mov_Ss: x86_intstate_t = 2;
pub const x86_intstate_t_X86_Intstate_Blocking_INIT: x86_intstate_t = 4;
pub const x86_intstate_t_X86_Intstate_Blocking_SMI: x86_intstate_t = 8;
pub const x86_intstate_t_X86_Intstate_Blocking_NMI: x86_intstate_t = 16;
pub type x86_intstate_t = ::std::os::raw::c_uint;
pub type x86_reg_access_interface_t = x86_reg_access_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_reg_access_interface {
    pub get_gpr: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, index: ::std::os::raw::c_uint) -> uint64,
    >,
    pub set_gpr: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, index: ::std::os::raw::c_uint, val: uint64),
    >,
    pub get_rip: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint64>,
    pub set_rip: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, rip: uint64)>,
    pub get_rflags: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint64>,
    pub set_rflags:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, rflags: uint64)>,
    #[doc = " Possibly faster method for setting only cf,pf,af,zf,sf,of"]
    pub set_status_flags:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, flags: uint16)>,
    #[doc = " Regular segment registers"]
    pub get_seg: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_seg_t) -> x86_seg_reg_t,
    >,
    pub set_seg: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_seg_t, seg: x86_seg_reg_t),
    >,
    #[doc = " IDTR and GDTR"]
    pub get_system_seg: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_system_seg_t) -> x86_system_seg_reg_t,
    >,
    pub set_system_seg: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            n: x86_system_seg_t,
            seg: x86_system_seg_reg_t,
        ),
    >,
    #[doc = " Control registers"]
    pub get_cr:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_cr_t) -> uint64>,
    pub set_cr: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_cr_t, val: uint64),
    >,
    pub get_efer: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint64>,
    pub set_efer:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, efer: uint64)>,
    pub get_xcr: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_xcr_t) -> uint64,
    >,
    pub set_xcr: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_xcr_t, val: uint64),
    >,
    #[doc = " x87 FPU"]
    pub get_freg: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            index: ::std::os::raw::c_uint,
        ) -> x86_fpu_reg_t,
    >,
    pub set_freg: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            index: ::std::os::raw::c_uint,
            freg: x86_fpu_reg_t,
        ),
    >,
    pub get_fpu_env:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_fpu_env_t>,
    pub set_fpu_env:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, state: x86_fpu_env_t)>,
    #[doc = " SIMD"]
    pub get_xmm: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, index: ::std::os::raw::c_uint) -> xmm_reg_t,
    >,
    pub set_xmm: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            index: ::std::os::raw::c_uint,
            val: xmm_reg_t,
        ),
    >,
    pub get_ymm: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, index: ::std::os::raw::c_uint) -> ymm_reg_t,
    >,
    pub set_ymm: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            index: ::std::os::raw::c_uint,
            val: ymm_reg_t,
        ),
    >,
    pub get_mxcsr: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint32>,
    pub set_mxcsr:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, mxcsr: uint32)>,
    #[doc = " Debug registers"]
    pub get_dr:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_dr_t) -> uint64>,
    pub set_dr: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, n: x86_dr_t, val: uint64),
    >,
    #[doc = " SMM"]
    pub get_in_smm: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> bool>,
    pub set_in_smm: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, val: bool)>,
    pub get_smm_base:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint64>,
    pub set_smm_base:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, val: uint64)>,
    #[doc = " Monitor/Mwait"]
    pub get_monitor_info:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_monitor_info_t>,
    pub set_monitor_info: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, val: x86_monitor_info_t),
    >,
    pub get_mwait_info:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_mwait_info_t>,
    pub set_mwait_info:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, val: x86_mwait_info_t)>,
    #[doc = " Non-register state"]
    pub get_activity_state:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_activity_t>,
    pub set_activity_state:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, val: x86_activity_t)>,
    pub get_interruptibility_state:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_intstate_t>,
    pub set_interruptibility_state:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, val: x86_intstate_t)>,
    #[doc = " A debug exception is pending if triggered by the last instruction,\nbut not yet taken."]
    pub get_pending_debug_exc: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_pending_debug_exc_t,
    >,
    pub set_pending_debug_exc: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, val: x86_pending_debug_exc_t),
    >,
    #[doc = " Derived state for fast/easy access"]
    pub get_xmode_info:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_xmode_info_t>,
    pub get_exec_mode:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> x86_exec_mode_t>,
    #[doc = " This is configuration info. No need for a set method."]
    pub get_mxcsr_mask:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint32>,
    #[doc = " Extension state dirty bit modification (for XSAVE)"]
    pub get_ext_state_dirty_bits:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> uint64>,
    pub or_ext_state_dirty_bits:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, dirty_bits: uint64)>,
    pub and_ext_state_dirty_bits:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, dirty_bits: uint64)>,
    #[doc = " PDPTE registers used in PAE paging mode"]
    pub get_pdpte: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, num: ::std::os::raw::c_int) -> uint64,
    >,
    pub set_pdpte: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, num: ::std::os::raw::c_int, val: uint64),
    >,
}
#[test]
fn bindgen_test_layout_x86_reg_access_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_reg_access_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_reg_access_interface>(),
        408usize,
        concat!("Size of: ", stringify!(x86_reg_access_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_reg_access_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_reg_access_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_gpr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_gpr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_gpr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_gpr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_rip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_rip) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_rflags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_rflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_rflags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_rflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_status_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_status_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_seg) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_seg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_seg) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_seg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_system_seg) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_system_seg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_system_seg) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_system_seg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cr) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_cr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cr) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_cr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_efer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_efer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_efer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_efer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_xcr) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_xcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_xcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_xcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_freg) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_freg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_freg) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_freg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_fpu_env) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_fpu_env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_fpu_env) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_fpu_env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_xmm) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_xmm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_xmm) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_xmm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_ymm) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_ymm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_ymm) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_ymm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mxcsr) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_mxcsr) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_dr) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_dr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_dr) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_dr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_in_smm) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_in_smm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_in_smm) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_in_smm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_smm_base) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_smm_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_smm_base) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_smm_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_monitor_info) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_monitor_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_monitor_info) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_monitor_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mwait_info) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_mwait_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_mwait_info) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_mwait_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_activity_state) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_activity_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_activity_state) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_activity_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interruptibility_state) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_interruptibility_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_interruptibility_state) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_interruptibility_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_pending_debug_exc) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_pending_debug_exc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_pending_debug_exc) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_pending_debug_exc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_xmode_info) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_xmode_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_exec_mode) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_exec_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mxcsr_mask) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_ext_state_dirty_bits) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_ext_state_dirty_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).or_ext_state_dirty_bits) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(or_ext_state_dirty_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).and_ext_state_dirty_bits) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(and_ext_state_dirty_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_pdpte) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(get_pdpte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_pdpte) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_reg_access_interface),
            "::",
            stringify!(set_pdpte)
        )
    );
}
pub type x86_exception_interface_t = x86_exception_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_exception_interface {
    pub DE_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub BR_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub UD_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub NM_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub DF_abort: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, desc: *const ::std::os::raw::c_char),
    >,
    pub TS_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, sel: uint16)>,
    pub NP_fault: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, sel_vec: uint16, is_vec: bool),
    >,
    pub SS_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, sel: uint16)>,
    pub GP_fault: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            sel_vec: uint16,
            is_vec: bool,
            desc: *const ::std::os::raw::c_char,
        ),
    >,
    pub PF_fault: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, laddr: linear_address_t, ecode: uint32),
    >,
    pub MF_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub AC_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub XM_fault: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_x86_exception_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_exception_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_exception_interface>(),
        104usize,
        concat!("Size of: ", stringify!(x86_exception_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_exception_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_exception_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DE_fault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(DE_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BR_fault) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(BR_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UD_fault) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(UD_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NM_fault) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(NM_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DF_abort) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(DF_abort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TS_fault) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(TS_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NP_fault) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(NP_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SS_fault) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(SS_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GP_fault) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(GP_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PF_fault) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(PF_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MF_fault) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(MF_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AC_fault) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(AC_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XM_fault) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_interface),
            "::",
            stringify!(XM_fault)
        )
    );
}
pub const x86_exception_source_t_X86_Exc_Hardware: x86_exception_source_t = 0;
pub const x86_exception_source_t_X86_Exc_Software: x86_exception_source_t = 1;
pub const x86_exception_source_t_X86_Exc_External: x86_exception_source_t = 2;
pub const x86_exception_source_t_X86_Exc_Software_Debug: x86_exception_source_t = 3;
pub const x86_exception_source_t_X86_Exc_Software_Priv: x86_exception_source_t = 4;
pub const x86_exception_source_t_X86_Exc_Triple_Fault: x86_exception_source_t = 5;
pub const x86_exception_source_t_X86_Exc_NMI: x86_exception_source_t = 6;
pub const x86_exception_source_t_X86_Exc_Other_Event: x86_exception_source_t = 7;
#[doc = " <add-type id=\"x86_exception_source\">\nDefines different exception sources for a given exception/interrupt.\n</add-type>"]
pub type x86_exception_source_t = ::std::os::raw::c_uint;
pub const x86_processor_mode_t_X86_Processor_Mode_Privileged: x86_processor_mode_t = 0;
pub const x86_processor_mode_t_X86_Processor_Mode_User: x86_processor_mode_t = 1;
pub const x86_processor_mode_t_X86_Processor_Mode_Current: x86_processor_mode_t = 2;
#[doc = " <add-type id=\"x86_processor_mode_t\"> </add-type>"]
pub type x86_processor_mode_t = ::std::os::raw::c_uint;
pub const x86_alignment_t_X86_Alignment_Not_Required: x86_alignment_t = 0;
pub const x86_alignment_t_X86_Alignment_Required: x86_alignment_t = 1;
#[doc = " <add-type id=\"x86_alignment_t\"> </add-type>"]
pub type x86_alignment_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"x86_read_physical_ret_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_read_physical_ret_t {
    pub value: uint64,
    pub exception: exception_type_t,
}
#[test]
fn bindgen_test_layout_x86_read_physical_ret_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_read_physical_ret_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_read_physical_ret_t>(),
        16usize,
        concat!("Size of: ", stringify!(x86_read_physical_ret_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_read_physical_ret_t>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_read_physical_ret_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_read_physical_ret_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_read_physical_ret_t),
            "::",
            stringify!(exception)
        )
    );
}
impl Default for x86_read_physical_ret_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type x86_memory_access_interface_t = x86_memory_access_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_memory_access_interface {
    pub read_logical: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            offs: logical_address_t,
            seg: x86_seg_t,
            len: ::std::os::raw::c_uint,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
        ) -> uint64,
    >,
    pub read_logical_buf: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            offs: logical_address_t,
            seg: x86_seg_t,
            len: ::std::os::raw::c_uint,
            p: *mut ::std::os::raw::c_void,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
            alignment: x86_alignment_t,
        ),
    >,
    pub write_logical: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            offs: logical_address_t,
            seg: x86_seg_t,
            len: ::std::os::raw::c_uint,
            val: uint64,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
        ),
    >,
    pub write_logical_buf: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            offs: logical_address_t,
            seg: x86_seg_t,
            len: ::std::os::raw::c_uint,
            p: *const ::std::os::raw::c_void,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
            alignment: x86_alignment_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_x86_memory_access_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_memory_access_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_memory_access_interface>(),
        32usize,
        concat!("Size of: ", stringify!(x86_memory_access_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_memory_access_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_memory_access_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_logical) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_access_interface),
            "::",
            stringify!(read_logical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_logical_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_access_interface),
            "::",
            stringify!(read_logical_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_logical) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_access_interface),
            "::",
            stringify!(write_logical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_logical_buf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_access_interface),
            "::",
            stringify!(write_logical_buf)
        )
    );
}
pub type x86_memory_operation_interface_t = x86_memory_operation_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_memory_operation_interface {
    pub read_logical: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            seg: x86_seg_t,
            offs: logical_address_t,
            size: ::std::os::raw::c_uint,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
        ) -> uint64,
    >,
    pub read_logical_buf: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            dst: *mut uint8,
            seg: x86_seg_t,
            offs: logical_address_t,
            size: ::std::os::raw::c_uint,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
        ),
    >,
    pub write_logical: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            val: uint64,
            seg: x86_seg_t,
            offs: logical_address_t,
            size: ::std::os::raw::c_uint,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
        ),
    >,
    pub write_logical_buf: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            src: *const uint8,
            seg: x86_seg_t,
            offs: logical_address_t,
            size: ::std::os::raw::c_uint,
            mode: x86_processor_mode_t,
            access_type: x86_access_type_t,
        ),
    >,
    pub read_physical: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            address: physical_address_t,
            size: ::std::os::raw::c_uint,
            access_type: x86_access_type_t,
        ) -> x86_read_physical_ret_t,
    >,
    pub read_physical_buf: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            dst: *mut uint8,
            address: physical_address_t,
            size: ::std::os::raw::c_uint,
            access_type: x86_access_type_t,
        ) -> exception_type_t,
    >,
    pub write_physical: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            val: uint64,
            address: physical_address_t,
            size: ::std::os::raw::c_uint,
            access_type: x86_access_type_t,
        ) -> exception_type_t,
    >,
    pub write_physical_buf: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            src: *const uint8,
            address: physical_address_t,
            size: ::std::os::raw::c_uint,
            access_type: x86_access_type_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_memory_operation_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_memory_operation_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_memory_operation_interface>(),
        64usize,
        concat!("Size of: ", stringify!(x86_memory_operation_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_memory_operation_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_memory_operation_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_logical) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(read_logical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_logical_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(read_logical_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_logical) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(write_logical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_logical_buf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(write_logical_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_physical) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(read_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_physical_buf) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(read_physical_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_physical) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(write_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_physical_buf) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_operation_interface),
            "::",
            stringify!(write_physical_buf)
        )
    );
}
pub type x86_vmp_control_interface_t = x86_vmp_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_vmp_control_interface {
    pub get_block_count: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t) -> ::std::os::raw::c_uint,
    >,
    pub set_block_count: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, cnt: ::std::os::raw::c_uint),
    >,
}
#[test]
fn bindgen_test_layout_x86_vmp_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_vmp_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_vmp_control_interface>(),
        16usize,
        concat!("Size of: ", stringify!(x86_vmp_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_vmp_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_vmp_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_block_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_vmp_control_interface),
            "::",
            stringify!(get_block_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_block_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_vmp_control_interface),
            "::",
            stringify!(set_block_count)
        )
    );
}
pub const vmp_feature_t_Vmp_Feature_Ept: vmp_feature_t = 0;
pub const vmp_feature_t_Vmp_Feature_Tpr_Threshold: vmp_feature_t = 1;
pub const vmp_feature_t_Vmp_Feature_Unrestricted_Guest: vmp_feature_t = 2;
pub const vmp_feature_t_Vmp_Feature_Backoff: vmp_feature_t = 3;
pub const vmp_feature_t_Vmp_Feature_Shadow_VMCS: vmp_feature_t = 4;
pub const vmp_feature_t_Vmp_Feature_Nested_EPT: vmp_feature_t = 5;
pub const vmp_feature_t_Vmp_Feature_Direct_Rdtsc: vmp_feature_t = 6;
#[doc = " ADD INTERFACE x86_vmp_control_interface"]
pub type vmp_feature_t = ::std::os::raw::c_uint;
pub const vmp_info_t_Vmp_Info_Cpu_Version: vmp_info_t = 0;
pub const vmp_info_t_Vmp_Info_Vmxmon_Version: vmp_info_t = 1;
pub type vmp_info_t = ::std::os::raw::c_uint;
pub type vmp_interface_t = vmp_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vmp_interface {
    pub class_has_support:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub host_support: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub compatible_config:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub enable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub disable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub enabled: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub set_threshold: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, threshold: ::std::os::raw::c_int),
    >,
    pub get_feature: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, feature: vmp_feature_t) -> bool,
    >,
    pub set_feature: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, feature: vmp_feature_t, val: bool) -> bool,
    >,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, info: vmp_info_t) -> uint64,
    >,
}
#[test]
fn bindgen_test_layout_vmp_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vmp_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmp_interface>(),
        80usize,
        concat!("Size of: ", stringify!(vmp_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vmp_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vmp_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_has_support) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(class_has_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_support) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(host_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compatible_config) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(compatible_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_threshold) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(set_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_feature) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(get_feature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_feature) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(set_feature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vmp_interface),
            "::",
            stringify!(get_info)
        )
    );
}
pub const xed_data_type_t_Xed_Iform: xed_data_type_t = 0;
#[doc = " ADD INTERFACE vmp_interface"]
pub type xed_data_type_t = ::std::os::raw::c_uint;
pub type xed_access_interface_t = xed_access_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xed_access_interface {
    pub get_last: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            type_: xed_data_type_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            type_: xed_data_type_t,
            bytes: bytes_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub to_string: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            type_: xed_data_type_t,
            value: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_xed_access_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xed_access_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xed_access_interface>(),
        24usize,
        concat!("Size of: ", stringify!(xed_access_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xed_access_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xed_access_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_last) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xed_access_interface),
            "::",
            stringify!(get_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xed_access_interface),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_string) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xed_access_interface),
            "::",
            stringify!(to_string)
        )
    );
}
pub type x86_ept_interface_t = x86_ept_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_ept_interface {
    pub guest_physical_to_physical: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            address: generic_address_t,
            cpu_mode: x86_processor_mode_t,
            access: access_t,
        ) -> physical_block_t,
    >,
    pub is_ept_active: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
}
#[test]
fn bindgen_test_layout_x86_ept_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_ept_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_ept_interface>(),
        16usize,
        concat!("Size of: ", stringify!(x86_ept_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_ept_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_ept_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guest_physical_to_physical) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_ept_interface),
            "::",
            stringify!(guest_physical_to_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_ept_active) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_ept_interface),
            "::",
            stringify!(is_ept_active)
        )
    );
}
pub const ppc_mc_exc_t_Sim_PPC_Generic_MC: ppc_mc_exc_t = 0;
pub const ppc_mc_exc_t_Sim_PPC_MC_TEA: ppc_mc_exc_t = 1;
pub const ppc_mc_exc_t_Sim_PPC_MC_MCP: ppc_mc_exc_t = 2;
pub const ppc_mc_exc_t_Sim_PPC_Bus_Address_Parity: ppc_mc_exc_t = 3;
pub const ppc_mc_exc_t_Sim_PPC_Bus_Data_Parity: ppc_mc_exc_t = 4;
pub const ppc_mc_exc_t_Sim_PPC_Instruction_Cache_Parity: ppc_mc_exc_t = 5;
pub const ppc_mc_exc_t_Sim_PPC_Data_Cache_Parity: ppc_mc_exc_t = 6;
pub const ppc_mc_exc_t_Sim_PPC_L2_Data_Parity: ppc_mc_exc_t = 7;
pub const ppc_mc_exc_t_Sim_PPC_L3_Data_Parity: ppc_mc_exc_t = 8;
pub const ppc_mc_exc_t_Sim_PPC_L3_Address_Parity: ppc_mc_exc_t = 9;
pub const ppc_mc_exc_t_Sim_PPC970_Data_Cache_Parity: ppc_mc_exc_t = 10;
pub const ppc_mc_exc_t_Sim_PPC970_Data_Cache_Tag_Parity: ppc_mc_exc_t = 11;
pub const ppc_mc_exc_t_Sim_PPC970_D_ERAT_Parity: ppc_mc_exc_t = 12;
pub const ppc_mc_exc_t_Sim_PPC970_TLB_Parity: ppc_mc_exc_t = 13;
pub const ppc_mc_exc_t_Sim_PPC970_SLB_Parity: ppc_mc_exc_t = 14;
pub const ppc_mc_exc_t_Sim_PPC970_L2_Load_ECC_Parity: ppc_mc_exc_t = 15;
pub const ppc_mc_exc_t_Sim_PPC970_L2_Page_Table_ECC_Parity: ppc_mc_exc_t = 16;
pub const ppc_mc_exc_t_Sim_PPC970_Uncacheable_Load_Parity: ppc_mc_exc_t = 17;
pub const ppc_mc_exc_t_Sim_PPC970_MC_External: ppc_mc_exc_t = 18;
#[doc = " <add-type id=\"ppc_mc_exc_t type\"><ndx>ppc_mc_exc_t</ndx></add-type>"]
pub type ppc_mc_exc_t = ::std::os::raw::c_uint;
#[doc = " Normal load or store instructions"]
pub const ppc_mem_instr_origin_t_Normal_Load_Store: ppc_mem_instr_origin_t = 0;
#[doc = " No data touched by the load/store will be placed in cache"]
pub const ppc_mem_instr_origin_t_Caching_Inhibited: ppc_mem_instr_origin_t = 1;
#[doc = " load/store multiple"]
pub const ppc_mem_instr_origin_t_Instr_Multiple: ppc_mem_instr_origin_t = 2;
#[doc = " load/store string"]
pub const ppc_mem_instr_origin_t_Instr_String: ppc_mem_instr_origin_t = 3;
#[doc = " Altivec load/store element"]
pub const ppc_mem_instr_origin_t_Instr_Altivec_Element: ppc_mem_instr_origin_t = 4;
#[doc = " data cache block touch"]
pub const ppc_mem_instr_origin_t_Instr_dcbt: ppc_mem_instr_origin_t = 5;
#[doc = " data cache block store"]
pub const ppc_mem_instr_origin_t_Instr_dcbst: ppc_mem_instr_origin_t = 6;
#[doc = " data cache block touch for store"]
pub const ppc_mem_instr_origin_t_Instr_dcbtst: ppc_mem_instr_origin_t = 7;
#[doc = " data cache block invalidate"]
pub const ppc_mem_instr_origin_t_Instr_dcbi: ppc_mem_instr_origin_t = 8;
#[doc = " data cache block flush"]
pub const ppc_mem_instr_origin_t_Instr_dcbf: ppc_mem_instr_origin_t = 9;
#[doc = " data cache block flush local"]
pub const ppc_mem_instr_origin_t_Instr_dcbfl: ppc_mem_instr_origin_t = 10;
#[doc = " data cache block allocate"]
pub const ppc_mem_instr_origin_t_Instr_dcba: ppc_mem_instr_origin_t = 11;
#[doc = " data cache block to zero"]
pub const ppc_mem_instr_origin_t_Instr_dcbz: ppc_mem_instr_origin_t = 12;
#[doc = " instruction cache block invalidate"]
pub const ppc_mem_instr_origin_t_Instr_icbi: ppc_mem_instr_origin_t = 13;
#[doc = " data stream touch"]
pub const ppc_mem_instr_origin_t_Instr_dst: ppc_mem_instr_origin_t = 14;
#[doc = " data stream touch transient"]
pub const ppc_mem_instr_origin_t_Instr_dstt: ppc_mem_instr_origin_t = 15;
#[doc = " data stream touch for store"]
pub const ppc_mem_instr_origin_t_Instr_dstst: ppc_mem_instr_origin_t = 16;
#[doc = " data stream touch for store transient"]
pub const ppc_mem_instr_origin_t_Instr_dststt: ppc_mem_instr_origin_t = 17;
#[doc = " data cache block lock clear (L1)"]
pub const ppc_mem_instr_origin_t_Instr_dcblc_l1: ppc_mem_instr_origin_t = 18;
#[doc = " data cache block lock clear (L2)"]
pub const ppc_mem_instr_origin_t_Instr_dcblc_l2: ppc_mem_instr_origin_t = 19;
#[doc = " data cache block touch and lock set (L1)"]
pub const ppc_mem_instr_origin_t_Instr_dcbtls_l1: ppc_mem_instr_origin_t = 20;
#[doc = " data cache block touch and lock set (L1)"]
pub const ppc_mem_instr_origin_t_Instr_dcbtls_l2: ppc_mem_instr_origin_t = 21;
#[doc = " data cache block touch for store and lock\nset (L1)"]
pub const ppc_mem_instr_origin_t_Instr_dcbtstls_l1: ppc_mem_instr_origin_t = 22;
#[doc = " data cache block touch for store and lock\nset (L1)"]
pub const ppc_mem_instr_origin_t_Instr_dcbtstls_l2: ppc_mem_instr_origin_t = 23;
#[doc = " instruction cache block clear (L1)"]
pub const ppc_mem_instr_origin_t_Instr_icblc_l1: ppc_mem_instr_origin_t = 24;
#[doc = " instruction cache block clear (L2)"]
pub const ppc_mem_instr_origin_t_Instr_icblc_l2: ppc_mem_instr_origin_t = 25;
#[doc = " instruction cache block touch and lock\nset (L1)"]
pub const ppc_mem_instr_origin_t_Instr_icbtls_l1: ppc_mem_instr_origin_t = 26;
#[doc = " instruction cache block touch and lock\nset (L1)"]
pub const ppc_mem_instr_origin_t_Instr_icbtls_l2: ppc_mem_instr_origin_t = 27;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_lwarx: ppc_mem_instr_origin_t = 28;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_stwcx: ppc_mem_instr_origin_t = 29;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_ldarx: ppc_mem_instr_origin_t = 30;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_stdcx: ppc_mem_instr_origin_t = 31;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_lq: ppc_mem_instr_origin_t = 32;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_stq: ppc_mem_instr_origin_t = 33;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_sync: ppc_mem_instr_origin_t = 34;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_eieio: ppc_mem_instr_origin_t = 35;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_ecowx: ppc_mem_instr_origin_t = 36;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_eciwx: ppc_mem_instr_origin_t = 37;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_tlbie: ppc_mem_instr_origin_t = 38;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_tlbsync: ppc_mem_instr_origin_t = 39;
#[doc = " Other cache affecting instructions"]
pub const ppc_mem_instr_origin_t_Instr_isync: ppc_mem_instr_origin_t = 40;
#[doc = " Load Floating point Double Pair"]
pub const ppc_mem_instr_origin_t_Instr_lfdp: ppc_mem_instr_origin_t = 41;
#[doc = " Store Floating point Double Pair"]
pub const ppc_mem_instr_origin_t_Instr_stfdp: ppc_mem_instr_origin_t = 42;
pub const ppc_mem_instr_origin_t_Instr_spe: ppc_mem_instr_origin_t = 43;
#[doc = " Obsolete - use Instr_dcba."]
pub const ppc_mem_instr_origin_t_Instr_dcbal: ppc_mem_instr_origin_t = 44;
#[doc = " data cache block lock clear"]
pub const ppc_mem_instr_origin_t_Instr_dcblc_pc: ppc_mem_instr_origin_t = 45;
#[doc = " data cache block touch and lock set"]
pub const ppc_mem_instr_origin_t_Instr_dcbtls_pc: ppc_mem_instr_origin_t = 46;
#[doc = " data cache block touch for store and lock\nset"]
pub const ppc_mem_instr_origin_t_Instr_dcbtstls_pc: ppc_mem_instr_origin_t = 47;
#[doc = " instruction cache block clear"]
pub const ppc_mem_instr_origin_t_Instr_icblc_pc: ppc_mem_instr_origin_t = 48;
#[doc = " instruction cache block touch and lock\nset"]
pub const ppc_mem_instr_origin_t_Instr_icbtls_pc: ppc_mem_instr_origin_t = 49;
#[doc = " Load/store from FPU unit"]
pub const ppc_mem_instr_origin_t_Instr_Fpu: ppc_mem_instr_origin_t = 50;
#[doc = " <add-type id=\"ppc_mem_instr_origin_t def\"></add-type>"]
pub type ppc_mem_instr_origin_t = ::std::os::raw::c_uint;
pub const ppc_decoration_type_t_Decoration_None: ppc_decoration_type_t = 0;
pub const ppc_decoration_type_t_Decoration_Notify: ppc_decoration_type_t = 1;
pub const ppc_decoration_type_t_Decoration_Load: ppc_decoration_type_t = 2;
pub const ppc_decoration_type_t_Decoration_Store: ppc_decoration_type_t = 3;
#[doc = " <add-type id=\"ppc_decoration_type_t def\"></add-type>"]
pub type ppc_decoration_type_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"ppc_decoration_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ppc_decoration_t {
    pub type_: ppc_decoration_type_t,
    pub data: uint64,
}
#[test]
fn bindgen_test_layout_ppc_decoration_t() {
    const UNINIT: ::std::mem::MaybeUninit<ppc_decoration_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ppc_decoration_t>(),
        16usize,
        concat!("Size of: ", stringify!(ppc_decoration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ppc_decoration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ppc_decoration_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_decoration_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_decoration_t),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ppc_decoration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"ppc_memory_transaction_t def\">\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ppc_memory_transaction {
    #[doc = " generic transaction"]
    pub s: generic_transaction_t,
    pub mode: processor_mode_t,
    pub instr_origin: ppc_mem_instr_origin_t,
    pub ea_origin: logical_address_t,
    pub wimg: uint8,
    pub alignment: uint8,
    #[doc = " cache operations may flag this to cause prefetches to be no-ops"]
    pub inhibit_exception: uint8,
    #[doc = " External PID"]
    pub external_pid: uint8,
    #[doc = " Decorated storage"]
    pub decoration: ppc_decoration_t,
}
#[test]
fn bindgen_test_layout_ppc_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<ppc_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ppc_memory_transaction>(),
        144usize,
        concat!("Size of: ", stringify!(ppc_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<ppc_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(ppc_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instr_origin) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(instr_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ea_origin) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(ea_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wimg) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(wimg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inhibit_exception) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(inhibit_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).external_pid) as usize - ptr as usize },
        123usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(external_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoration) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_memory_transaction),
            "::",
            stringify!(decoration)
        )
    );
}
impl Default for ppc_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"ppc_memory_transaction_t def\">\n</add-type>"]
pub type ppc_memory_transaction_t = ppc_memory_transaction;
extern "C" {
    pub fn SIM_ppc_mem_trans_from_generic(
        mop: *mut generic_transaction_t,
    ) -> *mut ppc_memory_transaction_t;
}
#[doc = " Not sleeping at all, this is the normal mode"]
pub const ppc_sleep_state_t_PPC_Sleep_Awake: ppc_sleep_state_t = 0;
#[doc = " Old version of power saving, the only level"]
pub const ppc_sleep_state_t_PPC_Sleep_MSR: ppc_sleep_state_t = 1;
#[doc = " Lowest level of power saving in new version"]
pub const ppc_sleep_state_t_PPC_Sleep_Doze: ppc_sleep_state_t = 2;
pub const ppc_sleep_state_t_PPC_Sleep_Nap: ppc_sleep_state_t = 3;
pub const ppc_sleep_state_t_PPC_Sleep_Sleep: ppc_sleep_state_t = 4;
#[doc = " Highest level"]
pub const ppc_sleep_state_t_PPC_Sleep_Rvwinkle: ppc_sleep_state_t = 5;
#[doc = " Wait instruction"]
pub const ppc_sleep_state_t_PPC_Sleep_Wait: ppc_sleep_state_t = 6;
#[doc = " Wait reservation"]
pub const ppc_sleep_state_t_PPC_Sleep_Waitrsv: ppc_sleep_state_t = 7;
pub type ppc_sleep_state_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"ppc_spr_user_setter_func_t def\"></add-type>"]
pub type ppc_spr_user_setter_func_t = gen_spr_user_setter_func_t;
#[doc = " <add-type id=\"ppc_spr_user_getter_func_t def\"></add-type>"]
pub type ppc_spr_user_getter_func_t = gen_spr_user_getter_func_t;
#[doc = " <add-type id=\"ppc_spr_access_type_t def\"></add-type>"]
pub use self::gen_spr_access_type_t as ppc_spr_access_type_t;
#[doc = " <add-type id=\"ppc_spr_ret_t def\"></add-type>"]
pub use self::gen_spr_ret_t as ppc_spr_ret_t;
pub type ppc_interface_t = ppc_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ppc_interface {
    pub clear_atomic_reservation_bit:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub raise_machine_check_exception:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, exc: ppc_mc_exc_t)>,
    #[doc = " Timebase"]
    pub get_timebase_enabled: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t) -> ::std::os::raw::c_uint,
    >,
    pub set_timebase_enabled: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, enabled: ::std::os::raw::c_uint),
    >,
    #[doc = " Power mode"]
    pub get_sleep_state:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t) -> ppc_sleep_state_t>,
    pub set_sleep_state: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, state: ppc_sleep_state_t),
    >,
}
#[test]
fn bindgen_test_layout_ppc_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ppc_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ppc_interface>(),
        48usize,
        concat!("Size of: ", stringify!(ppc_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ppc_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ppc_interface))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).clear_atomic_reservation_bit) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_interface),
            "::",
            stringify!(clear_atomic_reservation_bit)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).raise_machine_check_exception) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_interface),
            "::",
            stringify!(raise_machine_check_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_timebase_enabled) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_interface),
            "::",
            stringify!(get_timebase_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_timebase_enabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_interface),
            "::",
            stringify!(set_timebase_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sleep_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_interface),
            "::",
            stringify!(get_sleep_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_sleep_state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_interface),
            "::",
            stringify!(set_sleep_state)
        )
    );
}
pub type spr_interface_t = spr_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct spr_interface {
    pub register_user_handlers: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            spr_number: int64,
            getter: gen_spr_user_getter_func_t,
            user_getter_data: *mut lang_void,
            setter: gen_spr_user_setter_func_t,
            user_setter_data: *mut lang_void,
            privilege_checks: ::std::os::raw::c_int,
        ),
    >,
    pub unregister_user_handlers:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, spr_number: int64)>,
    pub set_target_value:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t, value: uint64)>,
    pub stash_value: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, spr_number: int64, value: uint64),
    >,
    pub fetch_value: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, spr_number: int64) -> uint64,
    >,
    pub default_getter: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            spr_number: int64,
            type_: gen_spr_access_type_t,
        ) -> gen_spr_ret_t,
    >,
    pub default_setter: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            spr_number: int64,
            value: uint64,
            type_: gen_spr_access_type_t,
        ) -> gen_spr_ret_t,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            spr_number: int64,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_number: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            spr_name: *const ::std::os::raw::c_char,
        ) -> int64,
    >,
}
#[test]
fn bindgen_test_layout_spr_interface() {
    const UNINIT: ::std::mem::MaybeUninit<spr_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spr_interface>(),
        72usize,
        concat!("Size of: ", stringify!(spr_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<spr_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(spr_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_user_handlers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(register_user_handlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_user_handlers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(unregister_user_handlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_target_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(set_target_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stash_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(stash_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetch_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(fetch_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_getter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(default_getter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_setter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(default_setter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_number) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spr_interface),
            "::",
            stringify!(get_number)
        )
    );
}
pub type pmr_interface_t = pmr_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pmr_interface {
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pmr_number: ::std::os::raw::c_int,
            instruction_read: bool,
        ) -> uint64,
    >,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pmr_number: ::std::os::raw::c_int,
            value: uint64,
            instruction_write: bool,
        ),
    >,
}
#[test]
fn bindgen_test_layout_pmr_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pmr_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pmr_interface>(),
        16usize,
        concat!("Size of: ", stringify!(pmr_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pmr_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pmr_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmr_interface),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pmr_interface),
            "::",
            stringify!(set)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct controllable_cache_t {
    pub obj: *mut conf_object_t,
    pub ifc: *const cache_control_interface_t,
}
#[test]
fn bindgen_test_layout_controllable_cache_t() {
    const UNINIT: ::std::mem::MaybeUninit<controllable_cache_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<controllable_cache_t>(),
        16usize,
        concat!("Size of: ", stringify!(controllable_cache_t))
    );
    assert_eq!(
        ::std::mem::align_of::<controllable_cache_t>(),
        8usize,
        concat!("Alignment of ", stringify!(controllable_cache_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(controllable_cache_t),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(controllable_cache_t),
            "::",
            stringify!(ifc)
        )
    );
}
impl Default for controllable_cache_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const riscv_cpu_mode_t_Riscv_Mode_User: riscv_cpu_mode_t = 0;
pub const riscv_cpu_mode_t_Riscv_Mode_Supervisor: riscv_cpu_mode_t = 1;
pub const riscv_cpu_mode_t_Riscv_Mode_Reserved: riscv_cpu_mode_t = 2;
pub const riscv_cpu_mode_t_Riscv_Mode_Machine: riscv_cpu_mode_t = 3;
#[doc = " <add-type id=\"riscv_cpu_mode_t def\"></add-type>"]
pub type riscv_cpu_mode_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"riscv_memory_transaction_t DOC\">\n<ndx>riscv_memory_transaction_t</ndx>\n<name index=\"true\">riscv_memory_transaction_t</name>\n<doc>\n<doc-item name=\"NAME\">riscv_memory_transaction_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"riscv_memory_transaction_t def\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThis is the RISC-V specific memory transaction data structure.\n\nThe <i>s</i> field contains generic information about memory operations\n(see <tt>generic_transaction_t</tt>).\n\nThe generic data is stored in the <var>s</var> field.\n\nThe <var>mode</var> field specifies the processor mode the MMU should assume\nwhen processing the transaction.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"riscv_memory_transaction_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct riscv_memory_transaction {
    #[doc = " generic transaction"]
    pub s: generic_transaction_t,
    pub mode: riscv_cpu_mode_t,
}
#[test]
fn bindgen_test_layout_riscv_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<riscv_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<riscv_memory_transaction>(),
        112usize,
        concat!("Size of: ", stringify!(riscv_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<riscv_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(riscv_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_memory_transaction),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_memory_transaction),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for riscv_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"riscv_memory_transaction_t DOC\">\n<ndx>riscv_memory_transaction_t</ndx>\n<name index=\"true\">riscv_memory_transaction_t</name>\n<doc>\n<doc-item name=\"NAME\">riscv_memory_transaction_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"riscv_memory_transaction_t def\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThis is the RISC-V specific memory transaction data structure.\n\nThe <i>s</i> field contains generic information about memory operations\n(see <tt>generic_transaction_t</tt>).\n\nThe generic data is stored in the <var>s</var> field.\n\nThe <var>mode</var> field specifies the processor mode the MMU should assume\nwhen processing the transaction.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"riscv_memory_transaction_t def\"></add-type>"]
pub type riscv_memory_transaction_t = riscv_memory_transaction;
pub type riscv_coprocessor_interface_t = riscv_coprocessor_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct riscv_coprocessor_interface {
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, number: uint64) -> uint64,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, number: uint64, value: uint64),
    >,
}
#[test]
fn bindgen_test_layout_riscv_coprocessor_interface() {
    const UNINIT: ::std::mem::MaybeUninit<riscv_coprocessor_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<riscv_coprocessor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(riscv_coprocessor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<riscv_coprocessor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(riscv_coprocessor_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_coprocessor_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_coprocessor_interface),
            "::",
            stringify!(write_register)
        )
    );
}
pub const riscv_vectoring_mode_t_Riscv_Non_Vectoring: riscv_vectoring_mode_t = 0;
pub const riscv_vectoring_mode_t_Riscv_Selective_Hardware_Vectoring: riscv_vectoring_mode_t = 1;
#[doc = " ADD INTERFACE riscv_coprocessor_interface"]
pub type riscv_vectoring_mode_t = ::std::os::raw::c_uint;
pub type riscv_clic_interrupt_interface_t = riscv_clic_interrupt_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct riscv_clic_interrupt_interface {
    pub set_active_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            id: uint64,
            level: uint64,
            vect_mode: riscv_vectoring_mode_t,
            cpu_mode: riscv_cpu_mode_t,
        ),
    >,
    pub clear_interrupt: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_riscv_clic_interrupt_interface() {
    const UNINIT: ::std::mem::MaybeUninit<riscv_clic_interrupt_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<riscv_clic_interrupt_interface>(),
        16usize,
        concat!("Size of: ", stringify!(riscv_clic_interrupt_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<riscv_clic_interrupt_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(riscv_clic_interrupt_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_active_interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_clic_interrupt_interface),
            "::",
            stringify!(set_active_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_interrupt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_clic_interrupt_interface),
            "::",
            stringify!(clear_interrupt)
        )
    );
}
pub type riscv_clic_interface_t = riscv_clic_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct riscv_clic_interface {
    pub acknowledge_interrupt:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, id: uint64)>,
}
#[test]
fn bindgen_test_layout_riscv_clic_interface() {
    const UNINIT: ::std::mem::MaybeUninit<riscv_clic_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<riscv_clic_interface>(),
        8usize,
        concat!("Size of: ", stringify!(riscv_clic_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<riscv_clic_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(riscv_clic_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledge_interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(riscv_clic_interface),
            "::",
            stringify!(acknowledge_interrupt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_riscv_wg_wid {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_riscv_wg_wid() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_riscv_wg_wid> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_riscv_wg_wid>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_riscv_wg_wid))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_riscv_wg_wid>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_riscv_wg_wid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_riscv_wg_wid),
            "::",
            stringify!(dummy)
        )
    );
}
pub type x86_instruction_query_interface_t = x86_instruction_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_instruction_query_interface {
    pub linear_address: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut instruction_handle_t,
        ) -> linear_address_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_instruction_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_instruction_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_instruction_query_interface>(),
        8usize,
        concat!("Size of: ", stringify!(x86_instruction_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_instruction_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_instruction_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_instruction_query_interface),
            "::",
            stringify!(linear_address)
        )
    );
}
pub type x86_memory_query_interface_t = x86_memory_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_memory_query_interface {
    pub linear_address: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut memory_handle_t,
        ) -> linear_address_t,
    >,
    pub segment: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut memory_handle_t) -> x86_seg_t,
    >,
    pub access_type: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: *mut memory_handle_t,
        ) -> x86_access_type_t,
    >,
    pub memory_type: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: *mut memory_handle_t,
        ) -> x86_memory_type_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_memory_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_memory_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_memory_query_interface>(),
        32usize,
        concat!("Size of: ", stringify!(x86_memory_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_memory_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_memory_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_query_interface),
            "::",
            stringify!(linear_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_query_interface),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_query_interface),
            "::",
            stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_memory_query_interface),
            "::",
            stringify!(memory_type)
        )
    );
}
pub type x86_exception_query_interface_t = x86_exception_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_exception_query_interface {
    pub vector: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut exception_handle_t) -> uint8,
    >,
    pub source: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut exception_handle_t,
        ) -> x86_exception_source_t,
    >,
    pub error_code: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut exception_handle_t) -> uint32,
    >,
}
#[test]
fn bindgen_test_layout_x86_exception_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_exception_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_exception_query_interface>(),
        24usize,
        concat!("Size of: ", stringify!(x86_exception_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_exception_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_exception_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_query_interface),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_query_interface),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_exception_query_interface),
            "::",
            stringify!(error_code)
        )
    );
}
pub type x86_address_query_interface_t = x86_address_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_address_query_interface {
    pub segment: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut conf_object_t, handle: *mut address_handle_t) -> x86_seg_t,
    >,
    pub get_page_crossing_info: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            handle: *mut address_handle_t,
        ) -> page_crossing_info_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_address_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_address_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_address_query_interface>(),
        16usize,
        concat!("Size of: ", stringify!(x86_address_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_address_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_address_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_address_query_interface),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_page_crossing_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_address_query_interface),
            "::",
            stringify!(get_page_crossing_info)
        )
    );
}
#[doc = " <add-type id=\"x86_mode_switch_cb_t\"></add-type>"]
pub type x86_mode_switch_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        mode: x86_detailed_exec_mode_t,
        user_data: *mut lang_void,
    ),
>;
pub type x86_instrumentation_subscribe_interface_t = x86_instrumentation_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_instrumentation_subscribe_interface {
    pub register_mode_switch_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: x86_mode_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_illegal_instruction_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_instruction_decoder_cb_t,
            disass_cb: cpu_instruction_disassemble_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_instrumentation_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_instrumentation_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_instrumentation_subscribe_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(x86_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<x86_instrumentation_subscribe_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x86_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_mode_switch_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_instrumentation_subscribe_interface),
            "::",
            stringify!(register_mode_switch_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_illegal_instruction_cb) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_instrumentation_subscribe_interface),
            "::",
            stringify!(register_illegal_instruction_cb)
        )
    );
}
pub type x86_instrumentation_subscribe_v2_interface_t = x86_instrumentation_subscribe_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_instrumentation_subscribe_v2_interface {
    pub register_mode_enter_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: x86_mode_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_mode_leave_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: x86_mode_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_illegal_instruction_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: cpu_instruction_decoder_cb_t,
            disass_cb: cpu_instruction_disassemble_cb_t,
            data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_x86_instrumentation_subscribe_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_instrumentation_subscribe_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_instrumentation_subscribe_v2_interface>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(x86_instrumentation_subscribe_v2_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<x86_instrumentation_subscribe_v2_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x86_instrumentation_subscribe_v2_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_mode_enter_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_instrumentation_subscribe_v2_interface),
            "::",
            stringify!(register_mode_enter_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_mode_leave_cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_instrumentation_subscribe_v2_interface),
            "::",
            stringify!(register_mode_leave_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_illegal_instruction_cb) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_instrumentation_subscribe_v2_interface),
            "::",
            stringify!(register_illegal_instruction_cb)
        )
    );
}
pub const vmx_mode_t_Vmx_Off: vmx_mode_t = 0;
pub const vmx_mode_t_Vmx_Root: vmx_mode_t = 1;
pub const vmx_mode_t_Vmx_Non_Root: vmx_mode_t = 2;
#[doc = " <add-type id=\"vmx_mode_t\"> This enum is used to distinguish VMX modes. It is\nused by the <type>vmx_mode_switch_cb_t</type>.\n</add-type>"]
pub type vmx_mode_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"vmx_mode_switch_cb_t\">\nThis callback type is used by the\n<iface>vmx_instrumentation_subscribe</iface> to implements VMX mode switch\ninstrumentation.\n</add-type>"]
pub type vmx_mode_switch_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        mode: vmx_mode_t,
        vmcs_address: physical_address_t,
        user_data: *mut lang_void,
    ),
>;
pub type vmx_instrumentation_subscribe_interface_t = vmx_instrumentation_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vmx_instrumentation_subscribe_interface {
    pub register_vmx_mode_leave_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: vmx_mode_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_vmx_mode_enter_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: vmx_mode_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_vmx_instrumentation_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vmx_instrumentation_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmx_instrumentation_subscribe_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(vmx_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vmx_instrumentation_subscribe_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vmx_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_vmx_mode_leave_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmx_instrumentation_subscribe_interface),
            "::",
            stringify!(register_vmx_mode_leave_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_vmx_mode_enter_cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmx_instrumentation_subscribe_interface),
            "::",
            stringify!(register_vmx_mode_enter_cb)
        )
    );
}
#[doc = " <add-type id=\"smm_switch_cb_t\">\nThis callback type is used by the\n<iface>smm_instrumentation_subscribe</iface> to implement instrumentation.\n</add-type>"]
pub type smm_switch_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        cpu: *mut conf_object_t,
        user_data: *mut lang_void,
    ),
>;
pub type smm_instrumentation_subscribe_interface_t = smm_instrumentation_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct smm_instrumentation_subscribe_interface {
    pub register_smm_enter_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: smm_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_smm_enter_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: smm_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_smm_leave_before_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: smm_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
    pub register_smm_leave_after_cb: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            connection: *mut conf_object_t,
            cb: smm_switch_cb_t,
            user_data: *mut lang_void,
        ) -> *mut cpu_cb_handle_t,
    >,
}
#[test]
fn bindgen_test_layout_smm_instrumentation_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<smm_instrumentation_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<smm_instrumentation_subscribe_interface>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(smm_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<smm_instrumentation_subscribe_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(smm_instrumentation_subscribe_interface)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_smm_enter_before_cb) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_instrumentation_subscribe_interface),
            "::",
            stringify!(register_smm_enter_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_smm_enter_after_cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_instrumentation_subscribe_interface),
            "::",
            stringify!(register_smm_enter_after_cb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).register_smm_leave_before_cb) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_instrumentation_subscribe_interface),
            "::",
            stringify!(register_smm_leave_before_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_smm_leave_after_cb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(smm_instrumentation_subscribe_interface),
            "::",
            stringify!(register_smm_leave_after_cb)
        )
    );
}
pub const x86_stream_enum_t_X86_Stream_Instruction_LA: x86_stream_enum_t = 32;
pub const x86_stream_enum_t_X86_Stream_Instruction_LA_After: x86_stream_enum_t = 33;
pub const x86_stream_enum_t_X86_Stream_Read_Memory: x86_stream_enum_t = 34;
pub const x86_stream_enum_t_X86_Stream_Write_Memory: x86_stream_enum_t = 35;
pub const x86_stream_enum_t_X86_Stream_Last: x86_stream_enum_t = 36;
#[doc = " ADD INTERFACE smm_instrumentation_subscribe"]
pub type x86_stream_enum_t = ::std::os::raw::c_uint;
#[doc = " Normal load or store instructions"]
pub const arm_mem_instr_origin_t_Instr_Normal_Arm: arm_mem_instr_origin_t = 0;
#[doc = " Unprivileged memory access instructions."]
pub const arm_mem_instr_origin_t_Instr_Unprivileged_Load: arm_mem_instr_origin_t = 1;
#[doc = " Unprivileged memory access instructions."]
pub const arm_mem_instr_origin_t_Instr_Unprivileged_Store: arm_mem_instr_origin_t = 2;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const arm_mem_instr_origin_t_Instr_ldrex: arm_mem_instr_origin_t = 3;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const arm_mem_instr_origin_t_Instr_strex: arm_mem_instr_origin_t = 4;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const arm_mem_instr_origin_t_Instr_ldxp: arm_mem_instr_origin_t = 5;
#[doc = " Other loads/stores or cache affecting instructions"]
pub const arm_mem_instr_origin_t_Instr_stxp: arm_mem_instr_origin_t = 6;
#[doc = " Address translation instruction"]
pub const arm_mem_instr_origin_t_Instr_At: arm_mem_instr_origin_t = 7;
#[doc = " Atomic read-modify-write instructions"]
pub const arm_mem_instr_origin_t_Instr_Atomic: arm_mem_instr_origin_t = 8;
#[doc = " Cache maintenance instructions"]
pub const arm_mem_instr_origin_t_Instr_Cache_Maintenance: arm_mem_instr_origin_t = 9;
#[doc = " Number of different of enum values, not a value in itself."]
pub const arm_mem_instr_origin_t_Instr_Count: arm_mem_instr_origin_t = 10;
#[doc = " <add-type id=\"arm_mem_instr_origin_t def\"></add-type>"]
pub type arm_mem_instr_origin_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"arm_memory_transaction_t DOC\">\n<ndx>arm_memory_transaction_t</ndx>\n<name index=\"true\">arm_memory_transaction_t</name>\n<doc>\n<doc-item name=\"NAME\">arm_memory_transaction_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"arm_memory_transaction_t def\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThis is the ARM specific memory transaction data structure.\nThe generic data is stored in the <var>s</var> field.\n\nThe <var>mode</var> field specifies the processor mode the MMU should assume\nwhen processing the transaction. This is the same as the current mode of the\nprocessor except for unprivileged load and store instructions when it is\nalways <const>Sim_CPU_Mode_User</const>.\n\nThe <var>rotate</var> field is non-zero if this transaction is from one of\nthe AArch32 instructions for which an unaligned address is interpreted as an\naligned load with the value rotated so that the addressed byte becomes the\nleast significant byte if neither <reg>SCTLR.U</reg> nor <reg>SCTLR.A</reg>\nis set.\n\nThe <var>instr_origin</var> field specifies the type of instruction that\ninitiated this memory transaction.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"arm_memory_transaction_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_memory_transaction {
    pub s: generic_transaction_t,
    pub mode: processor_mode_t,
    pub rotate: ::std::os::raw::c_int,
    pub instr_origin: arm_mem_instr_origin_t,
}
#[test]
fn bindgen_test_layout_arm_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<arm_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_memory_transaction>(),
        120usize,
        concat!("Size of: ", stringify!(arm_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_memory_transaction),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_memory_transaction),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotate) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_memory_transaction),
            "::",
            stringify!(rotate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instr_origin) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_memory_transaction),
            "::",
            stringify!(instr_origin)
        )
    );
}
impl Default for arm_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add id=\"arm_memory_transaction_t DOC\">\n<ndx>arm_memory_transaction_t</ndx>\n<name index=\"true\">arm_memory_transaction_t</name>\n<doc>\n<doc-item name=\"NAME\">arm_memory_transaction_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"arm_memory_transaction_t def\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThis is the ARM specific memory transaction data structure.\nThe generic data is stored in the <var>s</var> field.\n\nThe <var>mode</var> field specifies the processor mode the MMU should assume\nwhen processing the transaction. This is the same as the current mode of the\nprocessor except for unprivileged load and store instructions when it is\nalways <const>Sim_CPU_Mode_User</const>.\n\nThe <var>rotate</var> field is non-zero if this transaction is from one of\nthe AArch32 instructions for which an unaligned address is interpreted as an\naligned load with the value rotated so that the addressed byte becomes the\nleast significant byte if neither <reg>SCTLR.U</reg> nor <reg>SCTLR.A</reg>\nis set.\n\nThe <var>instr_origin</var> field specifies the type of instruction that\ninitiated this memory transaction.\n\n</doc-item>\n</doc>\n</add>\n\n<add-type id=\"arm_memory_transaction_t def\"></add-type>"]
pub type arm_memory_transaction_t = arm_memory_transaction;
extern "C" {
    pub fn SIM_arm_mem_trans_from_generic(
        mop: *mut generic_transaction_t,
    ) -> *mut arm_memory_transaction_t;
}
pub type arm_interface_t = arm_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_interface {
    pub read_register_mode: ::std::option::Option<
        unsafe extern "C" fn(
            processor_obj: *mut conf_object_t,
            reg_num: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        ) -> uint64,
    >,
    pub write_register_mode: ::std::option::Option<
        unsafe extern "C" fn(
            processor_obj: *mut conf_object_t,
            reg_num: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
            value: uint64,
        ),
    >,
}
#[test]
fn bindgen_test_layout_arm_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_interface>(),
        16usize,
        concat!("Size of: ", stringify!(arm_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_interface),
            "::",
            stringify!(read_register_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_interface),
            "::",
            stringify!(write_register_mode)
        )
    );
}
pub type arm_coprocessor_interface_t = arm_coprocessor_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_coprocessor_interface {
    pub process_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            CRd: uint32,
            opcode_1: uint32,
            CRn: uint32,
            CRm: uint32,
            opcode_2: uint32,
            type_: ::std::os::raw::c_int,
        ),
    >,
    pub load_coprocessor: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            CRd: uint32,
            N: uint32,
            Options: uint32,
            value: uint32,
            type_: ::std::os::raw::c_int,
        ),
    >,
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            opcode_1: uint32,
            CRn: uint32,
            CRm: uint32,
            opcode_2: uint32,
            type_: ::std::os::raw::c_int,
        ) -> uint32,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            value: uint32,
            opcode_1: uint32,
            CRn: uint32,
            CRm: uint32,
            opcode_2: uint32,
            type_: ::std::os::raw::c_int,
        ),
    >,
    pub read_register_64_bit: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            opcode_1: uint32,
            CRm: uint32,
            type_: ::std::os::raw::c_int,
        ) -> uint64,
    >,
    pub write_register_64_bit: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            value: uint64,
            opcode_1: uint32,
            CRm: uint32,
            type_: ::std::os::raw::c_int,
        ),
    >,
    pub store_coprocessor: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            CRd: uint32,
            N: uint32,
            Options: uint32,
            type_: ::std::os::raw::c_int,
        ) -> uint32,
    >,
    pub reset: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, hard_reset: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_arm_coprocessor_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_coprocessor_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_coprocessor_interface>(),
        64usize,
        concat!("Size of: ", stringify!(arm_coprocessor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_coprocessor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_coprocessor_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(process_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_coprocessor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(load_coprocessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(write_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register_64_bit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(read_register_64_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register_64_bit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(write_register_64_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).store_coprocessor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(store_coprocessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_coprocessor_interface),
            "::",
            stringify!(reset)
        )
    );
}
#[doc = " <add id=\"arm_avic_interface_t\">\n\nThe <iface>ARM AVIC</iface> interface makes it possible for an ARM\nprocessor to get the interrupt vector address from an AVIC device\nconnected to the processor core. Both processor and AVIC must\nenable the AVIC interface to support this feature.\n\nThe processor calls <fun>get_interrupt_address</fun> function to\nget the interrupt vector address. The AVIC returns an\n<em>arm_avic_t</em> struct with a <i>valid</i> field and an\n<i>address</i> field, the <i>address</i> field is only valid when\nthe <i>valid</i> is not <tt>0</tt>.\n\n<insert-until text=\"// ADD INTERFACE arm_avic_interface\"/>\n</add>\n<add id=\"arm_avic_interface_exec_context\">\nCell Context for all methods.\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_avic {
    pub valid: ::std::os::raw::c_int,
    pub address: uint32,
}
#[test]
fn bindgen_test_layout_arm_avic() {
    const UNINIT: ::std::mem::MaybeUninit<arm_avic> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_avic>(),
        8usize,
        concat!("Size of: ", stringify!(arm_avic))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_avic>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_avic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_avic),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_avic),
            "::",
            stringify!(address)
        )
    );
}
#[doc = " <add id=\"arm_avic_interface_t\">\n\nThe <iface>ARM AVIC</iface> interface makes it possible for an ARM\nprocessor to get the interrupt vector address from an AVIC device\nconnected to the processor core. Both processor and AVIC must\nenable the AVIC interface to support this feature.\n\nThe processor calls <fun>get_interrupt_address</fun> function to\nget the interrupt vector address. The AVIC returns an\n<em>arm_avic_t</em> struct with a <i>valid</i> field and an\n<i>address</i> field, the <i>address</i> field is only valid when\nthe <i>valid</i> is not <tt>0</tt>.\n\n<insert-until text=\"// ADD INTERFACE arm_avic_interface\"/>\n</add>\n<add id=\"arm_avic_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type arm_avic_t = arm_avic;
pub type arm_avic_interface_t = arm_avic_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_avic_interface {
    pub get_interrupt_address:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> arm_avic_t>,
}
#[test]
fn bindgen_test_layout_arm_avic_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_avic_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_avic_interface>(),
        8usize,
        concat!("Size of: ", stringify!(arm_avic_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_avic_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_avic_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interrupt_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_avic_interface),
            "::",
            stringify!(get_interrupt_address)
        )
    );
}
pub const arm_trustzone_mode_t_Arm_Trustzone_Secure: arm_trustzone_mode_t = 0;
pub const arm_trustzone_mode_t_Arm_Trustzone_Non_Secure: arm_trustzone_mode_t = 1;
#[doc = " <add id=\"arm_trustzone_interface_t\">\n\nThis interface is implemented by ARM processors that supports the arm ARM\nTrustZone feature. The <fun>get_security_mode</fun> function returns the\ncurrent state of the processor, whereas <fun>mem_op_security_mode</fun>\nextracts the mode of a memory operation in progress.\n\nThe <fun>get_security_mode</fun> functions corresponds to the expression\n<tt>(cpsr.mode != Monitor &amp;&amp; scr.ns) ? Arm_Trustzone_Non_Secure :\nArm_Trustzone_Secure</tt>. The <fun>mem_op_security_mode</fun> function\nalways returns <tt>Arm_Trustzone_Non_Secure</tt> when the processor is in\nnon-secure mode, in secure mode it returns the <tt>ns</tt> bit in the\nfirst-level page table entry for the actual area being accessed.\n\n<insert-until text=\"// END INTERFACE trustzone_arm\"/>\n</add>\n<add id=\"arm_trustzone_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type arm_trustzone_mode_t = ::std::os::raw::c_uint;
pub type arm_trustzone_interface_t = arm_trustzone_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_trustzone_interface {
    pub get_security_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> arm_trustzone_mode_t,
    >,
    pub mem_op_security_mode: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            memop: *mut generic_transaction_t,
        ) -> arm_trustzone_mode_t,
    >,
}
#[test]
fn bindgen_test_layout_arm_trustzone_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_trustzone_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_trustzone_interface>(),
        16usize,
        concat!("Size of: ", stringify!(arm_trustzone_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_trustzone_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_trustzone_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_security_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_trustzone_interface),
            "::",
            stringify!(get_security_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_op_security_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_trustzone_interface),
            "::",
            stringify!(mem_op_security_mode)
        )
    );
}
pub type arm_external_debug_interface_t = arm_external_debug_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_external_debug_interface {
    pub handle_semihosting: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub read_reg: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, offset: ::std::os::raw::c_int) -> uint64,
    >,
    pub write_reg: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, offset: ::std::os::raw::c_int, v: uint64),
    >,
}
#[test]
fn bindgen_test_layout_arm_external_debug_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_external_debug_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_external_debug_interface>(),
        24usize,
        concat!("Size of: ", stringify!(arm_external_debug_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_external_debug_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_external_debug_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_semihosting) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_external_debug_interface),
            "::",
            stringify!(handle_semihosting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_reg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_external_debug_interface),
            "::",
            stringify!(read_reg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_reg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_external_debug_interface),
            "::",
            stringify!(write_reg)
        )
    );
}
#[doc = " <add id=\"arm_gic_interface_t\"> This <iface>arm_gic</iface> interface is used\naccessing registers in a device implementing the Generic Interrupt\nController architecture..\n\nThe <fun>read_register</fun> function is called reading the registers in GIC\ndevice.\n\nThe <fun>write_register</fun> function is called writing the registers in\nGIC device.\n\nThe <fun>cpu_state_changed</fun> function is called to notify the GIC device\nthat the cpu has changed state. This function is only called when the cpu\nchanges state with an interrupt pending. </add>\n\n<add id=\"arm_gic_interface_exec_context\">\nCell Context for all methods.\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_cpu_state {
    #[doc = " scr_el3.irq"]
    pub fmo_set: bool,
    pub imo_set: bool,
    #[doc = " scr_el3.irq"]
    pub irq_set: bool,
    #[doc = " scr_el3.fiq"]
    pub fiq_set: bool,
    pub ns: bool,
    pub el: ::std::os::raw::c_int,
    pub mpidr: uint32,
}
#[test]
fn bindgen_test_layout_arm_cpu_state() {
    const UNINIT: ::std::mem::MaybeUninit<arm_cpu_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_cpu_state>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cpu_state))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_cpu_state>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cpu_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmo_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(fmo_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imo_set) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(imo_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irq_set) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(irq_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fiq_set) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(fiq_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(el)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpidr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_state),
            "::",
            stringify!(mpidr)
        )
    );
}
#[doc = " <add id=\"arm_gic_interface_t\"> This <iface>arm_gic</iface> interface is used\naccessing registers in a device implementing the Generic Interrupt\nController architecture..\n\nThe <fun>read_register</fun> function is called reading the registers in GIC\ndevice.\n\nThe <fun>write_register</fun> function is called writing the registers in\nGIC device.\n\nThe <fun>cpu_state_changed</fun> function is called to notify the GIC device\nthat the cpu has changed state. This function is only called when the cpu\nchanges state with an interrupt pending. </add>\n\n<add id=\"arm_gic_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type arm_cpu_state_t = arm_cpu_state;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gic_reg_info {
    pub op1: ::std::os::raw::c_int,
    pub crn: ::std::os::raw::c_int,
    pub crm: ::std::os::raw::c_int,
    pub op2: ::std::os::raw::c_int,
    pub cpu_state: arm_cpu_state_t,
}
#[test]
fn bindgen_test_layout_gic_reg_info() {
    const UNINIT: ::std::mem::MaybeUninit<gic_reg_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gic_reg_info>(),
        32usize,
        concat!("Size of: ", stringify!(gic_reg_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gic_reg_info>(),
        4usize,
        concat!("Alignment of ", stringify!(gic_reg_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gic_reg_info),
            "::",
            stringify!(op1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gic_reg_info),
            "::",
            stringify!(crn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gic_reg_info),
            "::",
            stringify!(crm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gic_reg_info),
            "::",
            stringify!(op2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gic_reg_info),
            "::",
            stringify!(cpu_state)
        )
    );
}
pub type gic_reg_info_t = gic_reg_info;
pub type arm_gic_interface_t = arm_gic_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_gic_interface {
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            reg_info: gic_reg_info_t,
            inquiry: bool,
        ) -> uint64,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, reg_info: gic_reg_info_t, value: uint64),
    >,
    pub cpu_state_changed: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu_state: arm_cpu_state_t),
    >,
}
#[test]
fn bindgen_test_layout_arm_gic_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_gic_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_gic_interface>(),
        24usize,
        concat!("Size of: ", stringify!(arm_gic_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_gic_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_gic_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gic_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gic_interface),
            "::",
            stringify!(write_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_state_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gic_interface),
            "::",
            stringify!(cpu_state_changed)
        )
    );
}
pub type arm_gic_cpu_state_interface_t = arm_gic_cpu_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_gic_cpu_state_interface {
    pub get_cpu_state:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> arm_cpu_state_t>,
}
#[test]
fn bindgen_test_layout_arm_gic_cpu_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_gic_cpu_state_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_gic_cpu_state_interface>(),
        8usize,
        concat!("Size of: ", stringify!(arm_gic_cpu_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_gic_cpu_state_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_gic_cpu_state_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cpu_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gic_cpu_state_interface),
            "::",
            stringify!(get_cpu_state)
        )
    );
}
pub const arm_mem_type_t_Arm_MemType_Normal: arm_mem_type_t = 0;
pub const arm_mem_type_t_Arm_MemType_Device: arm_mem_type_t = 1;
#[doc = " <add-type id=\"arm_mem_type_t def\"></add-type>"]
pub type arm_mem_type_t = ::std::os::raw::c_uint;
pub const arm_device_type_t_Arm_DeviceType_nGnRnE: arm_device_type_t = 0;
pub const arm_device_type_t_Arm_DeviceType_nGnRE: arm_device_type_t = 1;
pub const arm_device_type_t_Arm_DeviceType_nGRE: arm_device_type_t = 2;
pub const arm_device_type_t_Arm_DeviceType_GRE: arm_device_type_t = 3;
pub const arm_device_type_t_Arm_DeviceType_Unknown: arm_device_type_t = 4;
#[doc = " <add-type id=\"arm_device_type_t def\"></add-type>"]
pub type arm_device_type_t = ::std::os::raw::c_uint;
#[doc = " Non-cacheable"]
pub const arm_mem_attr_t_Arm_MemAttr_NC: arm_mem_attr_t = 0;
#[doc = " Write-through"]
pub const arm_mem_attr_t_Arm_MemAttr_WT: arm_mem_attr_t = 2;
#[doc = " Write-back"]
pub const arm_mem_attr_t_Arm_MemAttr_WB: arm_mem_attr_t = 3;
pub const arm_mem_attr_t_Arm_MemAttr_Unknown: arm_mem_attr_t = 4;
#[doc = " <add-type id=\"arm_mem_attr_t def\"></add-type>"]
pub type arm_mem_attr_t = ::std::os::raw::c_uint;
#[doc = " No Read-Allocate, No Write-Allocate"]
pub const arm_mem_hint_t_Arm_MemHint_No: arm_mem_hint_t = 0;
#[doc = " No Read-Allocate, Write-Allocate"]
pub const arm_mem_hint_t_Arm_MemHint_WA: arm_mem_hint_t = 1;
#[doc = " Read-Allocate, No Write-Allocate"]
pub const arm_mem_hint_t_Arm_MemHint_RA: arm_mem_hint_t = 2;
#[doc = " Read-Allocate, Write-Allocate"]
pub const arm_mem_hint_t_Arm_MemHint_RWA: arm_mem_hint_t = 3;
pub const arm_mem_hint_t_Arm_MemHint_Unknown: arm_mem_hint_t = 4;
#[doc = " <add-type id=\"arm_mem_hint_t def\"></add-type>"]
pub type arm_mem_hint_t = ::std::os::raw::c_uint;
pub const arm_mem_transient_t_Arm_Transient_True: arm_mem_transient_t = 0;
pub const arm_mem_transient_t_Arm_Transient_False: arm_mem_transient_t = 1;
pub const arm_mem_transient_t_Arm_Transient_Unknown: arm_mem_transient_t = 2;
#[doc = " <add-type id=\"arm_mem_transient_t def\"></add-type>"]
pub type arm_mem_transient_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"arm_memory_attributes_encoding_t def\"></add-type>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union arm_memory_attributes_encoding_t {
    pub u: arm_memory_attributes_encoding_t__bindgen_ty_1,
    pub u64_: uint64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_memory_attributes_encoding_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_arm_memory_attributes_encoding_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<arm_memory_attributes_encoding_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(arm_memory_attributes_encoding_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<arm_memory_attributes_encoding_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_memory_attributes_encoding_t__bindgen_ty_1)
        )
    );
}
impl arm_memory_attributes_encoding_t__bindgen_ty_1 {
    #[inline]
    pub fn memory_type(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_memory_type(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn device_type(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_device_type(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_cacheability(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_inner_cacheability(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_allocation_hint(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_inner_allocation_hint(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_transcience_hint(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_inner_transcience_hint(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_cacheability(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_outer_cacheability(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_allocation_hint(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_outer_allocation_hint(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_transcience_hint(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_outer_transcience_hint(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn shareable(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_shareable(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_shareable(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_outer_shareable(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        memory_type: uint64,
        device_type: uint64,
        inner_cacheability: uint64,
        inner_allocation_hint: uint64,
        inner_transcience_hint: uint64,
        outer_cacheability: uint64,
        outer_allocation_hint: uint64,
        outer_transcience_hint: uint64,
        shareable: uint64,
        outer_shareable: uint64,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let memory_type: u64 = unsafe { ::std::mem::transmute(memory_type) };
            memory_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let device_type: u64 = unsafe { ::std::mem::transmute(device_type) };
            device_type as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let inner_cacheability: u64 = unsafe { ::std::mem::transmute(inner_cacheability) };
            inner_cacheability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let inner_allocation_hint: u64 =
                unsafe { ::std::mem::transmute(inner_allocation_hint) };
            inner_allocation_hint as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let inner_transcience_hint: u64 =
                unsafe { ::std::mem::transmute(inner_transcience_hint) };
            inner_transcience_hint as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let outer_cacheability: u64 = unsafe { ::std::mem::transmute(outer_cacheability) };
            outer_cacheability as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let outer_allocation_hint: u64 =
                unsafe { ::std::mem::transmute(outer_allocation_hint) };
            outer_allocation_hint as u64
        });
        __bindgen_bitfield_unit.set(19usize, 2u8, {
            let outer_transcience_hint: u64 =
                unsafe { ::std::mem::transmute(outer_transcience_hint) };
            outer_transcience_hint as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let shareable: u64 = unsafe { ::std::mem::transmute(shareable) };
            shareable as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let outer_shareable: u64 = unsafe { ::std::mem::transmute(outer_shareable) };
            outer_shareable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_arm_memory_attributes_encoding_t() {
    const UNINIT: ::std::mem::MaybeUninit<arm_memory_attributes_encoding_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_memory_attributes_encoding_t>(),
        8usize,
        concat!("Size of: ", stringify!(arm_memory_attributes_encoding_t))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_memory_attributes_encoding_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_memory_attributes_encoding_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_memory_attributes_encoding_t),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_memory_attributes_encoding_t),
            "::",
            stringify!(u64_)
        )
    );
}
impl Default for arm_memory_attributes_encoding_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"arm_smmu_attributes_t def\"></add-type>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union arm_smmu_attributes_t {
    pub u: arm_smmu_attributes_t__bindgen_ty_1,
    pub u64_: uint64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_smmu_attributes_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[test]
fn bindgen_test_layout_arm_smmu_attributes_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<arm_smmu_attributes_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(arm_smmu_attributes_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_smmu_attributes_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_smmu_attributes_t__bindgen_ty_1)
        )
    );
}
impl arm_smmu_attributes_t__bindgen_ty_1 {
    #[inline]
    pub fn sid(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_sid(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ssid(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_ssid(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn secsid(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_secsid(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssidv(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssidv(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn atst(&self) -> uint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_atst(&mut self, val: uint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sid: uint64,
        ssid: uint64,
        secsid: uint64,
        ssidv: uint64,
        atst: uint64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let sid: u64 = unsafe { ::std::mem::transmute(sid) };
            sid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let ssid: u64 = unsafe { ::std::mem::transmute(ssid) };
            ssid as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let secsid: u64 = unsafe { ::std::mem::transmute(secsid) };
            secsid as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let ssidv: u64 = unsafe { ::std::mem::transmute(ssidv) };
            ssidv as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let atst: u64 = unsafe { ::std::mem::transmute(atst) };
            atst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_arm_smmu_attributes_t() {
    const UNINIT: ::std::mem::MaybeUninit<arm_smmu_attributes_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_smmu_attributes_t>(),
        8usize,
        concat!("Size of: ", stringify!(arm_smmu_attributes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_smmu_attributes_t>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_smmu_attributes_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_smmu_attributes_t),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_smmu_attributes_t),
            "::",
            stringify!(u64_)
        )
    );
}
impl Default for arm_smmu_attributes_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_arm_privileged {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_arm_privileged() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_arm_privileged> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_arm_privileged>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_arm_privileged)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_arm_privileged>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_arm_privileged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_arm_privileged),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_arm_nonsecure {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_arm_nonsecure() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_arm_nonsecure> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_arm_nonsecure>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_arm_nonsecure))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_arm_nonsecure>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_arm_nonsecure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_arm_nonsecure),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_arm_memory_attributes {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_arm_memory_attributes() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_arm_memory_attributes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_arm_memory_attributes>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_arm_memory_attributes)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_arm_memory_attributes>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_arm_memory_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_arm_memory_attributes),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_arm_smmu_attributes {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_arm_smmu_attributes() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_arm_smmu_attributes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_arm_smmu_attributes>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_arm_smmu_attributes)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_arm_smmu_attributes>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_arm_smmu_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_arm_smmu_attributes),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_arm_nsaid {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_arm_nsaid() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_arm_nsaid> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_arm_nsaid>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_arm_nsaid))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_arm_nsaid>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_arm_nsaid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_arm_nsaid),
            "::",
            stringify!(dummy)
        )
    );
}
pub type arm_cpu_group_exclusive_interface_t = arm_cpu_group_exclusive_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_cpu_group_exclusive_interface {
    pub mark_exclusive: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            address: physical_address_t,
            size: physical_address_t,
        ),
    >,
    pub clear_and_probe_exclusive: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            clear_address: physical_address_t,
            clear_size: physical_address_t,
            probe_address: physical_address_t,
            probe_size: physical_address_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_arm_cpu_group_exclusive_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_cpu_group_exclusive_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_cpu_group_exclusive_interface>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cpu_group_exclusive_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_cpu_group_exclusive_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_cpu_group_exclusive_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mark_exclusive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_group_exclusive_interface),
            "::",
            stringify!(mark_exclusive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_and_probe_exclusive) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_group_exclusive_interface),
            "::",
            stringify!(clear_and_probe_exclusive)
        )
    );
}
pub type arm_cpu_group_event_interface_t = arm_cpu_group_event_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_cpu_group_event_interface {
    pub signal_event: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_arm_cpu_group_event_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_cpu_group_event_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_cpu_group_event_interface>(),
        8usize,
        concat!("Size of: ", stringify!(arm_cpu_group_event_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_cpu_group_event_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cpu_group_event_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_group_event_interface),
            "::",
            stringify!(signal_event)
        )
    );
}
#[doc = " EL3"]
pub const arm_translation_regime_t_Arm_TR_EL3: arm_translation_regime_t = 0;
#[doc = " EL2   PL2"]
pub const arm_translation_regime_t_Arm_TR_EL2: arm_translation_regime_t = 1;
#[doc = " EL2&0"]
pub const arm_translation_regime_t_Arm_TR_EL20: arm_translation_regime_t = 2;
#[doc = " EL1&0 PL1&0"]
pub const arm_translation_regime_t_Arm_TR_EL10: arm_translation_regime_t = 3;
#[doc = " <add-type id=\"arm_translation_regime_t def\"></add-type>"]
pub type arm_translation_regime_t = ::std::os::raw::c_uint;
pub type arm_cpu_group_tlb_interface_t = arm_cpu_group_tlb_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arm_cpu_group_tlb_interface {
    pub invalidate_tlb: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            translation_regime: arm_translation_regime_t,
            by_virtual_address: bool,
            virtual_address: logical_address_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_arm_cpu_group_tlb_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arm_cpu_group_tlb_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arm_cpu_group_tlb_interface>(),
        8usize,
        concat!("Size of: ", stringify!(arm_cpu_group_tlb_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_cpu_group_tlb_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cpu_group_tlb_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate_tlb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cpu_group_tlb_interface),
            "::",
            stringify!(invalidate_tlb)
        )
    );
}
#[doc = " <add-type id=\"xtensa_memory_transaction_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_memory_transaction {
    #[doc = " generic transaction"]
    pub s: generic_transaction_t,
}
#[test]
fn bindgen_test_layout_xtensa_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_memory_transaction>(),
        104usize,
        concat!("Size of: ", stringify!(xtensa_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_memory_transaction),
            "::",
            stringify!(s)
        )
    );
}
impl Default for xtensa_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"xtensa_memory_transaction_t def\"></add-type>"]
pub type xtensa_memory_transaction_t = xtensa_memory_transaction;
pub type xtensa_tie_lookup_interface_t = xtensa_tie_lookup_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_tie_lookup_interface {
    pub data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            out_width: uint32,
            out_data: *const uint32,
            in_width: uint32,
            in_data: *mut uint32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_tie_lookup_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_tie_lookup_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_tie_lookup_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_tie_lookup_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_tie_lookup_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_tie_lookup_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_lookup_interface),
            "::",
            stringify!(data)
        )
    );
}
pub type xtensa_tie_export_state_interface_t = xtensa_tie_export_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_tie_export_state_interface {
    pub data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bit_width: uint32, out_data: *const uint32),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_tie_export_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_tie_export_state_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_tie_export_state_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_tie_export_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_tie_export_state_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xtensa_tie_export_state_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_export_state_interface),
            "::",
            stringify!(data)
        )
    );
}
pub type xtensa_tie_output_queue_interface_t = xtensa_tie_output_queue_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_tie_output_queue_interface {
    pub full: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bit_width: uint32,
            reserve_only: bool,
            out_data: *const uint32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_tie_output_queue_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_tie_output_queue_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_tie_output_queue_interface>(),
        16usize,
        concat!("Size of: ", stringify!(xtensa_tie_output_queue_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_tie_output_queue_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xtensa_tie_output_queue_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_output_queue_interface),
            "::",
            stringify!(full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_output_queue_interface),
            "::",
            stringify!(data)
        )
    );
}
pub type xtensa_tie_input_queue_interface_t = xtensa_tie_input_queue_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_tie_input_queue_interface {
    pub empty: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bit_width: uint32,
            is_peek: bool,
            in_data: *mut uint32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_tie_input_queue_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_tie_input_queue_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_tie_input_queue_interface>(),
        16usize,
        concat!("Size of: ", stringify!(xtensa_tie_input_queue_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_tie_input_queue_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xtensa_tie_input_queue_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).empty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_input_queue_interface),
            "::",
            stringify!(empty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_input_queue_interface),
            "::",
            stringify!(data)
        )
    );
}
pub type xtensa_tie_import_wire_interface_t = xtensa_tie_import_wire_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_tie_import_wire_interface {
    pub data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bit_width: uint32, in_data: *mut uint32),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_tie_import_wire_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_tie_import_wire_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_tie_import_wire_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_tie_import_wire_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_tie_import_wire_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xtensa_tie_import_wire_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_tie_import_wire_interface),
            "::",
            stringify!(data)
        )
    );
}
pub type xtensa_lookup_interface_t = xtensa_lookup_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_lookup_interface {
    pub register_lookup: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            user_object: *mut lang_void,
            lookup_func: *mut lang_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_lookup_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_lookup_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_lookup_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_lookup_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_lookup_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_lookup_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_lookup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_lookup_interface),
            "::",
            stringify!(register_lookup)
        )
    );
}
pub type xtensa_export_state_interface_t = xtensa_export_state_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_export_state_interface {
    pub register_export_state: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            user_object: *mut lang_void,
            export_state_func: *mut lang_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_export_state_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_export_state_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_export_state_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_export_state_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_export_state_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_export_state_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_export_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_export_state_interface),
            "::",
            stringify!(register_export_state)
        )
    );
}
pub type xtensa_output_queue_interface_t = xtensa_output_queue_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_output_queue_interface {
    pub register_output_queue: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            user_object: *mut lang_void,
            full_callback: *mut lang_void,
            data_callback: *mut lang_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_output_queue_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_output_queue_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_output_queue_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_output_queue_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_output_queue_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_output_queue_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_output_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_output_queue_interface),
            "::",
            stringify!(register_output_queue)
        )
    );
}
pub type xtensa_input_queue_interface_t = xtensa_input_queue_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_input_queue_interface {
    pub register_input_queue: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            user_object: *mut lang_void,
            empty_callback: *mut lang_void,
            data_callback: *mut lang_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_input_queue_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_input_queue_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_input_queue_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_input_queue_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_input_queue_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_input_queue_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_input_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_input_queue_interface),
            "::",
            stringify!(register_input_queue)
        )
    );
}
pub type xtensa_import_wire_interface_t = xtensa_import_wire_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct xtensa_import_wire_interface {
    pub register_import_wire: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            user_object: *mut lang_void,
            import_wire_func: *mut lang_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xtensa_import_wire_interface() {
    const UNINIT: ::std::mem::MaybeUninit<xtensa_import_wire_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xtensa_import_wire_interface>(),
        8usize,
        concat!("Size of: ", stringify!(xtensa_import_wire_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xtensa_import_wire_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xtensa_import_wire_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_import_wire) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtensa_import_wire_interface),
            "::",
            stringify!(register_import_wire)
        )
    );
}
#[doc = " <add-type id=\"nios_memory_transaction_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nios_memory_transaction {
    #[doc = " generic transaction"]
    pub s: generic_transaction_t,
}
#[test]
fn bindgen_test_layout_nios_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<nios_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nios_memory_transaction>(),
        104usize,
        concat!("Size of: ", stringify!(nios_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<nios_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(nios_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_memory_transaction),
            "::",
            stringify!(s)
        )
    );
}
impl Default for nios_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " <add-type id=\"nios_memory_transaction_t def\"></add-type>"]
pub type nios_memory_transaction_t = nios_memory_transaction;
pub type nios_interface_t = nios_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nios_interface {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nios_interface() {
    const UNINIT: ::std::mem::MaybeUninit<nios_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nios_interface>(),
        4usize,
        concat!("Size of: ", stringify!(nios_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<nios_interface>(),
        4usize,
        concat!("Alignment of ", stringify!(nios_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_interface),
            "::",
            stringify!(dummy)
        )
    );
}
pub type nios_eic_interface_t = nios_eic_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nios_eic_interface {
    pub handler:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> logical_address_t>,
    pub level: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub reg_set: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub nmi: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub handled: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_nios_eic_interface() {
    const UNINIT: ::std::mem::MaybeUninit<nios_eic_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nios_eic_interface>(),
        40usize,
        concat!("Size of: ", stringify!(nios_eic_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<nios_eic_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(nios_eic_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_eic_interface),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_eic_interface),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_set) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_eic_interface),
            "::",
            stringify!(reg_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nmi) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_eic_interface),
            "::",
            stringify!(nmi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handled) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_eic_interface),
            "::",
            stringify!(handled)
        )
    );
}
pub type nios_cache_interface_t = nios_cache_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nios_cache_interface {
    pub flushd: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut conf_object_t, addr: logical_address_t),
    >,
    pub flushda: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut conf_object_t, addr: logical_address_t),
    >,
    pub flushi: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut conf_object_t, addr: logical_address_t),
    >,
    pub flushp: ::std::option::Option<unsafe extern "C" fn(self_: *mut conf_object_t)>,
    pub initd: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut conf_object_t, addr: logical_address_t),
    >,
    pub initda: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut conf_object_t, addr: logical_address_t),
    >,
    pub initi: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut conf_object_t, addr: logical_address_t),
    >,
    pub sync: ::std::option::Option<unsafe extern "C" fn(self_: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_nios_cache_interface() {
    const UNINIT: ::std::mem::MaybeUninit<nios_cache_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nios_cache_interface>(),
        64usize,
        concat!("Size of: ", stringify!(nios_cache_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<nios_cache_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(nios_cache_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(flushd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushda) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(flushda)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushi) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(flushi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(flushp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(initd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initda) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(initda)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initi) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(initi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_cache_interface),
            "::",
            stringify!(sync)
        )
    );
}
pub type nios_custom_interface_t = nios_custom_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nios_custom_interface {
    pub custom: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut conf_object_t,
            n: uint32,
            a: uint32,
            b: uint32,
            c: uint32,
            rA: uint32,
            rB: uint32,
            readra: bool,
            readrb: bool,
            writerc: bool,
        ) -> uint32,
    >,
}
#[test]
fn bindgen_test_layout_nios_custom_interface() {
    const UNINIT: ::std::mem::MaybeUninit<nios_custom_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nios_custom_interface>(),
        8usize,
        concat!("Size of: ", stringify!(nios_custom_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<nios_custom_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(nios_custom_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nios_custom_interface),
            "::",
            stringify!(custom)
        )
    );
}
pub type sparc_v8_interface_t = sparc_v8_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sparc_v8_interface {
    pub read_window_register: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            window: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
        ) -> uint64,
    >,
    pub write_window_register: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut conf_object_t,
            window: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
            value: uint64,
        ),
    >,
    pub power_down: ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_sparc_v8_interface() {
    const UNINIT: ::std::mem::MaybeUninit<sparc_v8_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sparc_v8_interface>(),
        24usize,
        concat!("Size of: ", stringify!(sparc_v8_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<sparc_v8_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(sparc_v8_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_window_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_v8_interface),
            "::",
            stringify!(read_window_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_window_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_v8_interface),
            "::",
            stringify!(write_window_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).power_down) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_v8_interface),
            "::",
            stringify!(power_down)
        )
    );
}
pub type sparc_v8_ecc_fault_injection_interface_t = sparc_v8_ecc_fault_injection_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sparc_v8_ecc_fault_injection_interface {
    pub inject_instr_access_exception:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub inject_data_access_exception:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
    pub inject_reg_access_error:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_sparc_v8_ecc_fault_injection_interface() {
    const UNINIT: ::std::mem::MaybeUninit<sparc_v8_ecc_fault_injection_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sparc_v8_ecc_fault_injection_interface>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sparc_v8_ecc_fault_injection_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sparc_v8_ecc_fault_injection_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sparc_v8_ecc_fault_injection_interface)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inject_instr_access_exception) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_v8_ecc_fault_injection_interface),
            "::",
            stringify!(inject_instr_access_exception)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inject_data_access_exception) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_v8_ecc_fault_injection_interface),
            "::",
            stringify!(inject_data_access_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inject_reg_access_error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_v8_ecc_fault_injection_interface),
            "::",
            stringify!(inject_reg_access_error)
        )
    );
}
pub type i8051_interrupt_interface_t = i8051_interrupt_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i8051_interrupt_interface {
    pub active_interrupt: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub reti: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub suppress_irq:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, addr: uint32) -> bool>,
}
#[test]
fn bindgen_test_layout_i8051_interrupt_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i8051_interrupt_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i8051_interrupt_interface>(),
        24usize,
        concat!("Size of: ", stringify!(i8051_interrupt_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i8051_interrupt_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i8051_interrupt_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i8051_interrupt_interface),
            "::",
            stringify!(active_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reti) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i8051_interrupt_interface),
            "::",
            stringify!(reti)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suppress_irq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i8051_interrupt_interface),
            "::",
            stringify!(suppress_irq)
        )
    );
}
pub type i8051_timer_interface_t = i8051_timer_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i8051_timer_interface {
    pub change_mode:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, mode: uint8)>,
    pub switch_timer: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, caller: uint8, onoff: bool),
    >,
}
#[test]
fn bindgen_test_layout_i8051_timer_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i8051_timer_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i8051_timer_interface>(),
        16usize,
        concat!("Size of: ", stringify!(i8051_timer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i8051_timer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i8051_timer_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i8051_timer_interface),
            "::",
            stringify!(change_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switch_timer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i8051_timer_interface),
            "::",
            stringify!(switch_timer)
        )
    );
}
extern "C" {
    pub fn VT_register_new_code_block_listener(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                start: *mut ::std::os::raw::c_void,
                len: usize,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct prop_desc_t {
    #[doc = " The version of the struct used"]
    pub abi_version: ::std::os::raw::c_uint,
    #[doc = " for debugging purposes"]
    pub name: *const ::std::os::raw::c_char,
    pub free_data: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_prop_desc_t() {
    const UNINIT: ::std::mem::MaybeUninit<prop_desc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<prop_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(prop_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<prop_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(prop_desc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(prop_desc_t),
            "::",
            stringify!(abi_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(prop_desc_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(prop_desc_t),
            "::",
            stringify!(free_data)
        )
    );
}
impl Default for prop_desc_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type prop_id_t = *const prop_desc_t;
extern "C" {
    pub fn VT_set_object_prop(
        obj: *mut conf_object_t,
        prop: prop_id_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VT_get_object_prop(
        obj: *const conf_object_t,
        prop: prop_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub const serial_peripheral_interface_flags_SPI_Flags_CPHA: serial_peripheral_interface_flags = 1;
pub const serial_peripheral_interface_flags_SPI_Flags_CPOL: serial_peripheral_interface_flags = 2;
pub type serial_peripheral_interface_flags = ::std::os::raw::c_uint;
pub use self::serial_peripheral_interface_flags as serial_peripheral_interface_flags_t;
pub type serial_peripheral_interface_master_interface_t =
    serial_peripheral_interface_master_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct serial_peripheral_interface_master_interface {
    pub spi_response: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bits: ::std::os::raw::c_int,
            payload: *mut dbuffer_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_serial_peripheral_interface_master_interface() {
    const UNINIT: ::std::mem::MaybeUninit<serial_peripheral_interface_master_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<serial_peripheral_interface_master_interface>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(serial_peripheral_interface_master_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<serial_peripheral_interface_master_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(serial_peripheral_interface_master_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spi_response) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_peripheral_interface_master_interface),
            "::",
            stringify!(spi_response)
        )
    );
}
pub type serial_peripheral_interface_slave_interface_t =
    serial_peripheral_interface_slave_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct serial_peripheral_interface_slave_interface {
    pub spi_request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            first: ::std::os::raw::c_int,
            last: ::std::os::raw::c_int,
            bits: ::std::os::raw::c_int,
            payload: *mut dbuffer_t,
        ),
    >,
    pub connect_master: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            master: *mut conf_object_t,
            port: *const ::std::os::raw::c_char,
            flags: serial_peripheral_interface_flags_t,
        ),
    >,
    pub disconnect_master: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, master: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_serial_peripheral_interface_slave_interface() {
    const UNINIT: ::std::mem::MaybeUninit<serial_peripheral_interface_slave_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<serial_peripheral_interface_slave_interface>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(serial_peripheral_interface_slave_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<serial_peripheral_interface_slave_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(serial_peripheral_interface_slave_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spi_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_peripheral_interface_slave_interface),
            "::",
            stringify!(spi_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_master) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_peripheral_interface_slave_interface),
            "::",
            stringify!(connect_master)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect_master) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_peripheral_interface_slave_interface),
            "::",
            stringify!(disconnect_master)
        )
    );
}
pub type datagram_link_interface_t = datagram_link_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct datagram_link_interface {
    #[doc = " Transmit a message to the object."]
    pub receive: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, msg: bytes_t)>,
}
#[test]
fn bindgen_test_layout_datagram_link_interface() {
    const UNINIT: ::std::mem::MaybeUninit<datagram_link_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<datagram_link_interface>(),
        8usize,
        concat!("Size of: ", stringify!(datagram_link_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<datagram_link_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(datagram_link_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(datagram_link_interface),
            "::",
            stringify!(receive)
        )
    );
}
#[doc = " <add id=\"x86_cstate_interface_t\">\n\nThe methods in this interface can be used to read or change the current\npower state the CPU is in. A state value of 0 corresponds to C0, a value of\n1 corresponds to C1, etc. HLT will be reported as state 1, substate 0.\nMWAIT will reported based upon the eax hint, decoded as state = (eax[7:4] +\n1) mod 16, substate = eax[3:0].\n\n<fun>set_cstate</fun> will perform side-effects such as putting the\nprocessor to sleep or waking it up, and call the registered cstate\nlisteners.\n\n<insert-until text=\"// ADD INTERFACE x86_cstate_interface\"/>\n\n</add>\n<add id=\"x86_cstate_interface_exec_context\">\nCell Context for all methods.\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_cstate_t {
    pub state: uint32,
    pub sub_state: uint32,
}
#[test]
fn bindgen_test_layout_x86_cstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<x86_cstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_cstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(x86_cstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(x86_cstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cstate_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cstate_t),
            "::",
            stringify!(sub_state)
        )
    );
}
pub type x86_cstate_interface_t = x86_cstate_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_cstate_interface {
    pub get_cstate:
        ::std::option::Option<unsafe extern "C" fn(cpu_obj: *mut conf_object_t) -> x86_cstate_t>,
    pub set_cstate: ::std::option::Option<
        unsafe extern "C" fn(cpu_obj: *mut conf_object_t, state: uint32, sub_state: uint32),
    >,
}
#[test]
fn bindgen_test_layout_x86_cstate_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_cstate_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_cstate_interface>(),
        16usize,
        concat!("Size of: ", stringify!(x86_cstate_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cstate_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_cstate_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cstate_interface),
            "::",
            stringify!(get_cstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cstate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cstate_interface),
            "::",
            stringify!(set_cstate)
        )
    );
}
pub type x86_pkg_cstate_interface_t = x86_pkg_cstate_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_pkg_cstate_interface {
    pub get_pkg_cstate:
        ::std::option::Option<unsafe extern "C" fn(cpu_obj: *mut conf_object_t) -> x86_cstate_t>,
    pub set_pkg_cstate: ::std::option::Option<
        unsafe extern "C" fn(cpu_obj: *mut conf_object_t, state: uint32, sub_state: uint32),
    >,
    pub pkg_cstate_update:
        ::std::option::Option<unsafe extern "C" fn(cpu_obj: *mut conf_object_t, notify: bool)>,
}
#[test]
fn bindgen_test_layout_x86_pkg_cstate_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_pkg_cstate_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_pkg_cstate_interface>(),
        24usize,
        concat!("Size of: ", stringify!(x86_pkg_cstate_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_pkg_cstate_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_pkg_cstate_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_pkg_cstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_pkg_cstate_interface),
            "::",
            stringify!(get_pkg_cstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_pkg_cstate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_pkg_cstate_interface),
            "::",
            stringify!(set_pkg_cstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkg_cstate_update) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_pkg_cstate_interface),
            "::",
            stringify!(pkg_cstate_update)
        )
    );
}
pub type x86_cstate_notification_interface_t = x86_cstate_notification_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct x86_cstate_notification_interface {
    pub notification: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut conf_object_t,
            cpu: *mut conf_object_t,
            state: uint32,
            sub_state: uint32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_x86_cstate_notification_interface() {
    const UNINIT: ::std::mem::MaybeUninit<x86_cstate_notification_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x86_cstate_notification_interface>(),
        8usize,
        concat!("Size of: ", stringify!(x86_cstate_notification_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cstate_notification_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x86_cstate_notification_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cstate_notification_interface),
            "::",
            stringify!(notification)
        )
    );
}
pub type serial_device_interface_t = serial_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct serial_device_interface {
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub receive_ready: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_serial_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<serial_device_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<serial_device_interface>(),
        16usize,
        concat!("Size of: ", stringify!(serial_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<serial_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(serial_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_device_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_ready) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_device_interface),
            "::",
            stringify!(receive_ready)
        )
    );
}
pub type extended_serial_interface_t = extended_serial_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct extended_serial_interface {
    pub write_at: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            value: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            fg: ::std::os::raw::c_int,
            bg: ::std::os::raw::c_int,
        ),
    >,
    pub graphics_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, in_graphics_mode: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_extended_serial_interface() {
    const UNINIT: ::std::mem::MaybeUninit<extended_serial_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<extended_serial_interface>(),
        16usize,
        concat!("Size of: ", stringify!(extended_serial_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<extended_serial_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(extended_serial_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_at) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(extended_serial_interface),
            "::",
            stringify!(write_at)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphics_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(extended_serial_interface),
            "::",
            stringify!(graphics_mode)
        )
    );
}
pub type rs232_device_interface_t = rs232_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rs232_device_interface {
    #[doc = " Flow control lines"]
    pub cts: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
    pub dsr: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
    #[doc = " Ring indicator"]
    pub ring: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
    #[doc = " Carrier detect"]
    pub carrier: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
    #[doc = " Break"]
    pub got_break: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " Frame error"]
    pub got_frame_error: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_rs232_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<rs232_device_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rs232_device_interface>(),
        48usize,
        concat!("Size of: ", stringify!(rs232_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<rs232_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(rs232_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_device_interface),
            "::",
            stringify!(cts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_device_interface),
            "::",
            stringify!(dsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_device_interface),
            "::",
            stringify!(ring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).carrier) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_device_interface),
            "::",
            stringify!(carrier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).got_break) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_device_interface),
            "::",
            stringify!(got_break)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).got_frame_error) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_device_interface),
            "::",
            stringify!(got_frame_error)
        )
    );
}
pub const stop_bits_t_Stop_Bits_1: stop_bits_t = 0;
pub const stop_bits_t_Stop_Bits_1p5: stop_bits_t = 1;
pub const stop_bits_t_Stop_Bits_2: stop_bits_t = 2;
#[doc = " <add id=\"rs232_console_interface_t\">\nCurrently Simics internal.\n\n<insert-until text=\"// ADD INTERFACE rs232_console_interface\"/>\n\n</add>\n<add id=\"rs232_console_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type stop_bits_t = ::std::os::raw::c_uint;
pub const parity_mode_t_Parity_None: parity_mode_t = 0;
pub const parity_mode_t_Parity_Even: parity_mode_t = 1;
pub const parity_mode_t_Parity_Odd: parity_mode_t = 2;
pub type parity_mode_t = ::std::os::raw::c_uint;
pub type rs232_console_interface_t = rs232_console_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rs232_console_interface {
    #[doc = " Set line parameters"]
    pub set_baudrate: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            rate: ::std::os::raw::c_int,
            commit: ::std::os::raw::c_int,
        ),
    >,
    pub set_data_bits: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bits: ::std::os::raw::c_int,
            commit: ::std::os::raw::c_int,
        ),
    >,
    pub set_stop_bits: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            stop_bits: stop_bits_t,
            commit: ::std::os::raw::c_int,
        ),
    >,
    pub set_parity_mode: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            parity_mode: parity_mode_t,
            commit: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Flow control lines"]
    pub set_dtr: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
    pub set_rts: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
    #[doc = " Break"]
    pub set_break: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, status: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_rs232_console_interface() {
    const UNINIT: ::std::mem::MaybeUninit<rs232_console_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rs232_console_interface>(),
        56usize,
        concat!("Size of: ", stringify!(rs232_console_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<rs232_console_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(rs232_console_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_baudrate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_baudrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_data_bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_data_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_stop_bits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_stop_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_parity_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_parity_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_dtr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_dtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_rts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_rts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_break) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rs232_console_interface),
            "::",
            stringify!(set_break)
        )
    );
}
#[doc = " <add id=\"pci_memory_transaction_t DOC\">\n<ndx>pci_memory_transaction_t</ndx>\n<doc>\n<doc-item name=\"NAME\">pci_memory_transaction_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"pci_memory_transaction_t def\"/>\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\n\nThe <type>pci_memory_transaction_t</type> is used for memory accesses\ninitiated by PCI devices.\n\n<note>All struct fields are internal and should never be used\ndirectly.</note>\n\nA <type>generic_transaction_t</type> can be converted to a\n<type>pci_memory_transaction_t</type> via the\n<fun>SIM_pci_mem_trans_from_generic()</fun> function. Never explicitly cast\none struct to the other, always use the Simics API functions.</doc-item>\n<doc-item name=\"SEE ALSO\">\n<fun>SIM_pci_mem_trans_from_generic</fun>,\n<type>generic_transaction_t</type>\n</doc-item>\n</doc></add>\n\n<add-type id=\"pci_memory_transaction_t def\"></add-type>"]
pub type pci_memory_transaction_t = pci_memory_transaction;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_memory_transaction {
    pub _internal_s: generic_transaction_t,
    pub _internal_original_size: uint32,
    pub _internal_bus_address: ::std::os::raw::c_int,
    pub _internal_bus_number: ::std::os::raw::c_int,
    pub _internal_device_number: ::std::os::raw::c_int,
    pub _internal_function_number: ::std::os::raw::c_int,
    pub _internal_tlp_prefix: uint32,
}
#[test]
fn bindgen_test_layout_pci_memory_transaction() {
    const UNINIT: ::std::mem::MaybeUninit<pci_memory_transaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_memory_transaction>(),
        128usize,
        concat!("Size of: ", stringify!(pci_memory_transaction))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_memory_transaction>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_memory_transaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_original_size) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_original_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_bus_address) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_bus_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_bus_number) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_bus_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_device_number) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_device_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_function_number) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_function_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._internal_tlp_prefix) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_memory_transaction),
            "::",
            stringify!(_internal_tlp_prefix)
        )
    );
}
impl Default for pci_memory_transaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " The documentation for these EXPORTED methods are in mop.c and in the API RM"]
    pub fn SIM_pci_mem_trans_from_generic(
        mop: *mut generic_transaction_t,
    ) -> *mut pci_memory_transaction_t;
}
extern "C" {
    pub fn VT_get_pci_mem_op_requester_id(mop: *const pci_memory_transaction_t) -> uint16;
}
extern "C" {
    pub fn VT_get_pci_mem_op_tlp_prefix(mop: *const pci_memory_transaction_t) -> uint32;
}
extern "C" {
    pub fn VT_set_pci_mem_op_tlp_prefix(mop: *mut pci_memory_transaction_t, tlp_prefix: uint32);
}
pub type pci_device_interface_t = pci_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_device_interface {
    pub bus_reset: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " Deprecated; interrupt_acknowledge, special_cycle"]
    pub _deprecated_interrupt_acknowledge: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub _deprecated_special_cycle:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint32)>,
    #[doc = " System Error"]
    pub system_error: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " peer-to-peer interrupt mechanism"]
    pub interrupt_raised: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, pin: ::std::os::raw::c_int),
    >,
    pub interrupt_lowered: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, pin: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_pci_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_device_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_device_interface>(),
        48usize,
        concat!("Size of: ", stringify!(pci_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus_reset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_device_interface),
            "::",
            stringify!(bus_reset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._deprecated_interrupt_acknowledge) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_device_interface),
            "::",
            stringify!(_deprecated_interrupt_acknowledge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._deprecated_special_cycle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_device_interface),
            "::",
            stringify!(_deprecated_special_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_error) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_device_interface),
            "::",
            stringify!(system_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_raised) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_device_interface),
            "::",
            stringify!(interrupt_raised)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_lowered) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_device_interface),
            "::",
            stringify!(interrupt_lowered)
        )
    );
}
pub type pci_bus_interface_t = pci_bus_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_bus_interface {
    #[doc = " Deprecated; memory_access"]
    pub memory_access: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_op: *mut generic_transaction_t,
        ) -> exception_type_t,
    >,
    pub raise_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dev: *mut conf_object_t,
            pin: ::std::os::raw::c_int,
        ),
    >,
    pub lower_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dev: *mut conf_object_t,
            pin: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Deprecated; interrupt_acknowledge"]
    pub interrupt_acknowledge: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub add_map: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dev: *mut conf_object_t,
            space: addr_space_t,
            target: *mut conf_object_t,
            info: map_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub remove_map: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dev: *mut conf_object_t,
            space: addr_space_t,
            function: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_bus_number: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bus_id: ::std::os::raw::c_int),
    >,
    pub set_sub_bus_number: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bus_id: ::std::os::raw::c_int),
    >,
    #[doc = " Deprecated; add_default, remove_default"]
    pub add_default: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dev: *mut conf_object_t,
            space: addr_space_t,
            target: *mut conf_object_t,
            info: map_info_t,
        ),
    >,
    pub remove_default:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, space: addr_space_t)>,
    pub bus_reset: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " Deprecated; special_cycle"]
    pub special_cycle:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint32)>,
    pub system_error: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub get_bus_address: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dev: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_device_status: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            device: ::std::os::raw::c_int,
            function: ::std::os::raw::c_int,
            enabled: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Memory spaces"]
    pub configuration_space:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub io_space:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub memory_space:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
}
#[test]
fn bindgen_test_layout_pci_bus_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_bus_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_bus_interface>(),
        144usize,
        concat!("Size of: ", stringify!(pci_bus_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_bus_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_bus_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(memory_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raise_interrupt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(raise_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_interrupt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(lower_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_acknowledge) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(interrupt_acknowledge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_map) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(add_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_map) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(remove_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_bus_number) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(set_bus_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_sub_bus_number) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(set_sub_bus_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_default) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(add_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_default) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(remove_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus_reset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(bus_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).special_cycle) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(special_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_error) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(system_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_bus_address) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(get_bus_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_device_status) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(set_device_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).configuration_space) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(configuration_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_space) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(io_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_space) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bus_interface),
            "::",
            stringify!(memory_space)
        )
    );
}
pub type pci_upstream_interface_t = pci_upstream_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_upstream_interface {
    pub operation: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_op: *mut generic_transaction_t,
            space: addr_space_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_pci_upstream_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_upstream_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_upstream_interface>(),
        8usize,
        concat!("Size of: ", stringify!(pci_upstream_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_upstream_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_upstream_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_upstream_interface),
            "::",
            stringify!(operation)
        )
    );
}
pub type pci_upstream_operation_interface_t = pci_upstream_operation_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_upstream_operation_interface {
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            rid: uint16,
            space: addr_space_t,
            address: physical_address_t,
            buffer: buffer_t,
        ) -> exception_type_t,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            rid: uint16,
            space: addr_space_t,
            address: physical_address_t,
            buffer: bytes_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_pci_upstream_operation_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_upstream_operation_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_upstream_operation_interface>(),
        16usize,
        concat!("Size of: ", stringify!(pci_upstream_operation_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_upstream_operation_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pci_upstream_operation_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_upstream_operation_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_upstream_operation_interface),
            "::",
            stringify!(write)
        )
    );
}
pub type pci_downstream_interface_t = pci_downstream_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_downstream_interface {
    pub operation: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mem_op: *mut generic_transaction_t,
            space: addr_space_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_pci_downstream_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_downstream_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_downstream_interface>(),
        8usize,
        concat!("Size of: ", stringify!(pci_downstream_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_downstream_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_downstream_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_downstream_interface),
            "::",
            stringify!(operation)
        )
    );
}
pub type pci_bridge_interface_t = pci_bridge_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_bridge_interface {
    pub system_error: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub raise_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pci_bus: *mut conf_object_t,
            device: ::std::os::raw::c_int,
            pin: ::std::os::raw::c_int,
        ),
    >,
    pub lower_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pci_bus: *mut conf_object_t,
            device: ::std::os::raw::c_int,
            pin: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_pci_bridge_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_bridge_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_bridge_interface>(),
        24usize,
        concat!("Size of: ", stringify!(pci_bridge_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_bridge_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_bridge_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bridge_interface),
            "::",
            stringify!(system_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raise_interrupt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bridge_interface),
            "::",
            stringify!(raise_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_interrupt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_bridge_interface),
            "::",
            stringify!(lower_interrupt)
        )
    );
}
pub type pci_interrupt_interface_t = pci_interrupt_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_interrupt_interface {
    pub raise_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pci_bus: *mut conf_object_t,
            device: ::std::os::raw::c_int,
            pin: ::std::os::raw::c_int,
        ),
    >,
    pub lower_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            pci_bus: *mut conf_object_t,
            device: ::std::os::raw::c_int,
            pin: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_pci_interrupt_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_interrupt_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_interrupt_interface>(),
        16usize,
        concat!("Size of: ", stringify!(pci_interrupt_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_interrupt_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_interrupt_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raise_interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_interrupt_interface),
            "::",
            stringify!(raise_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_interrupt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_interrupt_interface),
            "::",
            stringify!(lower_interrupt)
        )
    );
}
#[doc = " As encoded in the PCIe spec; Interrupt Pin register"]
pub const pci_interrupt_pin_t_PCI_INTERRUPT_INTA: pci_interrupt_pin_t = 1;
#[doc = " As encoded in the PCIe spec; Interrupt Pin register"]
pub const pci_interrupt_pin_t_PCI_INTERRUPT_INTB: pci_interrupt_pin_t = 2;
#[doc = " As encoded in the PCIe spec; Interrupt Pin register"]
pub const pci_interrupt_pin_t_PCI_INTERRUPT_INTC: pci_interrupt_pin_t = 3;
#[doc = " As encoded in the PCIe spec; Interrupt Pin register"]
pub const pci_interrupt_pin_t_PCI_INTERRUPT_INTD: pci_interrupt_pin_t = 4;
#[doc = "<add-type id=\"pci_interrupt_pin_t def\">\n</add-type>"]
pub type pci_interrupt_pin_t = ::std::os::raw::c_uint;
#[doc = " Address Translation"]
pub const pcie_message_type_t_PCIE_ATS_Invalidate: pcie_message_type_t = 1;
#[doc = " Address Translation"]
pub const pcie_message_type_t_PCIE_PRS_Request: pcie_message_type_t = 4;
#[doc = " Address Translation"]
pub const pcie_message_type_t_PCIE_PRS_Response: pcie_message_type_t = 5;
#[doc = " Address Translation"]
pub const pcie_message_type_t_PCIE_Latency_Tolerance_Reporting: pcie_message_type_t = 16;
#[doc = " Address Translation"]
pub const pcie_message_type_t_PCIE_Optimized_Buffer_Flush_Fill: pcie_message_type_t = 18;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Assert_INTA: pcie_message_type_t = 32;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Assert_INTB: pcie_message_type_t = 33;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Assert_INTC: pcie_message_type_t = 34;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Assert_INTD: pcie_message_type_t = 35;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Deassert_INTA: pcie_message_type_t = 36;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Deassert_INTB: pcie_message_type_t = 37;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Deassert_INTC: pcie_message_type_t = 38;
#[doc = " INTx emulation"]
pub const pcie_message_type_t_PCIE_Msg_Deassert_INTD: pcie_message_type_t = 39;
#[doc = " Power Management"]
pub const pcie_message_type_t_PCIE_PM_Active_State_Nak: pcie_message_type_t = 20;
#[doc = " Power Management"]
pub const pcie_message_type_t_PCIE_PM_PME: pcie_message_type_t = 24;
#[doc = " Power Management"]
pub const pcie_message_type_t_PCIE_PM_Turn_Off: pcie_message_type_t = 25;
#[doc = " Power Management"]
pub const pcie_message_type_t_PCIE_PM_PME_TO_Ack: pcie_message_type_t = 27;
#[doc = " Error Messages"]
pub const pcie_message_type_t_PCIE_ERR_COR: pcie_message_type_t = 48;
#[doc = " Error Messages"]
pub const pcie_message_type_t_PCIE_ERR_NONFATAL: pcie_message_type_t = 49;
#[doc = " Error Messages"]
pub const pcie_message_type_t_PCIE_ERR_FATAL: pcie_message_type_t = 51;
#[doc = " Locked Transaction"]
pub const pcie_message_type_t_PCIE_Unlock: pcie_message_type_t = 0;
#[doc = " Slot Power Limit"]
pub const pcie_message_type_t_PCIE_Set_Slot_Power_Limit: pcie_message_type_t = 80;
#[doc = " Slot Power Limit"]
pub const pcie_message_type_t_PCIE_Precision_Time_Measurement: pcie_message_type_t = 82;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Power_Indicator_On: pcie_message_type_t = 69;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Power_Indicator_Blink: pcie_message_type_t = 71;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Power_Indicator_Off: pcie_message_type_t = 68;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Attention_Button_Pressed: pcie_message_type_t = 72;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Attention_Indicator_On: pcie_message_type_t = 65;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Attention_Indicator_Blink: pcie_message_type_t = 67;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_HP_Attention_Indicator_Off: pcie_message_type_t = 64;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_Vendor_Defined_Type_0: pcie_message_type_t = 126;
#[doc = " Hot Plug Messages"]
pub const pcie_message_type_t_PCIE_Vendor_Defined_Type_1: pcie_message_type_t = 127;
#[doc = " legacy name for PCIE_Unlock"]
pub const pcie_message_type_t_PCIE_Locked_Transaction: pcie_message_type_t = 0;
#[doc = " Data Link Layer (virtual) Messages\n\nNOTE: these messages only exist on Simics simulator, as they are\nnormally part of the Data Link Layer which is below the level of\nabstraction for Simics PCIe models\n\nAccording to PCIe rev 2.0, when a target receives a message that it\ndoes not recognize or support, except for the \"Vendor Defined Type\n1\" message, it should treat the request as an \"Unsupported Request\"\nand report it accordingly (see sec 2.3.1 for reference).\n\nHence models that comply with rev 2.0 must be updated to either\n1) handle these messages or 2) ignore these messages.\n\nIdeally we would like to use a new pcie_link interface to transmit\nthis information - see bug 17849 for more info."]
pub const pcie_message_type_t_PCIE_DLL_Link_Down: pcie_message_type_t = -1;
#[doc = " Data Link Layer (virtual) Messages\n\nNOTE: these messages only exist on Simics simulator, as they are\nnormally part of the Data Link Layer which is below the level of\nabstraction for Simics PCIe models\n\nAccording to PCIe rev 2.0, when a target receives a message that it\ndoes not recognize or support, except for the \"Vendor Defined Type\n1\" message, it should treat the request as an \"Unsupported Request\"\nand report it accordingly (see sec 2.3.1 for reference).\n\nHence models that comply with rev 2.0 must be updated to either\n1) handle these messages or 2) ignore these messages.\n\nIdeally we would like to use a new pcie_link interface to transmit\nthis information - see bug 17849 for more info."]
pub const pcie_message_type_t_PCIE_DLL_Link_Up: pcie_message_type_t = -2;
#[doc = "<add-type id=\"pcie_message_type_t def\">\n</add-type>"]
pub type pcie_message_type_t = ::std::os::raw::c_int;
pub type pci_express_interface_t = pci_express_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_express_interface {
    pub send_message: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut conf_object_t,
            src: *mut conf_object_t,
            type_: pcie_message_type_t,
            payload: byte_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_pci_express_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_express_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_express_interface>(),
        8usize,
        concat!("Size of: ", stringify!(pci_express_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_express_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_express_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_express_interface),
            "::",
            stringify!(send_message)
        )
    );
}
pub type pci_express_hotplug_interface_t = pci_express_hotplug_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_express_hotplug_interface {
    #[doc = " This is sent when a device is added or removed from the bus."]
    pub presence_change: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut conf_object_t,
            src: *mut conf_object_t,
            is_present: ::std::os::raw::c_int,
        ),
    >,
    pub inject_power_fault: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub press_attention_button:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub set_mrl_state: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, locked: ::std::os::raw::c_int),
    >,
    pub get_mrl_state: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_pci_express_hotplug_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_express_hotplug_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_express_hotplug_interface>(),
        40usize,
        concat!("Size of: ", stringify!(pci_express_hotplug_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_express_hotplug_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_express_hotplug_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presence_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_express_hotplug_interface),
            "::",
            stringify!(presence_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inject_power_fault) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_express_hotplug_interface),
            "::",
            stringify!(inject_power_fault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).press_attention_button) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_express_hotplug_interface),
            "::",
            stringify!(press_attention_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_mrl_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_express_hotplug_interface),
            "::",
            stringify!(set_mrl_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mrl_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_express_hotplug_interface),
            "::",
            stringify!(get_mrl_state)
        )
    );
}
pub type pci_multi_function_device_interface_t = pci_multi_function_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pci_multi_function_device_interface {
    pub supported_functions:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_pci_multi_function_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pci_multi_function_device_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pci_multi_function_device_interface>(),
        8usize,
        concat!("Size of: ", stringify!(pci_multi_function_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_multi_function_device_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pci_multi_function_device_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_functions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_multi_function_device_interface),
            "::",
            stringify!(supported_functions)
        )
    );
}
pub const pcie_type_t_PCIE_Type_Not_Set: pcie_type_t = 0;
pub const pcie_type_t_PCIE_Type_Mem: pcie_type_t = 1;
pub const pcie_type_t_PCIE_Type_IO: pcie_type_t = 2;
pub const pcie_type_t_PCIE_Type_Cfg: pcie_type_t = 3;
pub const pcie_type_t_PCIE_Type_Msg: pcie_type_t = 4;
pub const pcie_type_t_PCIE_Type_Other: pcie_type_t = 5;
#[doc = " <add id=\"pcie_device_interface_t\">\n\nThis interface must be implemented by all PCIe devices that can receive\ndownstream transactions.\n\n<fun>connected</fun> and <fun>disconnected</fun> are used to indicate that\nthe device is (dis)connected to <arg>port_obj</arg> with device id\n<arg>device_id</arg> and may use the <iface>pcie_map</iface> interface to\nadd/remove functions and claim/release other resources\n\n<fun>hot_reset</fun> is used to indicate that a Hot Reset has been signaled\non the PCIe link to which the device is connected. It is up to the device to\nreset functions and other resources mapped using the <iface>pcie_map</iface>\ninterface.\n\nNote: This interface is considered tech-preview and may change without\nnotice.\n\n<insert-until text=\"// ADD INTERFACE pcie_device_interface\"/>\n</add>\n\n<add id=\"pcie_device_interface_exec_context\">\nGlobal Context for all methods.\n</add>"]
pub type pcie_type_t = ::std::os::raw::c_uint;
pub type pcie_device_interface_t = pcie_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pcie_device_interface {
    pub connected: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            port_obj: *mut conf_object_t,
            device_id: uint16,
        ),
    >,
    pub disconnected: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            port_obj: *mut conf_object_t,
            device_id: uint16,
        ),
    >,
    pub hot_reset: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_pcie_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pcie_device_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pcie_device_interface>(),
        24usize,
        concat!("Size of: ", stringify!(pcie_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pcie_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_device_interface),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_device_interface),
            "::",
            stringify!(disconnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hot_reset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_device_interface),
            "::",
            stringify!(hot_reset)
        )
    );
}
pub type pcie_map_interface_t = pcie_map_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pcie_map_interface {
    pub add_map: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            map_obj: *mut conf_object_t,
            nfo: map_info_t,
            type_: pcie_type_t,
        ),
    >,
    pub del_map: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            map_obj: *mut conf_object_t,
            base: physical_address_t,
            type_: pcie_type_t,
        ),
    >,
    pub add_function: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            map_obj: *mut conf_object_t,
            function_id: uint16,
        ),
    >,
    pub del_function: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            map_obj: *mut conf_object_t,
            function_id: uint16,
        ),
    >,
    pub enable_function:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, function_id: uint16)>,
    pub disable_function:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, function_id: uint16)>,
    pub get_device_id: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, dev_obj: *mut conf_object_t) -> uint16,
    >,
}
#[test]
fn bindgen_test_layout_pcie_map_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pcie_map_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pcie_map_interface>(),
        56usize,
        concat!("Size of: ", stringify!(pcie_map_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_map_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pcie_map_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(add_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(del_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(add_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_function) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(del_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_function) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(enable_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_function) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(disable_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_device_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_map_interface),
            "::",
            stringify!(get_device_id)
        )
    );
}
pub type pcie_port_control_interface_t = pcie_port_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pcie_port_control_interface {
    pub set_secondary_bus_number:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint64)>,
    pub hot_reset: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_pcie_port_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<pcie_port_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pcie_port_control_interface>(),
        16usize,
        concat!("Size of: ", stringify!(pcie_port_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_port_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(pcie_port_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_secondary_bus_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_port_control_interface),
            "::",
            stringify!(set_secondary_bus_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hot_reset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_port_control_interface),
            "::",
            stringify!(hot_reset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_type {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_type() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_type> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_type>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_pcie_type))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_type>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_pcie_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_type),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_requester_id {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_requester_id() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_requester_id> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_requester_id>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_pcie_requester_id)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_requester_id>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_requester_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_requester_id),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_device_id {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_device_id() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_device_id> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_device_id>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_pcie_device_id)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_device_id>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_device_id),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_msg_type {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_msg_type() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_msg_type> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_msg_type>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_pcie_msg_type))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_msg_type>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_msg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_msg_type),
            "::",
            stringify!(dummy)
        )
    );
}
pub const pcie_msg_route_t_PCIE_Msg_Route_Not_Set: pcie_msg_route_t = 0;
#[doc = " To RC"]
pub const pcie_msg_route_t_PCIE_Msg_Route_Upstream: pcie_msg_route_t = 1;
#[doc = " IO and Memory"]
pub const pcie_msg_route_t_PCIE_Msg_Route_Address: pcie_msg_route_t = 2;
#[doc = " Messages"]
pub const pcie_msg_route_t_PCIE_Msg_Route_ID: pcie_msg_route_t = 3;
#[doc = " From RC"]
pub const pcie_msg_route_t_PCIE_Msg_Route_Broadcast: pcie_msg_route_t = 4;
#[doc = " INTx"]
pub const pcie_msg_route_t_PCIE_Msg_Route_Terminate: pcie_msg_route_t = 5;
#[doc = " PME_Turn_Off_Ack"]
pub const pcie_msg_route_t_PCIE_Msg_Route_Gather: pcie_msg_route_t = 6;
pub type pcie_msg_route_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_msg_route {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_msg_route() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_msg_route> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_msg_route>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_pcie_msg_route)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_msg_route>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_msg_route)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_msg_route),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_pasid {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_pasid() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_pasid> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_pasid>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_pcie_pasid))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_pasid>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_pasid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_pasid),
            "::",
            stringify!(dummy)
        )
    );
}
pub const pcie_at_t_PCIE_AT_Not_Set: pcie_at_t = 0;
pub const pcie_at_t_PCIE_AT_Untranslated: pcie_at_t = 1;
pub const pcie_at_t_PCIE_AT_Translation_Request: pcie_at_t = 2;
pub const pcie_at_t_PCIE_AT_Translated: pcie_at_t = 3;
pub type pcie_at_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_at {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_at() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_at> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_at>(),
        4usize,
        concat!("Size of: ", stringify!(dummy_semicolon_eater_pcie_at))
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_at>(),
        4usize,
        concat!("Alignment of ", stringify!(dummy_semicolon_eater_pcie_at))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_at),
            "::",
            stringify!(dummy)
        )
    );
}
pub const pcie_error_t_PCIE_Error_Not_Set: pcie_error_t = 0;
pub const pcie_error_t_PCIE_Error_Unsupported_Request: pcie_error_t = 1;
pub const pcie_error_t_PCIE_Error_Completer_Abort: pcie_error_t = 2;
pub const pcie_error_t_PCIE_Error_Master_Abort: pcie_error_t = 3;
pub const pcie_error_t_PCIE_Error_No_Error: pcie_error_t = 4;
pub const pcie_error_t_PCIE_Error_Configuration_Request_Retry_Status: pcie_error_t = 5;
pub type pcie_error_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pcie_error_ret_t {
    pub val: pcie_error_t,
}
#[test]
fn bindgen_test_layout_pcie_error_ret_t() {
    const UNINIT: ::std::mem::MaybeUninit<pcie_error_ret_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pcie_error_ret_t>(),
        4usize,
        concat!("Size of: ", stringify!(pcie_error_ret_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_error_ret_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pcie_error_ret_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_error_ret_t),
            "::",
            stringify!(val)
        )
    );
}
impl Default for pcie_error_ret_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_error_ret {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_error_ret() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_error_ret> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_error_ret>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_pcie_error_ret)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_error_ret>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_error_ret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_error_ret),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct pcie_byte_count_ret_t {
    pub val: uint64,
}
#[test]
fn bindgen_test_layout_pcie_byte_count_ret_t() {
    const UNINIT: ::std::mem::MaybeUninit<pcie_byte_count_ret_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pcie_byte_count_ret_t>(),
        8usize,
        concat!("Size of: ", stringify!(pcie_byte_count_ret_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_byte_count_ret_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pcie_byte_count_ret_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcie_byte_count_ret_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dummy_semicolon_eater_pcie_byte_count_ret {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dummy_semicolon_eater_pcie_byte_count_ret() {
    const UNINIT: ::std::mem::MaybeUninit<dummy_semicolon_eater_pcie_byte_count_ret> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dummy_semicolon_eater_pcie_byte_count_ret>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(dummy_semicolon_eater_pcie_byte_count_ret)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dummy_semicolon_eater_pcie_byte_count_ret>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dummy_semicolon_eater_pcie_byte_count_ret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dummy_semicolon_eater_pcie_byte_count_ret),
            "::",
            stringify!(dummy)
        )
    );
}
pub type mii_management_interface_t = mii_management_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mii_management_interface {
    pub serial_access: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            data_in: ::std::os::raw::c_int,
            clock: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
        ) -> uint16,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
            value: uint16,
        ),
    >,
}
#[test]
fn bindgen_test_layout_mii_management_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mii_management_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mii_management_interface>(),
        24usize,
        concat!("Size of: ", stringify!(mii_management_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mii_management_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mii_management_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mii_management_interface),
            "::",
            stringify!(serial_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mii_management_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mii_management_interface),
            "::",
            stringify!(write_register)
        )
    );
}
pub type mii_interface_t = mii_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mii_interface {
    pub serial_access: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            data_in: ::std::os::raw::c_int,
            clock: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, index: ::std::os::raw::c_int) -> uint16,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, index: ::std::os::raw::c_int, value: uint16),
    >,
}
#[test]
fn bindgen_test_layout_mii_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mii_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mii_interface>(),
        24usize,
        concat!("Size of: ", stringify!(mii_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mii_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mii_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mii_interface),
            "::",
            stringify!(serial_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mii_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mii_interface),
            "::",
            stringify!(write_register)
        )
    );
}
pub type mdio45_bus_interface_t = mdio45_bus_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mdio45_bus_interface {
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            mmd: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
        ) -> uint16,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            mdd: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
            value: uint16,
        ),
    >,
}
#[test]
fn bindgen_test_layout_mdio45_bus_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mdio45_bus_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mdio45_bus_interface>(),
        16usize,
        concat!("Size of: ", stringify!(mdio45_bus_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mdio45_bus_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mdio45_bus_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mdio45_bus_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mdio45_bus_interface),
            "::",
            stringify!(write_register)
        )
    );
}
pub type mdio45_phy_interface_t = mdio45_phy_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct mdio45_phy_interface {
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mmd: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
        ) -> uint16,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mmd: ::std::os::raw::c_int,
            reg: ::std::os::raw::c_int,
            value: uint16,
        ),
    >,
}
#[test]
fn bindgen_test_layout_mdio45_phy_interface() {
    const UNINIT: ::std::mem::MaybeUninit<mdio45_phy_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mdio45_phy_interface>(),
        16usize,
        concat!("Size of: ", stringify!(mdio45_phy_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<mdio45_phy_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(mdio45_phy_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mdio45_phy_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mdio45_phy_interface),
            "::",
            stringify!(write_register)
        )
    );
}
pub type simple_interrupt_interface_t = simple_interrupt_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct simple_interrupt_interface {
    pub interrupt: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
    pub interrupt_clear: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_simple_interrupt_interface() {
    const UNINIT: ::std::mem::MaybeUninit<simple_interrupt_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simple_interrupt_interface>(),
        16usize,
        concat!("Size of: ", stringify!(simple_interrupt_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<simple_interrupt_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(simple_interrupt_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simple_interrupt_interface),
            "::",
            stringify!(interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_clear) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(simple_interrupt_interface),
            "::",
            stringify!(interrupt_clear)
        )
    );
}
#[doc = "This interrupt_query interface is used by devices connected to interrupt\ncontrollers to query whether their irq level is enabled in the interrupt\ncontroller or not. This is done by the is_enabled function.\n\nIt can also be used to register a callback function to be called when the\nirq is enabled or disabled through the register_callback function.\n\nThis is very old design, do not use in new models!"]
pub type interrupt_changed_state_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        interrupt_controller: *mut conf_object_t,
        device: *mut conf_object_t,
        irq_level: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type interrupt_query_interface_t = interrupt_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interrupt_query_interface {
    pub is_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            interrupt_controller: *mut conf_object_t,
            irq_level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub register_callback: ::std::option::Option<
        unsafe extern "C" fn(
            interrupt_controller: *mut conf_object_t,
            device: *mut conf_object_t,
            irq_level: ::std::os::raw::c_int,
            cb: interrupt_changed_state_callback_t,
            cb_data: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_interrupt_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<interrupt_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interrupt_query_interface>(),
        16usize,
        concat!("Size of: ", stringify!(interrupt_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<interrupt_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(interrupt_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_query_interface),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_query_interface),
            "::",
            stringify!(register_callback)
        )
    );
}
#[doc = " obsolete typedefs kept for compatibility"]
pub type device_interrupt_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut conf_object_t, arg2: ::std::os::raw::c_int),
>;
pub type device_interrupt_clear_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut conf_object_t, arg2: ::std::os::raw::c_int),
>;
pub type interrupt_query_register_t = ::std::option::Option<
    unsafe extern "C" fn(
        interrupt_controller: *mut conf_object_t,
        device: *mut conf_object_t,
        irq_level: ::std::os::raw::c_int,
        cb: interrupt_changed_state_callback_t,
        cb_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type interrupt_query_enabled_t = ::std::option::Option<
    unsafe extern "C" fn(
        interrupt_controller: *mut conf_object_t,
        irq_level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <add-type id=\"telemetry_class_id_t def\"> </add-type>"]
pub type telemetry_class_id_t = ::std::os::raw::c_int;
#[doc = " <add-type id=\"telemetry_id_t def\"> </add-type>"]
pub type telemetry_id_t = ::std::os::raw::c_int;
pub type telemetry_interface_t = telemetry_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct telemetry_interface {
    pub get_telemetry_class_id: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_name: *const ::std::os::raw::c_char,
        ) -> telemetry_class_id_t,
    >,
    pub get_telemetry_class_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_id: telemetry_class_id_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_telemetry_class_description: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_id: telemetry_class_id_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_telemetry_id: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_id: telemetry_class_id_t,
            telemetry_name: *const ::std::os::raw::c_char,
        ) -> telemetry_id_t,
    >,
    pub get_telemetry_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_id: telemetry_class_id_t,
            telemetry_id: telemetry_id_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_telemetry_description: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_id: telemetry_class_id_t,
            telemetry_id: telemetry_id_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            telemetry_class_id: telemetry_class_id_t,
            telemetry_id: telemetry_id_t,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_telemetry_interface() {
    const UNINIT: ::std::mem::MaybeUninit<telemetry_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<telemetry_interface>(),
        56usize,
        concat!("Size of: ", stringify!(telemetry_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<telemetry_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(telemetry_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_telemetry_class_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_telemetry_class_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_telemetry_class_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_telemetry_class_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_telemetry_class_description) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_telemetry_class_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_telemetry_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_telemetry_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_telemetry_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_telemetry_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_telemetry_description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_telemetry_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(telemetry_interface),
            "::",
            stringify!(get_value)
        )
    );
}
pub const apic_destination_mode_t_Apic_Destination_Mode_Physical: apic_destination_mode_t = 0;
pub const apic_destination_mode_t_Apic_Destination_Mode_Logical: apic_destination_mode_t = 1;
#[doc = " <add-type id=\"apic_destination_mode_t\"> </add-type>"]
pub type apic_destination_mode_t = ::std::os::raw::c_uint;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_Fixed: apic_delivery_mode_t = 0;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_Lowest_Priority: apic_delivery_mode_t = 1;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_SMI: apic_delivery_mode_t = 2;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_Remote_Read: apic_delivery_mode_t = 3;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_NMI: apic_delivery_mode_t = 4;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_INIT: apic_delivery_mode_t = 5;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_Start_Up: apic_delivery_mode_t = 6;
pub const apic_delivery_mode_t_Apic_Delivery_Mode_Ext_INT: apic_delivery_mode_t = 7;
#[doc = " <add-type id=\"apic_delivery_mode_t\"> </add-type>"]
pub type apic_delivery_mode_t = ::std::os::raw::c_uint;
pub const apic_trigger_mode_t_Apic_Trigger_Mode_Edge: apic_trigger_mode_t = 0;
pub const apic_trigger_mode_t_Apic_Trigger_Mode_Level: apic_trigger_mode_t = 1;
#[doc = " <add-type id=\"apic_trigger_mode_t\"> </add-type>"]
pub type apic_trigger_mode_t = ::std::os::raw::c_uint;
pub const apic_delivery_status_t_Apic_Delivery_Status_Idle: apic_delivery_status_t = 0;
pub const apic_delivery_status_t_Apic_Delivery_Status_Send_Pending: apic_delivery_status_t = 1;
#[doc = " <add-type id=\"apic_delivery_status_t\"> </add-type>"]
pub type apic_delivery_status_t = ::std::os::raw::c_uint;
pub const apic_rr_status_t_Apic_RR_Invalid: apic_rr_status_t = 0;
pub const apic_rr_status_t_Apic_RR_Pending: apic_rr_status_t = 1;
pub const apic_rr_status_t_Apic_RR_Valid: apic_rr_status_t = 2;
#[doc = " <add-type id=\"apic_rr_status_t\"> </add-type>"]
pub type apic_rr_status_t = ::std::os::raw::c_uint;
pub const apic_bus_status_t_Apic_Bus_Accepted: apic_bus_status_t = 0;
pub const apic_bus_status_t_Apic_Bus_Retry: apic_bus_status_t = 1;
pub const apic_bus_status_t_Apic_Bus_No_Target: apic_bus_status_t = 2;
pub const apic_bus_status_t_Apic_Bus_Invalid: apic_bus_status_t = 3;
#[doc = " <add-type id=\"apic_bus_status_t\"> </add-type>"]
pub type apic_bus_status_t = ::std::os::raw::c_uint;
pub type apic_bus_interface_t = apic_bus_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct apic_bus_interface {
    pub interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            dest_mode: apic_destination_mode_t,
            delivery_mode: apic_delivery_mode_t,
            level_assert: ::std::os::raw::c_int,
            trigger_mode: apic_trigger_mode_t,
            vector: uint8,
            destination: uint8,
        ) -> apic_bus_status_t,
    >,
}
#[test]
fn bindgen_test_layout_apic_bus_interface() {
    const UNINIT: ::std::mem::MaybeUninit<apic_bus_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apic_bus_interface>(),
        8usize,
        concat!("Size of: ", stringify!(apic_bus_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<apic_bus_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(apic_bus_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apic_bus_interface),
            "::",
            stringify!(interrupt)
        )
    );
}
pub type nand_flash_interface_t = nand_flash_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nand_flash_interface {
    pub read_access: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint16>,
    pub write_access:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint16)>,
    pub set_command_latch_enable: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
    pub set_address_latch_enable: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
    pub set_write_protect: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
    pub set_spare_area_enable: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_nand_flash_interface() {
    const UNINIT: ::std::mem::MaybeUninit<nand_flash_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nand_flash_interface>(),
        48usize,
        concat!("Size of: ", stringify!(nand_flash_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<nand_flash_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(nand_flash_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nand_flash_interface),
            "::",
            stringify!(read_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nand_flash_interface),
            "::",
            stringify!(write_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_command_latch_enable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nand_flash_interface),
            "::",
            stringify!(set_command_latch_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_address_latch_enable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nand_flash_interface),
            "::",
            stringify!(set_address_latch_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_write_protect) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nand_flash_interface),
            "::",
            stringify!(set_write_protect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_spare_area_enable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nand_flash_interface),
            "::",
            stringify!(set_spare_area_enable)
        )
    );
}
pub const i3c_ack_t_I3C_ack: i3c_ack_t = 0;
pub const i3c_ack_t_I3C_noack: i3c_ack_t = 1;
#[doc = " <add id=\"i3c_master_interface_t\">\n<insert-until text=\"// ADD INTERFACE i3c_master_interface\"/>\n\nThe interfaces <iface>i3c_master</iface> <iface>i3c_slave</iface>\nand <iface>i3c_daa_snoop</iface> are used together to model\ncommunication over an I3C bus.\nThere are four kinds of devices roles on the I3C bus: Main Master,\nSecondary Master, Slave and Legacy I2C Slave. Exactly one device\nmust be the Main Master; this is typically configured statically.\nMain Master should implement the <iface>i3c_master</iface> interface,\nwhile slave should implement the <iface>i3c_slave</iface> interface.\nSecondary Master should implement both.\nMost calls to a method in the slave device interfaces expect a response\ncall to a method in the master device interfaces. One exception is the\nmethod <fun>sdr_write</fun> in the <fun>i3c_slave</fun> interface, master\nexpects no response when calling it.\nIt is up to each device to find the caller's interfaces; usually it is\nconfigured with attributes in both the master and slave device.\n\nTwo I3C devices can communicate directly if one implements the\n<iface>i3c_master</iface> interface and the other one implements the\n<iface>i3c_slave</iface> interface. An I3C bus with multiple masters\nor slaves is typically modelled using an <class>i3c-link</class> object,\nwhere each device is connected to an endpoint object.\n\nAn I3C bus consists of a number of <em>master</em> devices and a number\nof <em>slave</em> devices. Each I3C slave device listens to one or more\n<em>7-bit addresses</em>. The slave devices can be I3C slave devices or\nLegacy I2C slave devices. This is because I3C protocol is compatible with\nI2C protocol, so that I3C master device can communicate with I2C slave\ndevices.\nFor legacy I2C slave device, the address it listens to is\npre-configured by the device, i.e. static address. For I3C slave device,\nthe address it listens to can be either static address or dynamic address.\nThe dynamic address is assigned by master during Dynamic Address Assignment\nprocess. It is an error to connect two slave devices to the same\nbus if they listen to the same address.\nIn a communication, the Current Master refers to the device who now drives\nthe bus. It can be Main Master, or Secondary Master.\nUsually, communication over the bus is initiated by the Current Master,\nwhich can communicate with one or more slave devices at a time.\nA slave device can request to initiate an communication, i.e., issue\nan ibi_request, in three cases:\nHot-Join, In-Band Interrupt and as a Secondary Master other than the\nCurrent Master requesting to become Current Master.\nOnly one device on a bus can communicate at a time.\n\nThe <fun>start</fun> method starts a transfer. The <param>address</param>\nparameter is the address header combined with read/write bit encoded as an\n8-bit number. The least significant bit is the read/write bit and the other\nbits is the 7-bit address header.\nIf the <fun>start</fun> method is called from master, the address header\ncan be address pattern 0x7E for broadcast, or specific slave address (either\nI2C slave static address or I3C slave dynamic address).\n\nIn I3C bus or link implementation, every start request will broadcast to\nall other devices. So does the stop request. This will monitor bus/link\nstatus to all devices.\n\nNormally, master starts a transfer, then the slave responds to\n<fun>start</fun> using the <fun>acknowledge</fun> method (implemented by\nmaster side interface). The <param>ack</param> parameter may be\n<const>I3C_ack</const> or <const>I3C_noack</const> if the start is acked or\nnoacked, respectively.\n\nThere are five types of different start requests:\n<dl><dt>I3C master read transaction</dt>\n<dd>If a master's start with specific slave address was acked by other\ndevice, and read/write bit in the <param>address</param> parameter of\nthe <fun>start</fun> method was 1, then master proceeds with a sequence\nof <fun>read</fun> calls. Each call is followed by a <fun>read_response</fun>\ncall from the slave. Parameter <param>data</param> in the method\n<fun>read_response</fun> is the data transferred. The procedure is no\ndifference with regard to read from I3C slave or read from I2C slave.\nIn hardware, the ACK/T bit is handled differently for i2c and i3c, and\nthe master is supposed to know whether the slave is an i2c or i3c device.\nIn the i3c case, the slave is supposed to pass the T bit in the\n<param>more</param> argument of <fun>read_response</fun>, while an i2c\ndevice always passes <param>more</param> as true. Further more, in the\ni2c case, a master sends an ACK bit, which is not represented explicitly\nin the interface. The value of this bit can be deduced from whether the\nfollowing operation is START/STOP or READ. For i3c case, parameter\n<param>more</param> in method <fun>read_response</fun> indicates if\nthere are still data waiting to be transferred from slave to master.\n<param>more</param> is true when there are still data left, false otherwise.\n</dd>\n\n<dt>I3C master write transaction (write to I3C slave)</dt>\n<dd>If a master's start with specific slave address was acked by other\ndevice, and the read/write bit in the <param>address</param> parameter\nof <fun>start</fun> method was 0, the master proceeds with a\n<fun>sdr_write</fun> call, no response is expected. Parameter\n<param>data</param> in method <fun>write</fun> is the data transferred.\nThe parity bit is not passed explicitly in sdr_write, and that the slave\ncan assume the parity bit is correctly set.\n</dd>\n\n<dt>I3C master write transaction (write to I2C slave)</dt>\n<dd>When the master's start request is to write to I2C slave, i.e.,\nmaster issues a start request to I2C slave address with read/write bit\nis 0, then master proceeds with a sequence of <fun>write</fun> calls,\neach call expects a response call to a method <fun>acknowledge</fun>.\nThis is quite similar to I2C write transaction.</dd>\n\n<dt>I3C broadcast transaction</dt>\n<dd>When master starts a transfer with I3C Broadcast Address 0x7E which\nis passed as address header, i.e., address 0xFC passed in the\n<param>address</param> argument of method <fun>start</fun>, a typical\nI3C message transfer is initiated.\n\nMultiple I3C slave devices may acknowledge the start request. The master\nwill conceive a request as being acknowledged if it was acknowledged by\nat least one of the slaves. Note that there will be a single\n<fun>acknowledge</fun> call in the master; the link or bus handles\naggregation of acks.\n\nMaster sends the I3C Commands (Common Command Code, CCC) using\n<fun>sdr_write</fun> method after receiving ACK, showing to communicate\nwith either all Slaves (Broadcast CCCs) or specific individual Slaves\n(Direct CCCs). This operation expects no response, and master will proceed.\n\nIf Broadcast CCC sent previously, master calls <fun>sdr_write</fun> method\nto transfer data to all slaves who acked the initial access.</dd>\n\n<dt>I3C direct transaction</dt>\n<dd>After sending a Direct CCC, master continues with a repeated start\nrequest along with one specific I3C slave address. The transaction goes\non just like master is communicating with only one slave. After the\ncommunication with one slave, master may be issue a repeated start request\nto another slave. Further communication is routed only to the targeted\nslave device.</dd>\n</dl>\n\nAfter sending a number of reads or a number of writes, the master may\nchoose to either call the <fun>stop</fun> method to issue a <em>stop\ncondition</em> which terminates the transfer, or to call the <fun>start</fun>\nmethod again to issue a <em>repeated start condition</em>. The repeated start\ncondition works like a normal start condition.\n\nThe <fun>start</fun> method and <fun>read</fun> method in the slave\ninterfaces are allowed to respond synchronously; i.e., the\n<fun>acknowledge</fun> or <fun>read</fun> method may be called before the\ncorresponding method in the slave interfaces has returned. A master that\nneeds to connect directly to a slave device needs to take this into\nconsideration; however, when communicating via an <class>i3c-link</class>\nobject, the link guarantees that all responses are asynchronous.\n\nThe method <fun>daa_read</fun> and method <fun>daa_response</fun> are used\nin Dynamic Address Assignment process.\nMethod <fun>daa_read</fun> is called from master to signal a daa read request.\nMethod <fun>daa_response</fun> is called from slave to send slave specific\n8-bytes data (48-bit Unique ID, BCR, DCR) to master. The parameter\n<param>id</param>, <param>bcr</param> and <param>dcr</param> in method\n<fun>daa_response</fun> represent the slave specific daa data.\nIf multiple slaves response daa data, the slave with the lowest data wins\nand it will get the assigned address this time.\nMaster calls method <fun>write</fun> in slave interfaces to send assigned\ndynamic address to the slave who wins. This operation expects a response\ncall to method <fun>acknowledge</fun> in master side. Parameter\n<param>data</param> in method <fun>write</fun> stores the assigned address.\n\nMaster should implement the method <fun>stop</fun> in the interface\n<iface>i3c_slave</iface> in case there is secondary master in the\nconfiguration which may issue start request.\n\nSlave can request to start a communication through <fun>ibi_request</fun>.\nThe request is sent to Current Master which drives the bus now.\nIf the master chooses to continue the slave request, <fun>ibi_start</fun>\nis called, this ibi start will broadcast to all devices in the configuration.\nThen slave can send its address header with <fun>ibi_address</fun>\nargument <arg>address</arg>. The address header can be 0x02 for Hot-Join,\nor the address of the slave itself for IBI and secondary master with\nread/write bit 1 and 0 respectively.\nIf more than one slave issues <fun>ibi_address</fun>, arbitration occurs,\nthe slave with lowest address header wins and the winning address will be\ndelivered to master by link or bus.\nAt that time, master issues <fun>ibi_acknowledge</fun> to the slave who wins.\nOther slaves which do not receive <fun>ibi_acknowledge</fun> will consume it\nlost arbitration already.\n\n</add>\n<add id=\"i3c_master_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type i3c_ack_t = ::std::os::raw::c_uint;
pub type i3c_master_interface_t = i3c_master_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i3c_master_interface {
    pub acknowledge:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, ack: i3c_ack_t)>,
    pub read_response: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, value: uint8, more: bool),
    >,
    pub daa_response: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: uint64, bcr: uint8, dcr: uint8),
    >,
    pub ibi_request: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub ibi_address:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, address: uint8)>,
}
#[test]
fn bindgen_test_layout_i3c_master_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i3c_master_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i3c_master_interface>(),
        40usize,
        concat!("Size of: ", stringify!(i3c_master_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i3c_master_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i3c_master_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_master_interface),
            "::",
            stringify!(acknowledge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_master_interface),
            "::",
            stringify!(read_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).daa_response) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_master_interface),
            "::",
            stringify!(daa_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibi_request) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_master_interface),
            "::",
            stringify!(ibi_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibi_address) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_master_interface),
            "::",
            stringify!(ibi_address)
        )
    );
}
pub type i3c_slave_interface_t = i3c_slave_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i3c_slave_interface {
    pub start: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, address: uint8)>,
    pub write: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint8)>,
    pub sdr_write:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, data: bytes_t)>,
    pub read: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub daa_read: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub ibi_start: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub ibi_acknowledge:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, ack: i3c_ack_t)>,
}
#[test]
fn bindgen_test_layout_i3c_slave_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i3c_slave_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i3c_slave_interface>(),
        64usize,
        concat!("Size of: ", stringify!(i3c_slave_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i3c_slave_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i3c_slave_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdr_write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(sdr_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).daa_read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(daa_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibi_start) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(ibi_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibi_acknowledge) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_slave_interface),
            "::",
            stringify!(ibi_acknowledge)
        )
    );
}
pub type i3c_daa_snoop_interface_t = i3c_daa_snoop_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i3c_daa_snoop_interface {
    pub assigned_address: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            id: uint64,
            bcr: uint8,
            dcr: uint8,
            address: uint8,
        ),
    >,
}
#[test]
fn bindgen_test_layout_i3c_daa_snoop_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i3c_daa_snoop_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i3c_daa_snoop_interface>(),
        8usize,
        concat!("Size of: ", stringify!(i3c_daa_snoop_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i3c_daa_snoop_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i3c_daa_snoop_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assigned_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i3c_daa_snoop_interface),
            "::",
            stringify!(assigned_address)
        )
    );
}
#[doc = " <add id=\"link_message_t DOC\">\n<ndx>link_message_t</ndx>\n<doc>\n<doc-item name=\"NAME\">link_message_t</doc-item>\n<doc-item name=\"SYNOPSIS\">\ntypedef struct link_message link_message_t;\n</doc-item>\n<doc-item name=\"DESCRIPTION\">\nGeneric part of a link message. This structure should always be the\nfirst member of the link message data structure, so that the link\nlibrary can access the generic part with a simple cast.\n</doc-item>\n<doc-item name=\"EXAMPLE\">\nThe <class>datagram_link</class> example defines its link message in\nthe following way:\n<insert id=\"dl_msg_t\"/>\n</doc-item>\n<doc-item name=\"SEE ALSO\">\nlink_type_t,\nSIMLINK_init_message\n</doc-item>\n</doc>\n</add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct link_message_t {
    pub refcount: atomic_counter_t,
}
#[test]
fn bindgen_test_layout_link_message_t() {
    const UNINIT: ::std::mem::MaybeUninit<link_message_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<link_message_t>(),
        4usize,
        concat!("Size of: ", stringify!(link_message_t))
    );
    assert_eq!(
        ::std::mem::align_of::<link_message_t>(),
        4usize,
        concat!("Alignment of ", stringify!(link_message_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(link_message_t),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = " <add id=\"link_type_t DOC\">\n<ndx>link_type_t</ndx>\n<doc>\n<doc-item name=\"NAME\">link_type_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"link_type_t def\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\nFunctions to be defined by the specific link implementation.\n\nThese functions can be classified in four groups:\n\n<dl>\n\n<dt>Message Links Manipulation</dt>\n\n<dd>The first five functions are related to the link-specific\nmessages.\n\nAll five functions can be called in any execution context and should\nbe thread-safe. They all take the link object as argument, in case it\ncontains information necessary to perform the operation. As the link\nobject is shared between the cells in which it is connected, it\nshould not be modified during execution. Mutable state should be kept\nin the endpoint objects instead.\n\n<fun>msg_to_attr()</fun> transforms the message <param>msg</param>\ninto an <type>attr_value_t</type> value. It is used to checkpoint\nin-flight messages waiting to be delivered. The value returned will\nbe passed unchanged as argument <param>attr</param> to\n<fun>msg_from_attr()</fun> when loading a checkpoint with pending\nlink messages. Neither function is expected to return an error,\nalthough <fun>msg_from_attr()</fun> is allowed to return NULL when\ntranslating a message it does not care to restore. This can be useful\nto keep checkpoint compatibility with older versions of the same link\nthat do not always have the same message protocol.\n\nUsing the <class>datagram_link</class> as an example, the\n<class>datagram-link</class> message is defined as:\n\n<insert id=\"dl_msg_t\"/>\n\n<fun>msg_to_attr()</fun> and <fun>msg_from_attr()</fun> are thus\ndefined as:\n\n<insert id=\"dl_to_a\"/>\n<insert id=\"dl_fr_a\"/>\n\n<fun>free_msg()</fun> is called when the message <param>msg</param>\nhas been delivered to all its destinations and is no longer\nneeded. All memory allocated for <param>msg</param> is expected to be\nfreed, including <param>msg</param> itself. The\n<class>datagram_link</class> defines <fun>free_msg()</fun> as:\n\n<insert id=\"dl_free\"/>\n\n<fun>marshal()</fun> is called when the message <param>msg</param>\nshould be transmitted over a distributed simulation. Its purpose is\nto serialize the message into a <type>frags_t</type>\nrepresentation. Rather than returning the marshaled message,\n<fun>marshal()</fun> takes the <param>finish</param> and\n<param>finish_data</param> arguments, that it is expected to call\nonce the message has been marshaled.\n\nThe reason behind this mechanism is that it allows\n<fun>marshal()</fun> to perform its operations with a\n<type>frags_t</type> variable allocated on the stack, and thus to\nskip any heap allocation when sending the message. In case memory was\nallocated anyway, it should be freed just after <param>finish</param>\nhas returned.\n\n<insert id=\"dl_mrsh\"/>\n\n<fun>unmarshal()</fun> does the opposite of <fun>marshal()</fun>: it\ntakes a serialized <type>frags_t</type> representation of the message\ncalled <param>data</param> and returns a newly allocated link\nmessage.\n\n<insert id=\"dl_unm\"/>\n\n</dd>\n\n<dt>Endpoint Configuration</dt>\n\n<dd>Link endpoints are created as needed by the link\ncomponent. Depending on how they are created, they may not know yet\nwhich device they are connected to, so it might not be possible yet,\nfor example, to cache the device's communication interface in the\nendpoint's <fun>finalize()</fun> function. Additionally, there are\ncases where the device the endpoint talks to may be changed, such as\nwhen inserting a probe object to listen to the traffic.\n\nIn all of these cases, the <fun>device_changed()</fun> callback will\nbe called when the endpoint's device attribute is changed\n<em>and</em> the endpoint has reached to finalize phase. In that\ncallback, the new device can be obtained via\n<fun>SIMLINK_endpoint_device()</fun> and additional operations, such\nas interface caching, can be safely performed. The old device the\nendpoint was connected to is provided for convenience as an argument\nto <fun>device_changed()</fun>.\n\nNote that if no device related operations are necessary, this\ncallback may be left unimplemented.\n\nThe <class>ser_link</class> implementation of\n<fun>device_changed</fun> is the following:\n\n<insert id=\"sl_dev_changed\"/>\n\n</dd>\n\n<dt>Message Delivery</dt>\n\n<dd>Messages are delivered to the link by calling the\n<fun>deliver()</fun> function. The arguments of <fun>deliver()</fun>\nare the endpoint <param>ep</param> that received the message and the\nmessage <param>msg</param> itself. The implementation of\n<fun>deliver()</fun> is expected to call the correct device's\nfunction to deliver the message.\n\nNote that <fun>deliver()</fun> can be called in any execution context\nand should be thread-safe. The link object is shared between the\ncells in which it is connected, and should not be modified during\nexecution. Mutable state should be kept in the endpoint objects\ninstead.\n\nThe <class>datagram_link</class> implementation of\n<fun>deliver()</fun> is the following:\n\n<insert id=\"dl_dlv\"/>\n\n</dd>\n\n<dt>Configuration</dt>\n\n<dd>The last two functions of <type>link_type_t</type> are taking\ncare of the link configuration itself. In the same way messages needs\nto be marshaled when sent over a network, the global link\nconfiguration needs to be agreed upon when running the simulation in\nseveral processes.\n\n<fun>update_config_value()</fun> is called whenever a configuration\nparameter has been added or updated. The configuration parameter's\nname is provided as <param>key</param> and its new value as\n<param>value</param>, encoded as a <type>frags_t</type>.\n\n<fun>remove_config_value()</fun> is called whenever the configuration\nvalue <param>key</param> has been removed.\n\nThe interpretation of the link configuration messages is link\nspecific. The only configuration parameter that is defined by the\nlink library itself is <var>goal_latency</var>. This is handled\nentirely internally, although with the same mechanism as exposed\nhere. Configuration changes are initiated by the link objects\nthemselves with the Link Library API functions\n<fun>SIMLINK_config_update_value()</fun> and\n<fun>SIMLINK_config_remove_value()</fun>.\n\nNote that the link object that initiates the configuration change is\nalso called back via <fun>update_config_value()</fun> and\n<fun>remove_config_value()</fun>. Note also that the configuration\nchanges may be buffered and sent later if they are initiated too soon\nfor the configuration message to propagate.\n\nConfiguration changes should only be initiated while in Global\nContext, so the two configuration functions above will only be called\nin Global Context. This allows them to modify properties of\nthe link object itself without needing to care about thread safety.\n\nAs an example, here is how <class>ser_link</class> defines these two\nfunctions. The serial link keeps track of all endpoints connected to\nit by saving their ID as a configuration parameter. It also uses a\nconfigurable buffer size.\n\nFinally, it is important to note that these two callbacks may be\ncalled from a non-execution thread. They should call the Simics API\nonly via <fun>SIM_thread_safe_callback()</fun>. This includes calling\nthe <fun>SIM_log_*</fun> functions.\n\n<insert id=\"sl_cfg_up\"/>\n<insert id=\"sl_cfg_rm\"/>\n\n</dd>\n\n</dl>\n\n</doc-item>\n<doc-item name=\"SEE ALSO\">\nlink_message_t,\nSIMLINK_init\n</doc-item>\n\n</doc>\n</add>\n<add-type id=\"link_type_t def\"></add-type>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct link_type_t {
    pub msg_to_attr: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, msg: *const link_message_t) -> attr_value_t,
    >,
    pub msg_from_attr: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, attr: attr_value_t) -> *mut link_message_t,
    >,
    pub free_msg: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, msg: *mut link_message_t),
    >,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            msg: *const link_message_t,
            finish: ::std::option::Option<
                unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, msg: *const frags_t),
            >,
            finish_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub unmarshal: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, msg: *const frags_t) -> *mut link_message_t,
    >,
    pub deliver: ::std::option::Option<
        unsafe extern "C" fn(ep: *mut conf_object_t, msg: *const link_message_t),
    >,
    pub update_config_value: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            key: *const ::std::os::raw::c_char,
            value: *const frags_t,
        ),
    >,
    pub remove_config_value: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, key: *const ::std::os::raw::c_char),
    >,
    pub device_changed: ::std::option::Option<
        unsafe extern "C" fn(ep: *mut conf_object_t, old_dev: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_link_type_t() {
    const UNINIT: ::std::mem::MaybeUninit<link_type_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<link_type_t>(),
        72usize,
        concat!("Size of: ", stringify!(link_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<link_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(link_type_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_to_attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(msg_to_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_from_attr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(msg_from_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_msg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(free_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marshal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(marshal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmarshal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(unmarshal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deliver) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(deliver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_config_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(update_config_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_config_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(remove_config_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_changed) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(link_type_t),
            "::",
            stringify!(device_changed)
        )
    );
}
extern "C" {
    pub fn SIMLINK_endpoint_link(ep: *const conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIMLINK_endpoint_id(ep: *const conf_object_t) -> uint64;
}
extern "C" {
    pub fn SIMLINK_endpoint_clock(ep: *const conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIMLINK_endpoint_is_device(ep: *const conf_object_t) -> bool;
}
extern "C" {
    pub fn SIMLINK_endpoint_device(ep: *const conf_object_t) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIMLINK_endpoint_port(ep: *const conf_object_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIMLINK_endpoint_dev_name(
        ep: *const conf_object_t,
        scratch: buffer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SIMLINK_init_library();
}
extern "C" {
    pub fn SIMLINK_init_message(msg: *mut link_message_t);
}
extern "C" {
    pub fn SIMLINK_register_class(cls: *mut conf_class_t);
}
extern "C" {
    pub fn SIMLINK_register_endpoint_class(
        cls: *mut conf_class_t,
        msg_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIMLINK_register_snoop_endpoint_class(cls: *mut conf_class_t);
}
extern "C" {
    pub fn SIMLINK_init(obj: *mut conf_object_t, type_: *const link_type_t);
}
extern "C" {
    pub fn SIMLINK_endpoint_init(ep_obj: *mut conf_object_t, snoop: bool);
}
extern "C" {
    pub fn SIMLINK_finalize(link: *mut conf_object_t);
}
extern "C" {
    pub fn SIMLINK_endpoint_finalize(ep: *mut conf_object_t);
}
extern "C" {
    pub fn SIMLINK_endpoint_disconnect(ep: *mut conf_object_t);
}
extern "C" {
    pub fn SIMLINK_pre_delete(obj: *mut conf_object_t);
}
extern "C" {
    pub fn SIMLINK_snoop_endpoint_create(
        cls: *mut conf_class_t,
        link: *mut conf_object_t,
        clock: *mut conf_object_t,
        attrs: attr_value_t,
    ) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIMLINK_config_update_value(
        link: *mut conf_object_t,
        key: *const ::std::os::raw::c_char,
        value: *const frags_t,
    );
}
extern "C" {
    pub fn SIMLINK_config_remove_value(
        link: *mut conf_object_t,
        key: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SIMLINK_find_endpoint_by_id(link: *mut conf_object_t, id: uint64) -> *mut conf_object_t;
}
extern "C" {
    pub fn SIMLINK_send_message(
        src_ep: *mut conf_object_t,
        dst_id: uint64,
        msg: *mut link_message_t,
    );
}
extern "C" {
    pub fn SIMLINK_send_message_multi(
        src_ep: *mut conf_object_t,
        num_dsts: ::std::os::raw::c_uint,
        dst_ids: *const uint64,
        msg: *mut link_message_t,
    );
}
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Complete: firewire_ack_code_t = 1;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Pending: firewire_ack_code_t = 2;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Busy_X: firewire_ack_code_t = 4;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Busy_A: firewire_ack_code_t = 5;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Busy_B: firewire_ack_code_t = 6;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Tardy: firewire_ack_code_t = 11;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Conflict_Error: firewire_ack_code_t = 12;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Data_Error: firewire_ack_code_t = 13;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Type_Error: firewire_ack_code_t = 14;
#[doc = " Values defined in the FireWire specification"]
pub const firewire_ack_code_t_Firewire_Ack_Address_Error: firewire_ack_code_t = 15;
#[doc = " no destination found"]
pub const firewire_ack_code_t_Firewire_Ack_No_Destination: firewire_ack_code_t = 16;
#[doc = " no ack signal sent for packet"]
pub const firewire_ack_code_t_Firewire_Ack_No_Ack: firewire_ack_code_t = 17;
#[doc = " <add-type id=\"firewire_ack_code_t\"></add-type>"]
pub type firewire_ack_code_t = ::std::os::raw::c_uint;
pub const firewire_response_code_t_Firewire_Response_Complete: firewire_response_code_t = 0;
#[doc = "Firewire_Response_Conflict    = 4,"]
pub const firewire_response_code_t_Firewire_Response_Data_Error: firewire_response_code_t = 5;
#[doc = "Firewire_Response_Conflict    = 4,"]
pub const firewire_response_code_t_Firewire_Response_Type_Error: firewire_response_code_t = 6;
#[doc = "Firewire_Response_Conflict    = 4,"]
pub const firewire_response_code_t_Firewire_Response_Address_Error: firewire_response_code_t = 7;
#[doc = " <add-type id=\"firewire_response_code_t\"></add-type>"]
pub type firewire_response_code_t = ::std::os::raw::c_uint;
pub const firewire_transaction_code_t_Firewire_Write_Quadlet: firewire_transaction_code_t = 0;
pub const firewire_transaction_code_t_Firewire_Write_Block: firewire_transaction_code_t = 1;
pub const firewire_transaction_code_t_Firewire_Write_Response: firewire_transaction_code_t = 2;
pub const firewire_transaction_code_t_Firewire_Read_Quadlet: firewire_transaction_code_t = 4;
pub const firewire_transaction_code_t_Firewire_Read_Block: firewire_transaction_code_t = 5;
pub const firewire_transaction_code_t_Firewire_Read_Quadlet_Response: firewire_transaction_code_t =
    6;
pub const firewire_transaction_code_t_Firewire_Read_Block_Response: firewire_transaction_code_t = 7;
pub const firewire_transaction_code_t_Firewire_Cycle_Start: firewire_transaction_code_t = 8;
pub const firewire_transaction_code_t_Firewire_Lock: firewire_transaction_code_t = 9;
pub const firewire_transaction_code_t_Firewire_Streaming: firewire_transaction_code_t = 10;
pub const firewire_transaction_code_t_Firewire_Lock_Response: firewire_transaction_code_t = 11;
#[doc = " <add-type id=\"firewire_transaction_code_t\"></add-type>"]
pub type firewire_transaction_code_t = ::std::os::raw::c_uint;
pub const firewire_async_lock_code_t_Firewire_Lock_Maskswap: firewire_async_lock_code_t = 1;
pub const firewire_async_lock_code_t_Firewire_Lock_Compareswap: firewire_async_lock_code_t = 2;
pub const firewire_async_lock_code_t_Firewire_Lock_Fetchadd: firewire_async_lock_code_t = 3;
pub const firewire_async_lock_code_t_Firewire_Lock_Littleadd: firewire_async_lock_code_t = 4;
pub const firewire_async_lock_code_t_Firewire_Lock_Boundedadd: firewire_async_lock_code_t = 5;
pub const firewire_async_lock_code_t_Firewire_Lock_Wrapadd: firewire_async_lock_code_t = 6;
pub const firewire_async_lock_code_t_Firewire_Lock_Vendor: firewire_async_lock_code_t = 7;
#[doc = " <add-type id=\"firewire_async_lock_code_t\"></add-type>"]
pub type firewire_async_lock_code_t = ::std::os::raw::c_uint;
pub const firewire_iso_tag_t_Firewire_Tag_Unformatted: firewire_iso_tag_t = 0;
#[doc = " <add-type id=\"firewire_iso_tag_t\"></add-type>"]
pub type firewire_iso_tag_t = ::std::os::raw::c_uint;
pub const firewire_port_status_t_Firewire_Port_No_Port: firewire_port_status_t = 0;
pub const firewire_port_status_t_Firewire_Port_Not_Connected: firewire_port_status_t = 1;
pub const firewire_port_status_t_Firewire_Port_Parent: firewire_port_status_t = 2;
pub const firewire_port_status_t_Firewire_Port_Child: firewire_port_status_t = 3;
#[doc = " <add-type id=\"firewire_port_status_t\"></add-type>"]
pub type firewire_port_status_t = ::std::os::raw::c_uint;
pub type firewire_bus_interface_t = firewire_bus_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct firewire_bus_interface {
    pub connect_device: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            dev: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub disconnect_device: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            dev: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_device_bus_id: ::std::option::Option<
        unsafe extern "C" fn(bus: *mut conf_object_t, dev: *mut conf_object_t, bus_id: uint16),
    >,
    pub set_id_mask: ::std::option::Option<
        unsafe extern "C" fn(bus: *mut conf_object_t, dev: *mut conf_object_t, id_mask: uint16),
    >,
    pub transfer: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            source: *mut conf_object_t,
            packet: *mut dbuffer_t,
            crc_calculated: ::std::os::raw::c_int,
        ) -> firewire_ack_code_t,
    >,
    pub register_channel: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            dev: *mut conf_object_t,
            channel: uint32,
        ) -> ::std::os::raw::c_int,
    >,
    pub unregister_channel: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            dev: *mut conf_object_t,
            channel: uint32,
        ) -> ::std::os::raw::c_int,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(bus: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_firewire_bus_interface() {
    const UNINIT: ::std::mem::MaybeUninit<firewire_bus_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<firewire_bus_interface>(),
        64usize,
        concat!("Size of: ", stringify!(firewire_bus_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<firewire_bus_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(firewire_bus_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(connect_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect_device) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(disconnect_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_device_bus_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(set_device_bus_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_id_mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(set_id_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_channel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(register_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_channel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(unregister_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_bus_interface),
            "::",
            stringify!(reset)
        )
    );
}
#[doc = " <add-type id=\"uint32_array_t\">\nAn array of unsigned 32-bit integers.\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct uint32_array_t {
    pub len: usize,
    pub data: *mut uint32,
}
#[test]
fn bindgen_test_layout_uint32_array_t() {
    const UNINIT: ::std::mem::MaybeUninit<uint32_array_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint32_array_t>(),
        16usize,
        concat!("Size of: ", stringify!(uint32_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uint32_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uint32_array_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint32_array_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint32_array_t),
            "::",
            stringify!(data)
        )
    );
}
impl Default for uint32_array_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type firewire_device_interface_t = firewire_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct firewire_device_interface {
    pub transfer: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut conf_object_t,
            packet: *mut dbuffer_t,
            crc_calculated: ::std::os::raw::c_int,
        ) -> firewire_ack_code_t,
    >,
    pub reset: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut conf_object_t,
            id: uint16,
            root_id: uint8,
            self_ids: uint32_array_t,
        ),
    >,
    pub get_self_id_template:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut conf_object_t) -> uint32>,
    pub get_rhb: ::std::option::Option<
        unsafe extern "C" fn(dev: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub get_port_count:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut conf_object_t) -> uint8>,
    pub get_port_mask:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut conf_object_t) -> uint16>,
}
#[test]
fn bindgen_test_layout_firewire_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<firewire_device_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<firewire_device_interface>(),
        48usize,
        concat!("Size of: ", stringify!(firewire_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<firewire_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(firewire_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_device_interface),
            "::",
            stringify!(transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_device_interface),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_self_id_template) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_device_interface),
            "::",
            stringify!(get_self_id_template)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_rhb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_device_interface),
            "::",
            stringify!(get_rhb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_port_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_device_interface),
            "::",
            stringify!(get_port_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_port_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(firewire_device_interface),
            "::",
            stringify!(get_port_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct coreint_reply_t {
    pub enabled: bool,
    pub vector: uint64,
}
#[test]
fn bindgen_test_layout_coreint_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<coreint_reply_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<coreint_reply_t>(),
        16usize,
        concat!("Size of: ", stringify!(coreint_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<coreint_reply_t>(),
        8usize,
        concat!("Alignment of ", stringify!(coreint_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coreint_reply_t),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(coreint_reply_t),
            "::",
            stringify!(vector)
        )
    );
}
pub type coreint_interface_t = coreint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct coreint_interface {
    pub acknowledge: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, core: *mut conf_object_t) -> coreint_reply_t,
    >,
}
#[test]
fn bindgen_test_layout_coreint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<coreint_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<coreint_interface>(),
        8usize,
        concat!("Size of: ", stringify!(coreint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<coreint_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(coreint_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coreint_interface),
            "::",
            stringify!(acknowledge)
        )
    );
}
pub type translator_interface_t = translator_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct translator_interface {
    pub translate: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            addr: physical_address_t,
            access: access_t,
            default_target: *const map_target_t,
        ) -> translation_t,
    >,
}
#[test]
fn bindgen_test_layout_translator_interface() {
    const UNINIT: ::std::mem::MaybeUninit<translator_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<translator_interface>(),
        8usize,
        concat!("Size of: ", stringify!(translator_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<translator_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(translator_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).translate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(translator_interface),
            "::",
            stringify!(translate)
        )
    );
}
pub type transaction_translator_interface_t = transaction_translator_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct transaction_translator_interface {
    pub translate: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            addr: uint64,
            access: access_t,
            t: *mut transaction_t,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    translation: translation_t,
                    transaction: *mut transaction_t,
                    data: cbdata_call_t,
                ) -> exception_type_t,
            >,
            data: cbdata_register_t,
        ) -> exception_type_t,
    >,
}
#[test]
fn bindgen_test_layout_transaction_translator_interface() {
    const UNINIT: ::std::mem::MaybeUninit<transaction_translator_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<transaction_translator_interface>(),
        8usize,
        concat!("Size of: ", stringify!(transaction_translator_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<transaction_translator_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(transaction_translator_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).translate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(transaction_translator_interface),
            "::",
            stringify!(translate)
        )
    );
}
pub type translation_flush_interface_t = translation_flush_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct translation_flush_interface {
    pub flush_range: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            base: uint64,
            size: uint64,
            access: access_t,
            default_target: *const map_target_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_translation_flush_interface() {
    const UNINIT: ::std::mem::MaybeUninit<translation_flush_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<translation_flush_interface>(),
        8usize,
        concat!("Size of: ", stringify!(translation_flush_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<translation_flush_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(translation_flush_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(translation_flush_interface),
            "::",
            stringify!(flush_range)
        )
    );
}
pub const ms1553_phase_t_MS1553_Phase_Idle: ms1553_phase_t = 0;
pub const ms1553_phase_t_MS1553_Phase_T_Command: ms1553_phase_t = 1;
pub const ms1553_phase_t_MS1553_Phase_R_Command: ms1553_phase_t = 2;
pub const ms1553_phase_t_MS1553_Phase_M_T_Command: ms1553_phase_t = 3;
pub const ms1553_phase_t_MS1553_Phase_M_R_Command: ms1553_phase_t = 4;
pub const ms1553_phase_t_MS1553_Phase_M_N_Command: ms1553_phase_t = 5;
pub const ms1553_phase_t_MS1553_Phase_Data: ms1553_phase_t = 6;
pub const ms1553_phase_t_MS1553_Phase_Status: ms1553_phase_t = 7;
pub const ms1553_phase_t_MS1553_Num_Phases: ms1553_phase_t = 8;
#[doc = " <add-type id=\"ms1553_phase_t def\">\n</add-type>"]
pub type ms1553_phase_t = ::std::os::raw::c_uint;
pub const ms1553_error_t_MS1553_Err_Manchester: ms1553_error_t = 0;
pub const ms1553_error_t_MS1553_Err_Sync_Field: ms1553_error_t = 1;
pub const ms1553_error_t_MS1553_Err_Word_Count: ms1553_error_t = 2;
pub const ms1553_error_t_MS1553_Err_Parity: ms1553_error_t = 3;
pub const ms1553_error_t_MS1553_Err_Protocol: ms1553_error_t = 4;
#[doc = " <add-type id=\"ms1553_error_t def\">\n</add-type>"]
pub type ms1553_error_t = ::std::os::raw::c_uint;
pub const ms1553_mode_code_t_MS1553_Dynamic_Bus_Control: ms1553_mode_code_t = 0;
pub const ms1553_mode_code_t_MS1553_Synchronize_T: ms1553_mode_code_t = 1;
pub const ms1553_mode_code_t_MS1553_Transmit_Status_word: ms1553_mode_code_t = 2;
pub const ms1553_mode_code_t_MS1553_Initiate_Self_Test: ms1553_mode_code_t = 3;
pub const ms1553_mode_code_t_MS1553_Transmitter_Shutdown: ms1553_mode_code_t = 4;
pub const ms1553_mode_code_t_MS1553_Override_Transmitter_Shutdown: ms1553_mode_code_t = 5;
pub const ms1553_mode_code_t_MS1553_Inhibit_Terminal_Flag_Bit: ms1553_mode_code_t = 6;
pub const ms1553_mode_code_t_MS1553_Override_Inhibit_Terminal_Flag_Bit: ms1553_mode_code_t = 7;
pub const ms1553_mode_code_t_MS1553_Reset_Remote_Terminal: ms1553_mode_code_t = 8;
pub const ms1553_mode_code_t_MS1553_Transmit_Vector_Word: ms1553_mode_code_t = 16;
pub const ms1553_mode_code_t_MS1553_Synchronize_R: ms1553_mode_code_t = 17;
pub const ms1553_mode_code_t_MS1553_Transmit_Last_Command_Word: ms1553_mode_code_t = 18;
pub const ms1553_mode_code_t_MS1553_Transmit_BIT_Vector: ms1553_mode_code_t = 19;
pub const ms1553_mode_code_t_MS1553_Selected_Transmitter_Shutdown: ms1553_mode_code_t = 20;
pub const ms1553_mode_code_t_MS1553_Override_Selected_Transmitter_Shutdown: ms1553_mode_code_t = 21;
#[doc = " <add-type id=\"ms1553_mode_code_t def\">\n</add-type>"]
pub type ms1553_mode_code_t = ::std::os::raw::c_uint;
#[doc = " <add-type id=\"ms1553_words_t def\">\n</add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ms1553_words_t {
    pub length: ::std::os::raw::c_int,
    pub data: *const uint16,
}
#[test]
fn bindgen_test_layout_ms1553_words_t() {
    const UNINIT: ::std::mem::MaybeUninit<ms1553_words_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ms1553_words_t>(),
        16usize,
        concat!("Size of: ", stringify!(ms1553_words_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ms1553_words_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ms1553_words_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_words_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_words_t),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ms1553_words_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ms1553_link_interface_t = ms1553_link_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ms1553_link_interface {
    pub connect_terminal: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            obj: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub disconnect_terminal: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, id: ::std::os::raw::c_int),
    >,
    pub send_data: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            id: ::std::os::raw::c_int,
            phase: ms1553_phase_t,
            data: ms1553_words_t,
        ),
    >,
    pub set_terminal_address: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            id: ::std::os::raw::c_int,
            address: ::std::os::raw::c_int,
        ),
    >,
    pub clr_terminal_address: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, id: ::std::os::raw::c_int),
    >,
    pub set_idle: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, id: ::std::os::raw::c_int),
    >,
    pub inject_data: ::std::option::Option<
        unsafe extern "C" fn(link: *mut conf_object_t, phase: ms1553_phase_t, data: ms1553_words_t),
    >,
    pub inject_error:
        ::std::option::Option<unsafe extern "C" fn(link: *mut conf_object_t, err: ms1553_error_t)>,
}
#[test]
fn bindgen_test_layout_ms1553_link_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ms1553_link_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ms1553_link_interface>(),
        64usize,
        concat!("Size of: ", stringify!(ms1553_link_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ms1553_link_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ms1553_link_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_terminal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(connect_terminal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect_terminal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(disconnect_terminal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(send_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_terminal_address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(set_terminal_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clr_terminal_address) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(clr_terminal_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_idle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(set_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inject_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(inject_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inject_error) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_link_interface),
            "::",
            stringify!(inject_error)
        )
    );
}
pub type ms1553_terminal_interface_t = ms1553_terminal_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ms1553_terminal_interface {
    pub receive_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            link: *mut conf_object_t,
            id: ::std::os::raw::c_int,
            phase: ms1553_phase_t,
            data: ms1553_words_t,
        ),
    >,
    pub receive_error: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            link: *mut conf_object_t,
            id: ::std::os::raw::c_int,
            err: ms1553_error_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ms1553_terminal_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ms1553_terminal_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ms1553_terminal_interface>(),
        16usize,
        concat!("Size of: ", stringify!(ms1553_terminal_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ms1553_terminal_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ms1553_terminal_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_terminal_interface),
            "::",
            stringify!(receive_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_error) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ms1553_terminal_interface),
            "::",
            stringify!(receive_error)
        )
    );
}
pub type arinc429_bus_interface_t = arinc429_bus_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arinc429_bus_interface {
    pub send_word: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut conf_object_t,
            word: uint32,
            parity_ok: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_arinc429_bus_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arinc429_bus_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arinc429_bus_interface>(),
        8usize,
        concat!("Size of: ", stringify!(arinc429_bus_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arinc429_bus_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arinc429_bus_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arinc429_bus_interface),
            "::",
            stringify!(send_word)
        )
    );
}
pub type arinc429_receiver_interface_t = arinc429_receiver_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct arinc429_receiver_interface {
    pub receive_word: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut conf_object_t,
            word: uint32,
            parity_ok: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_arinc429_receiver_interface() {
    const UNINIT: ::std::mem::MaybeUninit<arinc429_receiver_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<arinc429_receiver_interface>(),
        8usize,
        concat!("Size of: ", stringify!(arinc429_receiver_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<arinc429_receiver_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(arinc429_receiver_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arinc429_receiver_interface),
            "::",
            stringify!(receive_word)
        )
    );
}
pub const interrupt_source_t_Interrupt_Source_Icr_Ipr: interrupt_source_t = 0;
pub const interrupt_source_t_Interrupt_Source_Msi: interrupt_source_t = 1;
pub const interrupt_source_t_Interrupt_Source_Virtual_Wire: interrupt_source_t = 2;
pub const interrupt_source_t_Interrupt_Source_Nmi_Pin: interrupt_source_t = 3;
pub const interrupt_source_t_Interrupt_Source_Lvt: interrupt_source_t = 4;
pub const interrupt_source_t_Interrupt_Source_Iommu: interrupt_source_t = 5;
pub const interrupt_source_t_Interrupt_Source_Int2: interrupt_source_t = 6;
pub const interrupt_source_t_Interrupt_Source_Vmcs_Injection: interrupt_source_t = 7;
pub const interrupt_source_t_Interrupt_Source_Legacy_Apic_Vector: interrupt_source_t = 8;
pub const interrupt_source_t_Interrupt_Source_Self_Ipi: interrupt_source_t = 9;
pub const interrupt_source_t_Interrupt_Source_Unknown: interrupt_source_t = 10;
pub type interrupt_source_t = ::std::os::raw::c_uint;
pub type interrupt_subscriber_interface_t = interrupt_subscriber_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interrupt_subscriber_interface {
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            delivery_mode: apic_delivery_mode_t,
            level_assert: bool,
            trigger_mode: apic_trigger_mode_t,
            vector: uint8,
            source: interrupt_source_t,
        ),
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_interrupt_subscriber_interface() {
    const UNINIT: ::std::mem::MaybeUninit<interrupt_subscriber_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interrupt_subscriber_interface>(),
        16usize,
        concat!("Size of: ", stringify!(interrupt_subscriber_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<interrupt_subscriber_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(interrupt_subscriber_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_subscriber_interface),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interrupt_subscriber_interface),
            "::",
            stringify!(reset)
        )
    );
}
pub const usb_transfer_completion_t_USB_Transfer_Completed: usb_transfer_completion_t = 0;
pub const usb_transfer_completion_t_USB_Transfer_Not_Ready: usb_transfer_completion_t = 1;
#[doc = " <add id=\"usb_transfer_t DOC\">\n<ndx>usb_transfer_t</ndx>\n<doc>\n<doc-item name=\"NAME\">usb_transfer_t</doc-item>\n<doc-item name=\"SYNOPSIS\"><insert id=\"usb_transfer_t\"/></doc-item>\n<doc-item name=\"DESCRIPTION\">\n<insert id=\"usb_transfer_t description\"/>\n</doc-item>\n</doc>\n</add>\n\n<add id=\"usb_transfer_t description\">\n\nAll USB related data types are Simics internal, and should not be\nused by user-defined classes.  The data types may change in future\nversions of Simics.\n\nThe <type>usb_transfer_t</type> type is independent of USB host and\nUSB device implementations and is used for sending data over USB.\n\nThere are two fields to identify the pipe: <var>function_address</var> is\nthe function/device address for the target USB device;\n<var>endpoint_number</var> specifies the endpoint number.\n\nThe type of transfer is defined using the <var>type</var> field. The type is\neither control, bulk, interrupt, or isochronous. The\n<var>u.control_request</var> field is only valid for control transfers. It\ncontains the information that would be in the setup packet of a control\ntransfer. The <var>u.periodic_time</var> field is only valid for periodic\ntransfers, i.e., interrupt and isochronous transfers. It specifies the\nminimum response time for a transfer expected by the USB host. A USB device\ndo not need to fulfill the expectation. It is merely a way to tell the USB\ndevice how to keep the timing specified in the periodic list scheduling.\n\nThe <var>usb_direction</var> field specifies the direction of the data in\nthe USB transfer. Only the actual data packet is used to specify the\ndirection, even if a real transfer consists of a mix of SETUP/OUT/IN/STATUS\npackets. <const>USB_Direction_None</const> means that the transfer does not\ncontain any data, for example, in <type>Set_Address</type> control\ntransfers. <var>size</var> is the number of bytes the USB host can\nreceive for IN transfers and the number of bytes sent for OUT\ntransfers. <var>buf</var> contains the IN or OUT data. Note that <i>buf</i>\ncan contain data for several data packets concatenated together. The\nendpoint descriptors in USB host and USB device define the maximum packet\nsize for the pipe, but there is no limitation in Simics.\n\nThe <var>status</var> field contains the status for the transfer. The status\nis typically only set by the USB device. The USB host does not set the\nstatus field when it has completed an IN transfer.\n\n</add>\n\n<add id=\"usb_transfer_t\">\n<name>usb_transfer_t</name>\n<insert-until text=\"// JDOCU INSERT-UNTIL usb_transfer_t\"/>\n</add>"]
pub type usb_transfer_completion_t = ::std::os::raw::c_uint;
pub const usb_direction_t_USB_Direction_None: usb_direction_t = 0;
pub const usb_direction_t_USB_Direction_In: usb_direction_t = 1;
pub const usb_direction_t_USB_Direction_Out: usb_direction_t = 2;
pub type usb_direction_t = ::std::os::raw::c_uint;
pub const usb_status_t_USB_Status_Undef: usb_status_t = 0;
pub const usb_status_t_USB_Status_Ack: usb_status_t = 1;
pub const usb_status_t_USB_Status_Nak: usb_status_t = 2;
pub const usb_status_t_USB_Status_Stall: usb_status_t = 3;
pub type usb_status_t = ::std::os::raw::c_uint;
pub const usb_type_t_USB_Type_Control: usb_type_t = 0;
pub const usb_type_t_USB_Type_Interrupt: usb_type_t = 1;
pub const usb_type_t_USB_Type_Isochronous: usb_type_t = 2;
pub const usb_type_t_USB_Type_Bulk: usb_type_t = 3;
pub type usb_type_t = ::std::os::raw::c_uint;
pub const usb_speed_t_USB_Speed_Low: usb_speed_t = 0;
pub const usb_speed_t_USB_Speed_Full: usb_speed_t = 1;
pub const usb_speed_t_USB_Speed_High: usb_speed_t = 2;
pub type usb_speed_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct usb_device_request_t {
    pub bmRequestType: uint8,
    pub bRequest: uint8,
    pub wValue: uint16,
    pub wIndex: uint16,
    pub wLength: uint16,
}
#[test]
fn bindgen_test_layout_usb_device_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<usb_device_request_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usb_device_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(usb_device_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_device_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_device_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_request_t),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_request_t),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_request_t),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_request_t),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_request_t),
            "::",
            stringify!(wLength)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_transfer_t {
    #[doc = " Endpoint/function specific information"]
    pub function_address: uint8,
    pub endpoint_number: uint8,
    #[doc = " Type specific information"]
    pub type_: usb_type_t,
    pub u: usb_transfer_t__bindgen_ty_1,
    #[doc = " Data specific"]
    pub direction: usb_direction_t,
    pub size: ::std::os::raw::c_int,
    pub buf: *mut dbuffer_t,
    #[doc = " Status"]
    pub status: usb_status_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union usb_transfer_t__bindgen_ty_1 {
    pub control_request: usb_device_request_t,
    pub periodic_time: nano_secs_t,
}
#[test]
fn bindgen_test_layout_usb_transfer_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<usb_transfer_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usb_transfer_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(usb_transfer_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_transfer_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(usb_transfer_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t__bindgen_ty_1),
            "::",
            stringify!(control_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t__bindgen_ty_1),
            "::",
            stringify!(periodic_time)
        )
    );
}
impl Default for usb_transfer_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_usb_transfer_t() {
    const UNINIT: ::std::mem::MaybeUninit<usb_transfer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usb_transfer_t>(),
        40usize,
        concat!("Size of: ", stringify!(usb_transfer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_transfer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(usb_transfer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(function_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_number) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(endpoint_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_transfer_t),
            "::",
            stringify!(status)
        )
    );
}
impl Default for usb_transfer_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type usb_device_interface_t = usb_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct usb_device_interface {
    pub submit_transfer: ::std::option::Option<
        unsafe extern "C" fn(
            dev_obj: *mut conf_object_t,
            transfer: *mut usb_transfer_t,
        ) -> usb_transfer_completion_t,
    >,
    pub abort_transfer: ::std::option::Option<
        unsafe extern "C" fn(dev_obj: *mut conf_object_t, transfer: *mut usb_transfer_t),
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(dev_obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_usb_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<usb_device_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usb_device_interface>(),
        24usize,
        concat!("Size of: ", stringify!(usb_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(usb_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submit_transfer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_interface),
            "::",
            stringify!(submit_transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_transfer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_interface),
            "::",
            stringify!(abort_transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_interface),
            "::",
            stringify!(reset)
        )
    );
}
pub type usb_interface_t = usb_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct usb_interface {
    pub connect_device: ::std::option::Option<
        unsafe extern "C" fn(
            bus_obj: *mut conf_object_t,
            dev_obj: *mut conf_object_t,
            speed: usb_speed_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub disconnect_device: ::std::option::Option<
        unsafe extern "C" fn(
            bus_obj: *mut conf_object_t,
            dev_obj: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub complete_transfer: ::std::option::Option<
        unsafe extern "C" fn(
            bus_obj: *mut conf_object_t,
            dev_obj: *mut conf_object_t,
            transfer: *mut usb_transfer_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_usb_interface() {
    const UNINIT: ::std::mem::MaybeUninit<usb_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usb_interface>(),
        24usize,
        concat!("Size of: ", stringify!(usb_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(usb_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface),
            "::",
            stringify!(connect_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect_device) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface),
            "::",
            stringify!(disconnect_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complete_transfer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface),
            "::",
            stringify!(complete_transfer)
        )
    );
}
pub const rapidio_operation_t_RapidIO_Read: rapidio_operation_t = 0;
pub const rapidio_operation_t_RapidIO_Write: rapidio_operation_t = 1;
pub const rapidio_operation_t_RapidIO_Increment: rapidio_operation_t = 2;
pub const rapidio_operation_t_RapidIO_Decrement: rapidio_operation_t = 3;
pub const rapidio_operation_t_RapidIO_Test_and_Swap: rapidio_operation_t = 4;
pub const rapidio_operation_t_RapidIO_Set: rapidio_operation_t = 5;
pub const rapidio_operation_t_RapidIO_Clear: rapidio_operation_t = 6;
pub const rapidio_operation_t_RapidIO_Compare_and_Swap: rapidio_operation_t = 7;
pub const rapidio_operation_t_RapidIO_Swap: rapidio_operation_t = 8;
#[doc = " <add-type id=\"rapidio_operation_t def\"></add-type>"]
pub type rapidio_operation_t = ::std::os::raw::c_uint;
pub type rapidio_v3_interface_t = rapidio_v3_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rapidio_v3_interface {
    pub memory_operation: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            destination: uint16,
            source: uint16,
            addr: physical_address_t,
            buf: *mut dbuffer_t,
            op: rapidio_operation_t,
        ),
    >,
    pub doorbell: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            destination: uint16,
            source: uint16,
            data: uint16,
        ),
    >,
    pub deliver_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            destination: uint16,
            source: uint16,
            mbox: uint16,
            letter: uint16,
            data: *mut dbuffer_t,
        ),
    >,
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            destination: uint16,
            source: uint16,
            hopcount: uint8,
            reg_no: ::std::os::raw::c_int,
        ) -> uint32,
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            destination: uint16,
            source: uint16,
            hopcount: uint8,
            reg_no: ::std::os::raw::c_int,
            value: uint32,
        ),
    >,
    pub port_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            hopcount: uint8,
            msg: *mut dbuffer_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rapidio_v3_interface() {
    const UNINIT: ::std::mem::MaybeUninit<rapidio_v3_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rapidio_v3_interface>(),
        48usize,
        concat!("Size of: ", stringify!(rapidio_v3_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<rapidio_v3_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(rapidio_v3_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v3_interface),
            "::",
            stringify!(memory_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doorbell) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v3_interface),
            "::",
            stringify!(doorbell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deliver_message) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v3_interface),
            "::",
            stringify!(deliver_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v3_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v3_interface),
            "::",
            stringify!(write_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v3_interface),
            "::",
            stringify!(port_write)
        )
    );
}
pub type rapidio_v4_interface_t = rapidio_v4_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rapidio_v4_interface {
    pub transaction_request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            addr: uint64,
            op: rapidio_operation_t,
            msg: bytes_t,
            id: uint64,
        ),
    >,
    pub transaction_response: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, msg: bytes_t, id: uint64),
    >,
    pub doorbell: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            val: uint16,
        ),
    >,
    pub deliver_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            mbox: uint16,
            letter: uint16,
            msg: bytes_t,
        ),
    >,
    pub read_register_request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            hopcount: uint8,
            reg_no: uint32,
            id: uint64,
        ),
    >,
    pub read_register_response: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, val: uint32, id: uint64),
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            hopcount: uint8,
            reg_no: uint32,
            val: uint32,
        ),
    >,
    pub port_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            hopcount: uint8,
            msg: bytes_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rapidio_v4_interface() {
    const UNINIT: ::std::mem::MaybeUninit<rapidio_v4_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rapidio_v4_interface>(),
        64usize,
        concat!("Size of: ", stringify!(rapidio_v4_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<rapidio_v4_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(rapidio_v4_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(transaction_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction_response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(transaction_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doorbell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(doorbell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deliver_message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(deliver_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register_request) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(read_register_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register_response) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(read_register_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(write_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_write) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v4_interface),
            "::",
            stringify!(port_write)
        )
    );
}
pub type rapidio_v5_interface_t = rapidio_v5_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rapidio_v5_interface {
    pub transaction_request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            addr: uint64,
            op: rapidio_operation_t,
            msg: bytes_t,
            id: uint64,
        ),
    >,
    pub transaction_response: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, msg: bytes_t, id: uint64),
    >,
    pub doorbell: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            val: uint16,
        ),
    >,
    pub deliver_message: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            mbox: uint16,
            letter: uint16,
            msg: bytes_t,
        ),
    >,
    pub read_register_request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            hopcount: uint8,
            reg_no: uint32,
            id: uint64,
        ),
    >,
    pub read_register_response: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, val: uint32, id: uint64),
    >,
    pub write_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            hopcount: uint8,
            reg_no: uint32,
            val: uint32,
        ),
    >,
    pub port_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            hopcount: uint8,
            msg: bytes_t,
        ),
    >,
    pub stream_data: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target_id: uint16,
            source_id: uint16,
            transport_class: uint32,
            cos: uint8,
            xh: uint8,
            stream_id: uint16,
            pdu: bytes_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rapidio_v5_interface() {
    const UNINIT: ::std::mem::MaybeUninit<rapidio_v5_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rapidio_v5_interface>(),
        72usize,
        concat!("Size of: ", stringify!(rapidio_v5_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<rapidio_v5_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(rapidio_v5_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(transaction_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction_response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(transaction_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doorbell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(doorbell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deliver_message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(deliver_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register_request) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(read_register_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register_response) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(read_register_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_register) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(write_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_write) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(port_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rapidio_v5_interface),
            "::",
            stringify!(stream_data)
        )
    );
}
pub const eth_frame_crc_status_t_Eth_Frame_CRC_Match: eth_frame_crc_status_t = 0;
pub const eth_frame_crc_status_t_Eth_Frame_CRC_Mismatch: eth_frame_crc_status_t = 1;
pub const eth_frame_crc_status_t_Eth_Frame_CRC_Unknown: eth_frame_crc_status_t = 2;
#[doc = " <add-type id=\"eth_frame_crc_status_t\">\n<ul>\n<li><tt>Eth_Frame_CRC_Match</tt> means that the frame contents are\ncorrect. The CRC field in the frame should not be relied upon as its\ncomputation may have been skipped for optimization, and it may contain any\nvalue, including zero, a random value or a correctly computed CRC.</li>\n\n<li><tt>Eth_Frame_CRC_Mismatch</tt> means that the frame contents are\nincorrect. The CRC field in the frame must contain a CRC that does not\nmatch the frame contents, i.e., to send an incorrect frame on the link,\nyou must make sure that the CRC field will not match when computed.</li>\n\n<li><tt>Eth_Frame_CRC_Unknown</tt> means that the relation between the\nframe contents and the CRC field is unknown. The relation can be\nestablished by computing the frame's CRC and comparing it to the frame's\nCRC field.</li>\n</ul>\n</add-type>"]
pub type eth_frame_crc_status_t = ::std::os::raw::c_uint;
pub type ethernet_common_interface_t = ethernet_common_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ethernet_common_interface {
    pub frame: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            frame: *const frags_t,
            crc_status: eth_frame_crc_status_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ethernet_common_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ethernet_common_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethernet_common_interface>(),
        8usize,
        concat!("Size of: ", stringify!(ethernet_common_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ethernet_common_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ethernet_common_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_common_interface),
            "::",
            stringify!(frame)
        )
    );
}
pub type ethernet_cable_interface_t = ethernet_cable_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ethernet_cable_interface {
    pub link_status:
        ::std::option::Option<unsafe extern "C" fn(ep: *mut conf_object_t, link_up: bool)>,
}
#[test]
fn bindgen_test_layout_ethernet_cable_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ethernet_cable_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethernet_cable_interface>(),
        8usize,
        concat!("Size of: ", stringify!(ethernet_cable_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ethernet_cable_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ethernet_cable_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_cable_interface),
            "::",
            stringify!(link_status)
        )
    );
}
#[doc = " <add-type id=\"ethernet_link_snoop_t\"></add-type>"]
pub type ethernet_link_snoop_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut lang_void,
        clock: *mut conf_object_t,
        packet: *const frags_t,
        crc_status: eth_frame_crc_status_t,
    ),
>;
pub type ethernet_snoop_interface_t = ethernet_snoop_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ethernet_snoop_interface {
    pub attach: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            clock: *mut conf_object_t,
            snoop_fun: ethernet_link_snoop_t,
            user_data: *mut lang_void,
        ) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_ethernet_snoop_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ethernet_snoop_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethernet_snoop_interface>(),
        8usize,
        concat!("Size of: ", stringify!(ethernet_snoop_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ethernet_snoop_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ethernet_snoop_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_snoop_interface),
            "::",
            stringify!(attach)
        )
    );
}
pub type ethernet_vlan_snoop_interface_t = ethernet_vlan_snoop_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ethernet_vlan_snoop_interface {
    pub attach: ::std::option::Option<
        unsafe extern "C" fn(
            link: *mut conf_object_t,
            clock: *mut conf_object_t,
            snoop_fun: ethernet_link_snoop_t,
            user_data: *mut lang_void,
            vlan_id: uint16,
            is_vlan_trunk: bool,
        ) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_ethernet_vlan_snoop_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ethernet_vlan_snoop_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethernet_vlan_snoop_interface>(),
        8usize,
        concat!("Size of: ", stringify!(ethernet_vlan_snoop_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ethernet_vlan_snoop_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ethernet_vlan_snoop_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_vlan_snoop_interface),
            "::",
            stringify!(attach)
        )
    );
}
pub type microwire_interface_t = microwire_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct microwire_interface {
    pub set_cs: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cs: ::std::os::raw::c_int),
    >,
    pub set_sk: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, sk: ::std::os::raw::c_int),
    >,
    pub set_di: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, di: ::std::os::raw::c_int),
    >,
    pub get_do: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub read_word: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, offset: ::std::os::raw::c_int) -> uint16,
    >,
    pub write_word: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, offset: ::std::os::raw::c_int, value: uint16),
    >,
}
#[test]
fn bindgen_test_layout_microwire_interface() {
    const UNINIT: ::std::mem::MaybeUninit<microwire_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<microwire_interface>(),
        48usize,
        concat!("Size of: ", stringify!(microwire_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<microwire_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(microwire_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(microwire_interface),
            "::",
            stringify!(set_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_sk) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(microwire_interface),
            "::",
            stringify!(set_sk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_di) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(microwire_interface),
            "::",
            stringify!(set_di)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_do) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(microwire_interface),
            "::",
            stringify!(get_do)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_word) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(microwire_interface),
            "::",
            stringify!(read_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_word) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(microwire_interface),
            "::",
            stringify!(write_word)
        )
    );
}
pub type sata_interface_t = sata_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sata_interface {
    pub receive_fis:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, fis: bytes_t)>,
}
#[test]
fn bindgen_test_layout_sata_interface() {
    const UNINIT: ::std::mem::MaybeUninit<sata_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sata_interface>(),
        8usize,
        concat!("Size of: ", stringify!(sata_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<sata_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(sata_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_fis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sata_interface),
            "::",
            stringify!(receive_fis)
        )
    );
}
pub const eth_probe_side_t_Eth_Probe_Port_A: eth_probe_side_t = 0;
pub const eth_probe_side_t_Eth_Probe_Port_B: eth_probe_side_t = 1;
#[doc = " <add id=\"eth_probe_side_t\">\n<insert-until text=\"// END eth_probe_side_t\"/>\n</add>"]
pub type eth_probe_side_t = ::std::os::raw::c_uint;
#[doc = " <add id=\"ethernet_probe_snoop_t\">\n<insert-until text=\"// END ethernet_probe_snoop_t\"/>\n</add>"]
pub type ethernet_probe_snoop_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut lang_void,
        probe: *mut conf_object_t,
        to_side: eth_probe_side_t,
        frame: *const frags_t,
        crc_status: eth_frame_crc_status_t,
    ),
>;
pub type ethernet_probe_interface_t = ethernet_probe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ethernet_probe_interface {
    pub attach_snooper: ::std::option::Option<
        unsafe extern "C" fn(
            probe: *mut conf_object_t,
            snoop_fun: ethernet_probe_snoop_t,
            user_data: *mut lang_void,
        ),
    >,
    pub attach_probe: ::std::option::Option<
        unsafe extern "C" fn(
            probe: *mut conf_object_t,
            snoop_fun: ethernet_probe_snoop_t,
            user_data: *mut lang_void,
        ),
    >,
    pub detach: ::std::option::Option<unsafe extern "C" fn(probe: *mut conf_object_t)>,
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(
            probe: *mut conf_object_t,
            to_side: eth_probe_side_t,
            frame: *const frags_t,
            crc_status: eth_frame_crc_status_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ethernet_probe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ethernet_probe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethernet_probe_interface>(),
        32usize,
        concat!("Size of: ", stringify!(ethernet_probe_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ethernet_probe_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ethernet_probe_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach_snooper) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_probe_interface),
            "::",
            stringify!(attach_snooper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach_probe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_probe_interface),
            "::",
            stringify!(attach_probe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detach) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_probe_interface),
            "::",
            stringify!(detach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_frame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethernet_probe_interface),
            "::",
            stringify!(send_frame)
        )
    );
}
pub type mod_def_t = ::std::os::raw::c_int;
pub type gbic_transceiver_interface_t = gbic_transceiver_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gbic_transceiver_interface {
    pub read_mod_def:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> mod_def_t>,
    pub write_mod_def:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, mod_def: mod_def_t)>,
    pub loopback: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, loopback: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_gbic_transceiver_interface() {
    const UNINIT: ::std::mem::MaybeUninit<gbic_transceiver_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gbic_transceiver_interface>(),
        24usize,
        concat!("Size of: ", stringify!(gbic_transceiver_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<gbic_transceiver_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(gbic_transceiver_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_mod_def) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gbic_transceiver_interface),
            "::",
            stringify!(read_mod_def)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_mod_def) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gbic_transceiver_interface),
            "::",
            stringify!(write_mod_def)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loopback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gbic_transceiver_interface),
            "::",
            stringify!(loopback)
        )
    );
}
#[doc = " not connected at all"]
pub const ieee_802_3_media_t_IEEE_no_media: ieee_802_3_media_t = 0;
#[doc = " media type is unknown"]
pub const ieee_802_3_media_t_IEEE_media_unknown: ieee_802_3_media_t = 1;
#[doc = " 10 Mb/s CSMA/CD LAN over RG 58 coaxial cable"]
pub const ieee_802_3_media_t_IEEE_10base2: ieee_802_3_media_t = 2;
#[doc = " 10 Mb/s CSMA/CD LAN over coaxial cable\n(i.e., thicknet)"]
pub const ieee_802_3_media_t_IEEE_10base5: ieee_802_3_media_t = 3;
#[doc = " 10 Mb/s CSMA/CD LAN over fiber optic cable"]
pub const ieee_802_3_media_t_IEEE_10baseF: ieee_802_3_media_t = 4;
#[doc = " 10 Mb/s CSMA/CD LAN over two pairs of\ntwisted-pair telephone wire"]
pub const ieee_802_3_media_t_IEEE_10baseT: ieee_802_3_media_t = 5;
#[doc = " 100 Mb/s CSMA/CD LAN over two optical fibers"]
pub const ieee_802_3_media_t_IEEE_100baseFX: ieee_802_3_media_t = 6;
#[doc = " 100 Mb/s CSMA/CD LAN"]
pub const ieee_802_3_media_t_IEEE_100baseT: ieee_802_3_media_t = 7;
#[doc = " 100 Mb/s CSMA/CD LAN over two pairs of cat 3\nor better balanced cabling"]
pub const ieee_802_3_media_t_IEEE_100baseT2: ieee_802_3_media_t = 8;
#[doc = " 100 Mb/s CSMA/CD LAN over four pairs of cat 3,\n4, and 5 UTP wire"]
pub const ieee_802_3_media_t_IEEE_100baseT4: ieee_802_3_media_t = 9;
#[doc = " 100 Mb/s CSMA/CD LAN over two pairs of cat 5\nUTP or STP wire"]
pub const ieee_802_3_media_t_IEEE_100baseTX: ieee_802_3_media_t = 10;
#[doc = " 100 Mb/s CSMA/CD LAN with PMD and MDI of\nISO/IEC 9314 by ASC X3T12 (FDDI)"]
pub const ieee_802_3_media_t_IEEE_100baseX: ieee_802_3_media_t = 11;
#[doc = " 1000 Mb/s CSMA/CD LAN derived from\nANSI X3.230-1994 (FC-PH) [B20]11"]
pub const ieee_802_3_media_t_IEEE_1000baseX: ieee_802_3_media_t = 12;
#[doc = " 1000BASE-X over specially shielded balanced\ncopper jumper cable assemblies"]
pub const ieee_802_3_media_t_IEEE_1000baseCX: ieee_802_3_media_t = 13;
#[doc = " 1000BASE-X using long wavelength laser over\nmultimode and single-mode fiber"]
pub const ieee_802_3_media_t_IEEE_1000baseLX: ieee_802_3_media_t = 14;
#[doc = " 1000BASE-X using short wavelength laser over\nmultimode fiber"]
pub const ieee_802_3_media_t_IEEE_1000baseSX: ieee_802_3_media_t = 15;
#[doc = " 1000 Mb/s CSMA/CD LAN using four pairs of cat 5\nbalanced copper cabling"]
pub const ieee_802_3_media_t_IEEE_1000baseT: ieee_802_3_media_t = 16;
#[doc = " 10 Mb/s CSMA/CD LAN over single broadband\ncable"]
pub const ieee_802_3_media_t_IEEE_10broad36: ieee_802_3_media_t = 17;
#[doc = " 1 Mb/s CSMA/CD LAN over two pairs of\ntwisted-pair telephone wire"]
pub const ieee_802_3_media_t_IEEE_1base5: ieee_802_3_media_t = 18;
pub type ieee_802_3_media_t = ::std::os::raw::c_uint;
pub const ieee_802_3_duplex_mode_t_IEEE_half_duplex: ieee_802_3_duplex_mode_t = 0;
pub const ieee_802_3_duplex_mode_t_IEEE_full_duplex: ieee_802_3_duplex_mode_t = 1;
pub type ieee_802_3_duplex_mode_t = ::std::os::raw::c_uint;
pub const ieee_802_3_link_status_t_IEEE_link_unconnected: ieee_802_3_link_status_t = 0;
pub const ieee_802_3_link_status_t_IEEE_link_down: ieee_802_3_link_status_t = 1;
pub const ieee_802_3_link_status_t_IEEE_link_up: ieee_802_3_link_status_t = 2;
#[doc = " <add-type id=\"ieee_802_3_link_status_t\"></add-type>"]
pub type ieee_802_3_link_status_t = ::std::os::raw::c_uint;
pub type ieee_802_3_phy_interface_t = ieee_802_3_phy_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ieee_802_3_phy_interface {
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            buf: *mut dbuffer_t,
            replace_crc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_tx_bandwidth: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub add_mac:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, mac: *const uint8)>,
    pub del_mac:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, mac: *const uint8)>,
    pub add_mac_mask: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, mac: *const uint8, mask: *const uint8),
    >,
    pub del_mac_mask: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, mac: *const uint8, mask: *const uint8),
    >,
    pub set_promiscous_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, enable: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_ieee_802_3_phy_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_3_phy_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_3_phy_interface>(),
        56usize,
        concat!("Size of: ", stringify!(ieee_802_3_phy_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_3_phy_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_802_3_phy_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(send_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_tx_bandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(check_tx_bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_mac) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(add_mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_mac) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(del_mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_mac_mask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(add_mac_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_mac_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(del_mac_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_promiscous_mode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_interface),
            "::",
            stringify!(set_promiscous_mode)
        )
    );
}
pub type ieee_802_3_phy_v2_interface_t = ieee_802_3_phy_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ieee_802_3_phy_v2_interface {
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            buf: *mut dbuffer_t,
            replace_crc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_tx_bandwidth: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub add_mac:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, mac: byte_string_t)>,
    pub del_mac:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, mac: byte_string_t)>,
    pub add_mac_mask: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, mac: byte_string_t, mask: byte_string_t),
    >,
    pub del_mac_mask: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, mac: byte_string_t, mask: byte_string_t),
    >,
    pub set_promiscous_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, enable: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_ieee_802_3_phy_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_3_phy_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_3_phy_v2_interface>(),
        56usize,
        concat!("Size of: ", stringify!(ieee_802_3_phy_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_3_phy_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_802_3_phy_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(send_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_tx_bandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(check_tx_bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_mac) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(add_mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_mac) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(del_mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_mac_mask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(add_mac_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del_mac_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(del_mac_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_promiscous_mode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v2_interface),
            "::",
            stringify!(set_promiscous_mode)
        )
    );
}
pub type ieee_802_3_phy_v3_interface_t = ieee_802_3_phy_v3_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ieee_802_3_phy_v3_interface {
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            frame: *const frags_t,
            replace_crc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_tx_bandwidth: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_ieee_802_3_phy_v3_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_3_phy_v3_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_3_phy_v3_interface>(),
        16usize,
        concat!("Size of: ", stringify!(ieee_802_3_phy_v3_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_3_phy_v3_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_802_3_phy_v3_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v3_interface),
            "::",
            stringify!(send_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_tx_bandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_phy_v3_interface),
            "::",
            stringify!(check_tx_bandwidth)
        )
    );
}
pub type ieee_802_3_mac_interface_t = ieee_802_3_mac_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ieee_802_3_mac_interface {
    pub receive_frame: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            buf: *mut dbuffer_t,
            crc_ok: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub tx_bandwidth_available: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, phy: ::std::os::raw::c_int),
    >,
    pub link_status_changed: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            status: ieee_802_3_link_status_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ieee_802_3_mac_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_3_mac_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_3_mac_interface>(),
        24usize,
        concat!("Size of: ", stringify!(ieee_802_3_mac_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_3_mac_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_802_3_mac_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_mac_interface),
            "::",
            stringify!(receive_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_bandwidth_available) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_mac_interface),
            "::",
            stringify!(tx_bandwidth_available)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_status_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_mac_interface),
            "::",
            stringify!(link_status_changed)
        )
    );
}
pub type ieee_802_3_mac_v3_interface_t = ieee_802_3_mac_v3_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ieee_802_3_mac_v3_interface {
    pub receive_frame: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            frame: *const frags_t,
            crc_ok: ::std::os::raw::c_int,
        ),
    >,
    pub tx_bandwidth_available: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, phy: ::std::os::raw::c_int),
    >,
    pub link_status_changed: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            phy: ::std::os::raw::c_int,
            status: ieee_802_3_link_status_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ieee_802_3_mac_v3_interface() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_3_mac_v3_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_3_mac_v3_interface>(),
        24usize,
        concat!("Size of: ", stringify!(ieee_802_3_mac_v3_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_3_mac_v3_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_802_3_mac_v3_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_mac_v3_interface),
            "::",
            stringify!(receive_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_bandwidth_available) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_mac_v3_interface),
            "::",
            stringify!(tx_bandwidth_available)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_status_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_3_mac_v3_interface),
            "::",
            stringify!(link_status_changed)
        )
    );
}
pub type vectored_interrupt_interface_t = vectored_interrupt_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vectored_interrupt_interface {
    pub set_level: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            source: *mut conf_object_t,
            level: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vectored_interrupt_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vectored_interrupt_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vectored_interrupt_interface>(),
        8usize,
        concat!("Size of: ", stringify!(vectored_interrupt_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vectored_interrupt_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vectored_interrupt_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vectored_interrupt_interface),
            "::",
            stringify!(set_level)
        )
    );
}
pub type vectored_interrupt_source_interface_t = vectored_interrupt_source_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vectored_interrupt_source_interface {
    pub acknowledge: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            target: *mut conf_object_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_vectored_interrupt_source_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vectored_interrupt_source_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vectored_interrupt_source_interface>(),
        8usize,
        concat!("Size of: ", stringify!(vectored_interrupt_source_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vectored_interrupt_source_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vectored_interrupt_source_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vectored_interrupt_source_interface),
            "::",
            stringify!(acknowledge)
        )
    );
}
pub const i2c_device_state_I2C_idle: i2c_device_state = 0;
pub const i2c_device_state_I2C_master_transmit: i2c_device_state = 1;
pub const i2c_device_state_I2C_master_receive: i2c_device_state = 2;
pub const i2c_device_state_I2C_slave_transmit: i2c_device_state = 3;
pub const i2c_device_state_I2C_slave_receive: i2c_device_state = 4;
pub const i2c_device_state_I2C_max_states: i2c_device_state = 5;
pub type i2c_device_state = ::std::os::raw::c_uint;
pub use self::i2c_device_state as i2c_device_state_t;
pub const i2c_device_flag_t_I2C_flag_exclusive: i2c_device_flag_t = 0;
pub const i2c_device_flag_t_I2C_flag_shared: i2c_device_flag_t = 1;
#[doc = " <add-type id=\"i2c_device_flag_t def\">\n</add-type>"]
pub type i2c_device_flag_t = ::std::os::raw::c_uint;
pub type i2c_bus_interface_t = i2c_bus_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_bus_interface {
    pub start: ::std::option::Option<
        unsafe extern "C" fn(i2c_bus: *mut conf_object_t, address: uint8) -> ::std::os::raw::c_int,
    >,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(i2c_bus: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub read_data:
        ::std::option::Option<unsafe extern "C" fn(i2c_bus: *mut conf_object_t) -> uint8>,
    pub write_data:
        ::std::option::Option<unsafe extern "C" fn(i2c_bus: *mut conf_object_t, value: uint8)>,
    pub register_device: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_bus: *mut conf_object_t,
            device: *mut conf_object_t,
            address: uint8,
            mask: uint8,
            flags: i2c_device_flag_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub unregister_device: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_bus: *mut conf_object_t,
            device: *mut conf_object_t,
            address: uint8,
            mask: uint8,
        ),
    >,
}
#[test]
fn bindgen_test_layout_i2c_bus_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_bus_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_bus_interface>(),
        48usize,
        concat!("Size of: ", stringify!(i2c_bus_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_bus_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_bus_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bus_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bus_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bus_interface),
            "::",
            stringify!(read_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bus_interface),
            "::",
            stringify!(write_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_device) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bus_interface),
            "::",
            stringify!(register_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_device) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bus_interface),
            "::",
            stringify!(unregister_device)
        )
    );
}
pub type i2c_device_interface_t = i2c_device_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_device_interface {
    pub set_state: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut conf_object_t,
            state: i2c_device_state_t,
            address: uint8,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_data: ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t) -> uint8>,
    pub write_data:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, value: uint8)>,
}
#[test]
fn bindgen_test_layout_i2c_device_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_device_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_device_interface>(),
        24usize,
        concat!("Size of: ", stringify!(i2c_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_device_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_device_interface),
            "::",
            stringify!(set_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_device_interface),
            "::",
            stringify!(read_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_device_interface),
            "::",
            stringify!(write_data)
        )
    );
}
#[doc = " The ACK bit related to the operation was 0. This typically\nmeans that the operation was successful"]
pub const i2c_status_t_I2C_status_success: i2c_status_t = 0;
#[doc = " The ACK bit related to the operation was 1. This typically\nmeans that the operation was unsuccessful"]
pub const i2c_status_t_I2C_status_noack: i2c_status_t = 1;
#[doc = " The operation could not be carried out, because the link is\ncurrently in use by another master"]
pub const i2c_status_t_I2C_status_bus_busy: i2c_status_t = 2;
pub type i2c_status_t = ::std::os::raw::c_uint;
pub type i2c_link_interface_t = i2c_link_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_link_interface {
    pub register_slave_address: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            slave: *mut conf_object_t,
            address: uint32,
            mask: uint32,
        ),
    >,
    pub unregister_slave_address: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            slave: *mut conf_object_t,
            address: uint32,
            mask: uint32,
        ),
    >,
    pub register_bridge: ::std::option::Option<
        unsafe extern "C" fn(i2c_link: *mut conf_object_t, bridge: *mut conf_object_t),
    >,
    pub disconnect_device: ::std::option::Option<
        unsafe extern "C" fn(i2c_link: *mut conf_object_t, device: *mut conf_object_t),
    >,
    pub start_request: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            master: *mut conf_object_t,
            address: uint32,
        ),
    >,
    pub read_request: ::std::option::Option<
        unsafe extern "C" fn(i2c_link: *mut conf_object_t, master: *mut conf_object_t),
    >,
    pub ack_read_request: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            master: *mut conf_object_t,
            ack: i2c_status_t,
        ),
    >,
    pub write_request: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            master: *mut conf_object_t,
            value: uint8,
        ),
    >,
    pub read_response: ::std::option::Option<
        unsafe extern "C" fn(i2c_link: *mut conf_object_t, slave: *mut conf_object_t, value: uint8),
    >,
    pub ack_read_response: ::std::option::Option<
        unsafe extern "C" fn(i2c_link: *mut conf_object_t, slave: *mut conf_object_t),
    >,
    pub write_response: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            slave: *mut conf_object_t,
            status: i2c_status_t,
        ),
    >,
    pub start_response: ::std::option::Option<
        unsafe extern "C" fn(
            i2c_link: *mut conf_object_t,
            slave: *mut conf_object_t,
            status: i2c_status_t,
        ),
    >,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(i2c_link: *mut conf_object_t, master: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_i2c_link_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_link_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_link_interface>(),
        104usize,
        concat!("Size of: ", stringify!(i2c_link_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_link_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_link_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_slave_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(register_slave_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_slave_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(unregister_slave_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_bridge) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(register_bridge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect_device) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(disconnect_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_request) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(start_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_request) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(read_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack_read_request) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(ack_read_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_request) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(write_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_response) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(read_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack_read_response) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(ack_read_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_response) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(write_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_response) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(start_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_link_interface),
            "::",
            stringify!(stop)
        )
    );
}
pub type i2c_slave_interface_t = i2c_slave_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_slave_interface {
    pub start_request:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, address: uint32)>,
    pub read_request: ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t)>,
    pub ack_read_request:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, ack: i2c_status_t)>,
    pub write_request:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, value: uint8)>,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(device: *mut conf_object_t, repeated_start: uint8),
    >,
}
#[test]
fn bindgen_test_layout_i2c_slave_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_slave_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_slave_interface>(),
        40usize,
        concat!("Size of: ", stringify!(i2c_slave_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_slave_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_slave_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_interface),
            "::",
            stringify!(start_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_request) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_interface),
            "::",
            stringify!(read_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack_read_request) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_interface),
            "::",
            stringify!(ack_read_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_request) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_interface),
            "::",
            stringify!(write_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_interface),
            "::",
            stringify!(stop)
        )
    );
}
pub type i2c_master_interface_t = i2c_master_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_master_interface {
    pub bus_freed: ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t)>,
    pub read_response:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, value: uint8)>,
    pub ack_read_response: ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t)>,
    pub write_response: ::std::option::Option<
        unsafe extern "C" fn(device: *mut conf_object_t, status: i2c_status_t),
    >,
    pub start_response: ::std::option::Option<
        unsafe extern "C" fn(device: *mut conf_object_t, status: i2c_status_t),
    >,
}
#[test]
fn bindgen_test_layout_i2c_master_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_master_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_master_interface>(),
        40usize,
        concat!("Size of: ", stringify!(i2c_master_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_master_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_master_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus_freed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_interface),
            "::",
            stringify!(bus_freed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_interface),
            "::",
            stringify!(read_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack_read_response) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_interface),
            "::",
            stringify!(ack_read_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_response) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_interface),
            "::",
            stringify!(write_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_response) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_interface),
            "::",
            stringify!(start_response)
        )
    );
}
pub type i2c_bridge_interface_t = i2c_bridge_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_bridge_interface {
    pub address_added: ::std::option::Option<
        unsafe extern "C" fn(device: *mut conf_object_t, addr: uint32, mask: uint32),
    >,
    pub address_removed: ::std::option::Option<
        unsafe extern "C" fn(device: *mut conf_object_t, addr: uint32, mask: uint32),
    >,
}
#[test]
fn bindgen_test_layout_i2c_bridge_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_bridge_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_bridge_interface>(),
        16usize,
        concat!("Size of: ", stringify!(i2c_bridge_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_bridge_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_bridge_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_added) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bridge_interface),
            "::",
            stringify!(address_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_removed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_bridge_interface),
            "::",
            stringify!(address_removed)
        )
    );
}
pub type i2c_slave_v2_interface_t = i2c_slave_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_slave_v2_interface {
    pub start:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, address: uint8)>,
    pub read: ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t)>,
    pub write:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, value: uint8)>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t)>,
    pub addresses:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_i2c_slave_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_slave_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_slave_v2_interface>(),
        40usize,
        concat!("Size of: ", stringify!(i2c_slave_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_slave_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_slave_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_v2_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_v2_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_v2_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_v2_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addresses) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_slave_v2_interface),
            "::",
            stringify!(addresses)
        )
    );
}
pub const i2c_ack_t_I2C_ack: i2c_ack_t = 0;
pub const i2c_ack_t_I2C_noack: i2c_ack_t = 1;
#[doc = " <add id=\"i2c_master_v2_interface_t\">\n<insert-until text=\"// ADD INTERFACE i2c_master_v2_interface\"/>\n\nThe <iface>i2c_master_v2</iface> interface should be implemented\nby devices that intend to act as a master on an I2C link.\n\nThe function <fun>acknowledge</fun> is called in response to a\n<fun>start</fun> or <fun>write</fun> call in the\n<iface>i2c_slave_v2</iface> interface of the slave device.\n<fun>read_response</fun> is called as response to a\n<fun>read</fun> call.  More details can be found in the\ndocumentation of the <nref\nlabel=\"__rm_interface_i2c_slave_v2\">i2c_slave_v2</nref> interface.\n\n</add>\n<add id=\"i2c_master_v2_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type i2c_ack_t = ::std::os::raw::c_uint;
pub type i2c_master_v2_interface_t = i2c_master_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct i2c_master_v2_interface {
    pub acknowledge:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, ack: i2c_ack_t)>,
    pub read_response:
        ::std::option::Option<unsafe extern "C" fn(device: *mut conf_object_t, value: uint8)>,
}
#[test]
fn bindgen_test_layout_i2c_master_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_master_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_master_v2_interface>(),
        16usize,
        concat!("Size of: ", stringify!(i2c_master_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_master_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_master_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_v2_interface),
            "::",
            stringify!(acknowledge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_master_v2_interface),
            "::",
            stringify!(read_response)
        )
    );
}
pub type hpi_interface_t = hpi_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hpi_interface {
    #[doc = " HCNTL = 0"]
    pub read_hpic: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub write_hpic:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint32)>,
    #[doc = " HCNTL = 1"]
    pub read_hpia: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint32>,
    pub write_hpia:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint32)>,
    #[doc = " HCNTL = 1 (autoincrement == 0) */\n/* HCNTL = 2 (autoincrement == 1)"]
    pub read_hpid: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            autoincrement: ::std::os::raw::c_int,
        ) -> uint32,
    >,
    pub write_hpid: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            value: uint32,
            autoincrement: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_hpi_interface() {
    const UNINIT: ::std::mem::MaybeUninit<hpi_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hpi_interface>(),
        48usize,
        concat!("Size of: ", stringify!(hpi_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<hpi_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(hpi_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_hpic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hpi_interface),
            "::",
            stringify!(read_hpic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_hpic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hpi_interface),
            "::",
            stringify!(write_hpic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_hpia) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hpi_interface),
            "::",
            stringify!(read_hpia)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_hpia) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hpi_interface),
            "::",
            stringify!(write_hpia)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_hpid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hpi_interface),
            "::",
            stringify!(read_hpid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_hpid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hpi_interface),
            "::",
            stringify!(write_hpid)
        )
    );
}
extern "C" {
    pub fn VT_push_exc_ppg_entry(key: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn VT_pop_exc_ppg_entry(
        key: *mut ::std::os::raw::c_void,
        function: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn VT_report_uncaught_exceptions();
}
extern "C" {
    pub fn VT_obtain_python_lock() -> bool;
}
extern "C" {
    pub fn VT_release_python_lock(old_lock_state: bool);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct trampoline_data {
    #[doc = " trampoline template"]
    pub templ: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " size of the trampoline template"]
    pub size: usize,
    pub offsets: trampoline_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct trampoline_data__bindgen_ty_1 {
    #[doc = " offsets of hi/lo 32 bits of the C function address"]
    pub function_hi: usize,
    #[doc = " offsets of hi/lo 32 bits of the C function address"]
    pub function_lo: usize,
    #[doc = " offsets of hi/lo 32 bits of the data address"]
    pub data_hi: usize,
    #[doc = " offsets of hi/lo 32 bits of the data address"]
    pub data_lo: usize,
}
#[test]
fn bindgen_test_layout_trampoline_data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<trampoline_data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<trampoline_data__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(trampoline_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<trampoline_data__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(trampoline_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function_hi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data__bindgen_ty_1),
            "::",
            stringify!(function_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function_lo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data__bindgen_ty_1),
            "::",
            stringify!(function_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_hi) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data__bindgen_ty_1),
            "::",
            stringify!(data_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_lo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data__bindgen_ty_1),
            "::",
            stringify!(data_lo)
        )
    );
}
#[test]
fn bindgen_test_layout_trampoline_data() {
    const UNINIT: ::std::mem::MaybeUninit<trampoline_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<trampoline_data>(),
        48usize,
        concat!("Size of: ", stringify!(trampoline_data))
    );
    assert_eq!(
        ::std::mem::align_of::<trampoline_data>(),
        8usize,
        concat!("Alignment of ", stringify!(trampoline_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).templ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data),
            "::",
            stringify!(templ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_data),
            "::",
            stringify!(offsets)
        )
    );
}
pub type trampoline_data_t = trampoline_data;
pub type opaque_type_t = opaque_type;
extern "C" {
    #[doc = " obsolete, for ABI compatibility with simics < 6.0.161"]
    pub fn VT_register_py_interface(
        iface_name: *const ::std::os::raw::c_char,
        pytype: *mut _typeobject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " obsolete,  for ABI compatibility with simics < 6.0.161"]
    pub fn VT_get_py_interface(iface_name: *const ::std::os::raw::c_char) -> *mut _typeobject;
}
extern "C" {
    #[doc = " obsolete, for ABI compatibility with simics < 6.0.162"]
    pub fn VT_register_python_interface(
        iface_name: *const ::std::os::raw::c_char,
        ot: *mut opaque_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " obsolete, for ABI compatibility with simics < 6.0.162"]
    pub fn VT_get_python_interface(iface_name: *const ::std::os::raw::c_char)
        -> *mut opaque_type_t;
}
extern "C" {
    pub fn VT_python_wrap_conf_object(data: *mut conf_object_t) -> *mut _object;
}
extern "C" {
    pub fn VT_python_unwrap_conf_object(pyobj: *mut _object) -> *mut conf_object_t;
}
extern "C" {
    pub fn VT_handle_python_exception(
        return_source: *mut _object,
        signature: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_raise_python_exception(
        exc_type: sim_exception_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn VT_attr_value_to_python_obj(
        value: *mut attr_value_t,
        err_msg: *mut *const ::std::os::raw::c_char,
    ) -> *mut _object;
}
extern "C" {
    pub fn VT_python_obj_to_attr_value_with_error(
        obj: *mut _object,
        ret: *mut attr_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_byte_string_to_pyobject(bstr: byte_string_t, po: *mut *mut _object);
}
extern "C" {
    pub fn VT_pyobject_to_byte_string(
        po: *mut _object,
        bstr: *mut byte_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VT_pyobject_to_buffer_t(b: *mut buffer_t, obj: *mut _object) -> bool;
}
extern "C" {
    pub fn VT_buffer_t_to_pyobject(b: buffer_t) -> *mut _object;
}
extern "C" {
    pub fn VT_buffer_t_pyobject_invalidate(obj: *mut _object);
}
#[doc = " struct to hold data about each type of generated trampolines (one\nper signature)"]
pub type py_wrap_c_func_t = py_wrap_c_func;
#[doc = " converter functions from/to a struct field type"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct field_type_t {
    #[doc = " of type"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " conversion from Python: return 0 on success, -1 on error"]
    pub from_py: ::std::option::Option<
        unsafe extern "C" fn(
            generic_dst: *mut ::std::os::raw::c_void,
            pysrc: *mut _object,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " conversion to Python: shouldn't fail"]
    pub to_py: ::std::option::Option<
        unsafe extern "C" fn(
            generic_src: *mut ::std::os::raw::c_void,
            object: *mut conf_object_t,
        ) -> *mut _object,
    >,
    #[doc = " optional function to free C data; must not fail"]
    pub free_fn:
        ::std::option::Option<unsafe extern "C" fn(generic_data: *mut ::std::os::raw::c_void)>,
    #[doc = " wrap data, used for converting function pointer types"]
    pub fn_wrap_data: *mut py_wrap_c_func_t,
}
#[test]
fn bindgen_test_layout_field_type_t() {
    const UNINIT: ::std::mem::MaybeUninit<field_type_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<field_type_t>(),
        40usize,
        concat!("Size of: ", stringify!(field_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<field_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(field_type_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(field_type_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_py) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(field_type_t),
            "::",
            stringify!(from_py)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_py) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(field_type_t),
            "::",
            stringify!(to_py)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(field_type_t),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_wrap_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(field_type_t),
            "::",
            stringify!(fn_wrap_data)
        )
    );
}
impl Default for field_type_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct member information"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct struct_member {
    pub name: *const ::std::os::raw::c_char,
    #[doc = " set this member to a Python value: 0 on success, -1 on error"]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            c_struct: *mut ::std::os::raw::c_void,
            member: *const struct_member,
            pysrc: *mut _object,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " retrieve this member as a Python value; object is only used\nfor interfaces"]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            c_struct: *mut ::std::os::raw::c_void,
            object: *mut conf_object_t,
            member: *const struct_member,
        ) -> *mut _object,
    >,
    #[doc = " member byte offset in struct"]
    pub ofs: usize,
    pub type_: *const field_type_t,
}
#[test]
fn bindgen_test_layout_struct_member() {
    const UNINIT: ::std::mem::MaybeUninit<struct_member> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<struct_member>(),
        40usize,
        concat!("Size of: ", stringify!(struct_member))
    );
    assert_eq!(
        ::std::mem::align_of::<struct_member>(),
        8usize,
        concat!("Alignment of ", stringify!(struct_member))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_member),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_member),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_member),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ofs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_member),
            "::",
            stringify!(ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_member),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for struct_member {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct member information"]
pub type struct_member_t = struct_member;
extern "C" {
    pub fn VT_python_cbdata_type() -> *const cbdata_type_t;
}
extern "C" {
    pub fn VT_cbdata_python_type() -> *mut _object;
}
#[doc = " struct to hold data about each type of generated trampolines (one\nper signature)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct py_wrap_c_func {
    #[doc = " Python definition"]
    pub meth: PyMethodDef,
    #[doc = " C function that converts arguments and calls Python"]
    pub python_caller: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " information about generated trampolines"]
    pub trampoline_data: *const trampoline_data,
    #[doc = " non-zero if this is a \"method\" function that can bind to an\nobject"]
    pub is_method: bool,
    #[doc = " Number of arguments the function takes, including the first \"object\"\nargument if it is a method."]
    pub arity: ::std::os::raw::c_uchar,
    #[doc = " Python wrapper, indexed by a hash of the C function and\nbound object"]
    pub c_to_py_table: *mut ht_int_table_t,
    #[doc = " PyDictObject with PyCObject(C wrapper), indexed by Python object"]
    pub py_to_c_dict: *mut PyObject,
}
#[test]
fn bindgen_test_layout_py_wrap_c_func() {
    const UNINIT: ::std::mem::MaybeUninit<py_wrap_c_func> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<py_wrap_c_func>(),
        72usize,
        concat!("Size of: ", stringify!(py_wrap_c_func))
    );
    assert_eq!(
        ::std::mem::align_of::<py_wrap_c_func>(),
        8usize,
        concat!("Alignment of ", stringify!(py_wrap_c_func))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(meth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).python_caller) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(python_caller)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trampoline_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(trampoline_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_method) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(is_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arity) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(arity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_to_py_table) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(c_to_py_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).py_to_c_dict) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(py_wrap_c_func),
            "::",
            stringify!(py_to_c_dict)
        )
    );
}
impl Default for py_wrap_c_func {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " py_opaque_type_t is used to wrap C structures whose contents cannot\n be accessed by Python without getter/setter functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct py_opaque_type_t {
    pub ob_base: PyObject,
    #[doc = " true if struct should be freed at\ndestruction"]
    pub malloced: bool,
    #[doc = " true if fields should be freed at\ndestruction"]
    pub free_fields: bool,
    #[doc = " true if data is allowed to change"]
    pub mutable: bool,
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " used for interfaces only"]
    pub object: *mut conf_object_t,
    pub type_: *mut opaque_type_t,
}
#[test]
fn bindgen_test_layout_py_opaque_type_t() {
    const UNINIT: ::std::mem::MaybeUninit<py_opaque_type_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<py_opaque_type_t>(),
        48usize,
        concat!("Size of: ", stringify!(py_opaque_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<py_opaque_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(py_opaque_type_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloced) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(malloced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fields) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(free_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutable) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(mutable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(py_opaque_type_t),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for py_opaque_type_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct opaque_type {
    pub pytype: *mut PyTypeObject,
    pub name: *const ::std::os::raw::c_char,
    pub pyspec: PyType_Spec,
    pub size: ::std::os::raw::c_uint,
    pub members: *const struct_member_t,
    pub nmembers: ::std::os::raw::c_int,
    pub is_interface: bool,
    pub get_dict: ::std::option::Option<
        unsafe extern "C" fn(
            c_struct: *mut ::std::os::raw::c_void,
            ot: *mut opaque_type,
        ) -> *mut PyObject,
    >,
}
#[test]
fn bindgen_test_layout_opaque_type() {
    const UNINIT: ::std::mem::MaybeUninit<opaque_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<opaque_type>(),
        80usize,
        concat!("Size of: ", stringify!(opaque_type))
    );
    assert_eq!(
        ::std::mem::align_of::<opaque_type>(),
        8usize,
        concat!("Alignment of ", stringify!(opaque_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pytype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(pytype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pyspec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(pyspec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).members) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(members)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nmembers) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(nmembers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_interface) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(is_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_dict) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_type),
            "::",
            stringify!(get_dict)
        )
    );
}
impl Default for opaque_type {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct py_method_t {
    pub ob_base: PyObject,
    #[doc = " actual signature may vary"]
    pub func: ::std::option::Option<unsafe extern "C" fn()>,
    pub object: *mut conf_object_t,
}
#[test]
fn bindgen_test_layout_py_method_t() {
    const UNINIT: ::std::mem::MaybeUninit<py_method_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<py_method_t>(),
        32usize,
        concat!("Size of: ", stringify!(py_method_t))
    );
    assert_eq!(
        ::std::mem::align_of::<py_method_t>(),
        8usize,
        concat!("Alignment of ", stringify!(py_method_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(py_method_t),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(py_method_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(py_method_t),
            "::",
            stringify!(object)
        )
    );
}
impl Default for py_method_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct python_cbdata_t {
    pub ob_base: PyObject,
    pub cbdata: cbdata_t,
}
#[test]
fn bindgen_test_layout_python_cbdata_t() {
    const UNINIT: ::std::mem::MaybeUninit<python_cbdata_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<python_cbdata_t>(),
        32usize,
        concat!("Size of: ", stringify!(python_cbdata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<python_cbdata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(python_cbdata_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ob_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(python_cbdata_t),
            "::",
            stringify!(ob_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbdata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(python_cbdata_t),
            "::",
            stringify!(cbdata)
        )
    );
}
impl Default for python_cbdata_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VT_init_python_wrappings() -> *mut _object;
}
extern "C" {
    pub fn VT_lookup_python_opaque_type(name: *const ::std::os::raw::c_char) -> *mut opaque_type_t;
}
extern "C" {
    pub fn VT_lookup_python_opaque_type_name(
        type_: *mut opaque_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " obsolete, for ABI compatibility with simics < 6.0.162"]
    pub fn VT_register_opaque_type(type_: *mut opaque_type_t);
}
extern "C" {
    pub fn VT_register_opaque_python_type(type_: *mut opaque_type_t, pytype: *mut _typeobject);
}
extern "C" {
    pub fn VT_get_opaque_python_type(ot: *mut opaque_type_t) -> *mut _typeobject;
}
extern "C" {
    pub fn VT_get_py_c_wrap(
        func: *const ::std::os::raw::c_void,
        object: *mut conf_object_t,
        data: *mut py_wrap_c_func_t,
    ) -> *mut _object;
}
extern "C" {
    pub fn VT_get_c_py_wrap(
        dst: *mut *const ::std::os::raw::c_void,
        src: *mut _object,
        data: *mut py_wrap_c_func_t,
        ignore_arity: bool,
    ) -> ::std::os::raw::c_int;
}
pub type cancel_id_t = uint64;
pub type entity_id_t = uint64;
pub type node_id_t = uint64;
pub type transaction_id_t = uint64;
pub type request_id_t = uint64;
pub const cancel_id_error_t_Cancel_Error_ID: cancel_id_error_t = 0;
pub type cancel_id_error_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct maybe_node_id {
    pub valid: bool,
    pub id: node_id_t,
}
#[test]
fn bindgen_test_layout_maybe_node_id() {
    const UNINIT: ::std::mem::MaybeUninit<maybe_node_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<maybe_node_id>(),
        16usize,
        concat!("Size of: ", stringify!(maybe_node_id))
    );
    assert_eq!(
        ::std::mem::align_of::<maybe_node_id>(),
        8usize,
        concat!("Alignment of ", stringify!(maybe_node_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maybe_node_id),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maybe_node_id),
            "::",
            stringify!(id)
        )
    );
}
pub type maybe_node_id_t = maybe_node_id;
pub const osa_read_len_t_OSA_Read_One_Byte: osa_read_len_t = 1;
pub const osa_read_len_t_OSA_Read_Two_Byte: osa_read_len_t = 2;
pub const osa_read_len_t_OSA_Read_Four_Byte: osa_read_len_t = 4;
pub const osa_read_len_t_OSA_Read_Eight_Byte: osa_read_len_t = 8;
#[doc = " <add id=\"osa_machine_notification_interface_t\">\n<name>osa_machine_notification_interface_t</name>\n<ndx>osa_machine_notification_interface_t</ndx>\n\n<ndx>notify_mode_change!osa_machine_notification interface method</ndx>\n<fun>notify_mode_change</fun> registers a callback function that will be\ncalled when processor <arg>cpu</arg> changes processor mode. The\ncallback function will be called with the processor that changed mode\n<arg>cpu</arg>, the mode previous to the change <arg>old_mode</arg> and\nthe mode after the change <arg>new_mode</arg>.\n\n<ndx>notify_exception!osa_machine_notification interface method</ndx>\n<fun>notify_exception</fun> registers a callback function that will be\ncalled when processor <arg>cpu</arg> takes an exception with exception\nnumber <arg>exc_num</arg>. The callback function <arg>cb</arg> will be\ncalled with the processor <arg>cpu</arg> causing the exception and\nexception number <arg>exc_num</arg> of that exception.\n\n<ndx>notify_control_reg!osa_machine_notification interface method</ndx>\n<fun>notify_control_reg</fun> registers a callback function that will be\ncalled when a control register, with register number <arg>reg_num</arg>, in\nprocessor <arg>cpu</arg> is updated. The callback function <arg>cb</arg>\nwill be called with the processor <arg>cpu</arg>, register number\n<arg>reg_num</arg> and the written register <arg>value</arg> (see\nCore_Control_Register_Write documentation for more details) as\narguments. The register number for a certain register can be retrieved with\nthe <fun>get_register_number</fun> function.\n\n<ndx>notify_control_reg_read!osa_machine_notification interface method</ndx>\n<fun>notify_control_reg_read</fun> registers a callback function that will\nbe called when a control register, with register number <arg>reg_num</arg>,\nin processor <arg>cpu</arg> is read. The callback function <arg>cb</arg>\nwill be called with the processor <arg>cpu</arg> and register number\n<arg>reg_num</arg> as arguments. The register number for a certain register\ncan be retrieved with the <fun>get_register_number</fun> function.\n\n<ndx>notify_exec_breakpoint!osa_machine_notification interface method</ndx>\n<fun>notify_exec_breakpoint</fun>,\n<ndx>notify_read_breakpoint!osa_machine_notification interface method</ndx>\n<fun>notify_read_breakpoint</fun> and\n<ndx>notify_write_breakpoint!osa_machine_notification interface method</ndx>\n<fun>notify_write_breakpoint</fun> plant breakpoints of length\n<arg>len</arg> for processor <arg>cpu</arg> on <arg>address</arg>.\nThe breakpoint is of type execution, read, write respectively. The\n<arg>virt</arg> argument specifies if <arg>address</arg> is a virtual\nor physical address. The callback function <arg>cb</arg> is called when\nthe breakpoint is hit.\nThe arguments of the callback functions are the processor that the\nbreakpoint hit on <arg>cpu</arg> and the <arg>address</arg>\n(virtual or physical depending on what the breakpoint was registered as)\nthat was hit.\nCallbacks functions for <fun>notify_read_breakpoint</fun> and\n<fun>notify_write_breakpoint</fun> also gets the access size <arg>len</arg>\nof the read or write.\nThe callback function for <fun>notify_write_breakpoint</fun> additionally\nhas the previous value <arg>old_val</arg> at the address written and the new\nvalue <arg>new_val</arg> that is being written passed as arguments. Reading\nthe actual memory from the callback will result in reading the new value that\nhas been written as the callback is called after the write is done.\nOn x86 virtual breakpoints use linear addresses (as opposed to logical\naddresses).\n\nFor all functions, the <arg>tracker</arg> argument should be the tracker\ncalling this interface. This makes it possible for a hypervisor tracker to\nhandle guests differently.\n\nAll methods that register a notification callback take <arg>data</arg> as an\nargument which will be passed on to callback function. These methods return\na cancel ID to be used with the <fun>cancel</fun> method to cancel the\ncallback. A returned value of 0 means that an error occurred and no callback\nwas registered, in which case the caller is responsible for freeing the\ncallback <arg>data</arg>.\n\n<ndx>cancel!osa_machine_notification interface method</ndx>\n<fun>cancel</fun> cancels the callback function with ID <arg>cancel_id</arg>\nand will free the callback <arg>data</arg> associated with the\nnotification. This ID will have been returned from the function that\nregistered the callback.\n\n<insert-until text=\"// ADD INTERFACE osa_machine_notification_interface\"/>\n</add>\n\n<add id=\"osa_machine_notification_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type osa_read_len_t = ::std::os::raw::c_uint;
pub type osa_machine_notification_interface_t = osa_machine_notification_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_machine_notification_interface {
    pub notify_mode_change: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    old_mode: processor_mode_t,
                    new_mode: processor_mode_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_exception: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            exc_num: ::std::os::raw::c_int,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    exc_num: ::std::os::raw::c_int,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_control_reg: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            reg_num: ::std::os::raw::c_int,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    reg_num: ::std::os::raw::c_int,
                    value: uint64,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_exec_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            address: uint64,
            len: uint64,
            virt: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, cpu: *mut conf_object_t, address: uint64),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_read_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            address: uint64,
            len: ::std::os::raw::c_uint,
            virt: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    address: uint64,
                    len: ::std::os::raw::c_uint,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_write_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            address: uint64,
            len: ::std::os::raw::c_uint,
            virt: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    address: uint64,
                    len: ::std::os::raw::c_uint,
                    old_val: uint64,
                    new_val: uint64,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cancel_id: cancel_id_t,
        ),
    >,
    pub notify_control_reg_read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            reg_num: ::std::os::raw::c_int,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    cpu: *mut conf_object_t,
                    reg_num: ::std::os::raw::c_int,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
}
#[test]
fn bindgen_test_layout_osa_machine_notification_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_machine_notification_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_machine_notification_interface>(),
        64usize,
        concat!("Size of: ", stringify!(osa_machine_notification_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_machine_notification_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(osa_machine_notification_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_mode_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_mode_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_exception) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_control_reg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_control_reg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_exec_breakpoint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_exec_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_read_breakpoint) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_read_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_write_breakpoint) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_write_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_control_reg_read) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_notification_interface),
            "::",
            stringify!(notify_control_reg_read)
        )
    );
}
pub type osa_machine_query_interface_t = osa_machine_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_machine_query_interface {
    pub read_register: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            reg: ::std::os::raw::c_int,
        ) -> uint64,
    >,
    pub get_register_number: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            reg: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_phys_memory: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            addr: physical_address_t,
            len: osa_read_len_t,
        ) -> attr_value_t,
    >,
    pub read_phys_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            paddr: physical_address_t,
            len: ::std::os::raw::c_uint,
        ) -> attr_value_t,
    >,
    pub virtual_to_physical: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            vaddr: uint64,
        ) -> attr_value_t,
    >,
    pub cpu_mode: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
        ) -> processor_mode_t,
    >,
    pub get_all_processors: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, tracker: *mut conf_object_t) -> attr_value_t,
    >,
    pub get_exception_number: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            cpu: *mut conf_object_t,
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_osa_machine_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_machine_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_machine_query_interface>(),
        64usize,
        concat!("Size of: ", stringify!(osa_machine_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_machine_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_machine_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(read_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_register_number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(get_register_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_phys_memory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(read_phys_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_phys_bytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(read_phys_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virtual_to_physical) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(virtual_to_physical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(cpu_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_all_processors) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(get_all_processors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_exception_number) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_machine_query_interface),
            "::",
            stringify!(get_exception_number)
        )
    );
}
pub type osa_mapper_admin_interface_t = osa_mapper_admin_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_mapper_admin_interface {
    pub tracker_updated: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
            changeset: attr_value_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_osa_mapper_admin_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_mapper_admin_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_mapper_admin_interface>(),
        8usize,
        concat!("Size of: ", stringify!(osa_mapper_admin_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_mapper_admin_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_mapper_admin_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracker_updated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_mapper_admin_interface),
            "::",
            stringify!(tracker_updated)
        )
    );
}
pub type osa_mapper_control_interface_t = osa_mapper_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_mapper_control_interface {
    pub disable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub enable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub clear_state: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_osa_mapper_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_mapper_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_mapper_control_interface>(),
        24usize,
        concat!("Size of: ", stringify!(osa_mapper_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_mapper_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_mapper_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_mapper_control_interface),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_mapper_control_interface),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_mapper_control_interface),
            "::",
            stringify!(clear_state)
        )
    );
}
pub type osa_mapper_query_interface_t = osa_mapper_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_mapper_query_interface {
    pub get_process_list:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_mapper: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> *mut conf_object_t,
    >,
}
#[test]
fn bindgen_test_layout_osa_mapper_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_mapper_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_mapper_query_interface>(),
        16usize,
        concat!("Size of: ", stringify!(osa_mapper_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_mapper_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_mapper_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_process_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_mapper_query_interface),
            "::",
            stringify!(get_process_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mapper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_mapper_query_interface),
            "::",
            stringify!(get_mapper)
        )
    );
}
pub type osa_node_tree_admin_interface_t = osa_node_tree_admin_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_node_tree_admin_interface {
    pub begin: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *mut conf_object_t,
        ) -> transaction_id_t,
    >,
    pub end: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, transaction_id: transaction_id_t),
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mapper: *mut conf_object_t,
            props: attr_value_t,
        ) -> node_id_t,
    >,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            parent_id: node_id_t,
            props: attr_value_t,
        ) -> node_id_t,
    >,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t, props: attr_value_t),
    >,
    pub remove:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t)>,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            event_name: *const ::std::os::raw::c_char,
            event_data: attr_value_t,
        ),
    >,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t, cpu: *mut conf_object_t),
    >,
    pub deactivate: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t, cpu: *mut conf_object_t),
    >,
    pub register_formatter: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            key: *const ::std::os::raw::c_char,
            recursive: bool,
            formatter: ::std::option::Option<
                unsafe extern "C" fn(val: attr_value_t) -> attr_value_t,
            >,
        ) -> cancel_id_t,
    >,
    pub unregister_formatter:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, node_id: cancel_id_t)>,
    pub reset: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t, props: attr_value_t),
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            key: *const ::std::os::raw::c_char,
            value: attr_value_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_osa_node_tree_admin_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_node_tree_admin_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_node_tree_admin_interface>(),
        104usize,
        concat!("Size of: ", stringify!(osa_node_tree_admin_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_node_tree_admin_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_node_tree_admin_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deactivate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_formatter) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(register_formatter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_formatter) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(unregister_formatter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_property) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_admin_interface),
            "::",
            stringify!(set_property)
        )
    );
}
pub type osa_parameters_interface_t = osa_parameters_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_parameters_interface {
    pub get_parameters: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, include_children: bool) -> attr_value_t,
    >,
    pub set_parameters: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, parameters: attr_value_t) -> attr_value_t,
    >,
    pub is_kind_supported: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, kind: *const ::std::os::raw::c_char) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_osa_parameters_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_parameters_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_parameters_interface>(),
        24usize,
        concat!("Size of: ", stringify!(osa_parameters_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_parameters_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_parameters_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parameters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_parameters_interface),
            "::",
            stringify!(get_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_parameters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_parameters_interface),
            "::",
            stringify!(set_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_kind_supported) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_parameters_interface),
            "::",
            stringify!(is_kind_supported)
        )
    );
}
pub type osa_tracker_component_interface_t = osa_tracker_component_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_tracker_component_interface {
    pub get_tracker:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub get_mapper:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
}
#[test]
fn bindgen_test_layout_osa_tracker_component_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_tracker_component_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_tracker_component_interface>(),
        16usize,
        concat!("Size of: ", stringify!(osa_tracker_component_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_tracker_component_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_tracker_component_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_tracker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_component_interface),
            "::",
            stringify!(get_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mapper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_component_interface),
            "::",
            stringify!(get_mapper)
        )
    );
}
pub type osa_tracker_state_admin_interface_t = osa_tracker_state_admin_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_tracker_state_admin_interface {
    pub begin: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            initiator: *mut conf_object_t,
        ) -> transaction_id_t,
    >,
    pub end: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, txid: transaction_id_t),
    >,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            entity_id: entity_id_t,
            attributes: attr_value_t,
        ),
    >,
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, entity_id: entity_id_t),
    >,
    pub remove_all: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub set_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            entity_id: entity_id_t,
            key: *const ::std::os::raw::c_char,
            val: attr_value_t,
        ),
    >,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            entity_id: entity_id_t,
            attributes: attr_value_t,
        ),
    >,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            entity_id: entity_id_t,
            event_name: *const ::std::os::raw::c_char,
            event_data: attr_value_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_osa_tracker_state_admin_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_tracker_state_admin_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_tracker_state_admin_interface>(),
        64usize,
        concat!("Size of: ", stringify!(osa_tracker_state_admin_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_tracker_state_admin_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(osa_tracker_state_admin_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_all) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(remove_all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attribute) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(set_attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_admin_interface),
            "::",
            stringify!(event)
        )
    );
}
pub type osa_tracker_state_notification_interface_t = osa_tracker_state_notification_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_tracker_state_notification_interface {
    pub subscribe_tracker: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mapper: *mut conf_object_t,
            tracker: *mut conf_object_t,
        ),
    >,
    pub unsubscribe_tracker: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            mapper: *mut conf_object_t,
            tracker: *mut conf_object_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_osa_tracker_state_notification_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_tracker_state_notification_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_tracker_state_notification_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(osa_tracker_state_notification_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<osa_tracker_state_notification_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(osa_tracker_state_notification_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribe_tracker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_notification_interface),
            "::",
            stringify!(subscribe_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsubscribe_tracker) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_notification_interface),
            "::",
            stringify!(unsubscribe_tracker)
        )
    );
}
pub type osa_tracker_state_query_interface_t = osa_tracker_state_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_tracker_state_query_interface {
    pub get_trackers:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_entities: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, tracker: *mut conf_object_t) -> attr_value_t,
    >,
    pub get_entity: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            tracker: *mut conf_object_t,
            id: entity_id_t,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_osa_tracker_state_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_tracker_state_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_tracker_state_query_interface>(),
        24usize,
        concat!("Size of: ", stringify!(osa_tracker_state_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_tracker_state_query_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(osa_tracker_state_query_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_trackers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_query_interface),
            "::",
            stringify!(get_trackers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_entities) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_query_interface),
            "::",
            stringify!(get_entities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_entity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_state_query_interface),
            "::",
            stringify!(get_entity)
        )
    );
}
pub type osa_tracker_control_interface_t = osa_tracker_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_tracker_control_interface {
    pub disable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub enable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub clear_state: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub add_processor: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu: *mut conf_object_t) -> bool,
    >,
    pub remove_processor: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cpu: *mut conf_object_t) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_osa_tracker_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_tracker_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_tracker_control_interface>(),
        40usize,
        concat!("Size of: ", stringify!(osa_tracker_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_tracker_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_tracker_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_control_interface),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_control_interface),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_control_interface),
            "::",
            stringify!(clear_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_processor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_control_interface),
            "::",
            stringify!(add_processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_processor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_tracker_control_interface),
            "::",
            stringify!(remove_processor)
        )
    );
}
pub type osa_micro_checkpoint_interface_t = osa_micro_checkpoint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_micro_checkpoint_interface {
    pub started: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub finished: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_osa_micro_checkpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_micro_checkpoint_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_micro_checkpoint_interface>(),
        16usize,
        concat!("Size of: ", stringify!(osa_micro_checkpoint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_micro_checkpoint_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_micro_checkpoint_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).started) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_micro_checkpoint_interface),
            "::",
            stringify!(started)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finished) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_micro_checkpoint_interface),
            "::",
            stringify!(finished)
        )
    );
}
pub type instrumentation_filter_slave_interface_t = instrumentation_filter_slave_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instrumentation_filter_slave_interface {
    pub disable: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, source_id: ::std::os::raw::c_uint),
    >,
    pub enable: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, source_id: ::std::os::raw::c_uint),
    >,
}
#[test]
fn bindgen_test_layout_instrumentation_filter_slave_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instrumentation_filter_slave_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instrumentation_filter_slave_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(instrumentation_filter_slave_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<instrumentation_filter_slave_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(instrumentation_filter_slave_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_slave_interface),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_slave_interface),
            "::",
            stringify!(enable)
        )
    );
}
pub type instrumentation_filter_status_interface_t = instrumentation_filter_status_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instrumentation_filter_status_interface {
    pub get_disabled_sources:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_instrumentation_filter_status_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instrumentation_filter_status_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instrumentation_filter_status_interface>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(instrumentation_filter_status_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<instrumentation_filter_status_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(instrumentation_filter_status_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_disabled_sources) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_status_interface),
            "::",
            stringify!(get_disabled_sources)
        )
    );
}
pub type instrumentation_filter_master_interface_t = instrumentation_filter_master_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instrumentation_filter_master_interface {
    pub set_source_id: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, source_id: ::std::os::raw::c_uint),
    >,
    pub add_slave: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            slave: *mut conf_object_t,
            provider_obj: *mut conf_object_t,
        ) -> bool,
    >,
    pub remove_slave: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            slave: *mut conf_object_t,
            provider_obj: *mut conf_object_t,
        ),
    >,
    pub short_filter_config: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_instrumentation_filter_master_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instrumentation_filter_master_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instrumentation_filter_master_interface>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(instrumentation_filter_master_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<instrumentation_filter_master_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(instrumentation_filter_master_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_source_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_master_interface),
            "::",
            stringify!(set_source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_slave) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_master_interface),
            "::",
            stringify!(add_slave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_slave) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_master_interface),
            "::",
            stringify!(remove_slave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_filter_config) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_filter_master_interface),
            "::",
            stringify!(short_filter_config)
        )
    );
}
pub type osa_control_v2_interface_t = osa_control_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_control_v2_interface {
    pub request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, id: request_id_t)>,
    pub clear_state:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_osa_control_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_control_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_control_v2_interface>(),
        24usize,
        concat!("Size of: ", stringify!(osa_control_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_control_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_control_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_control_v2_interface),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_control_v2_interface),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_control_v2_interface),
            "::",
            stringify!(clear_state)
        )
    );
}
#[doc = " <add-type id=\"disasm_instr_t\"> </add-type>"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct disasm_instr_t {
    #[doc = " Where the instructions starts in the buffer"]
    pub start: ::std::os::raw::c_int,
    #[doc = " Length of instruction, or -1 if incomplete"]
    pub length: ::std::os::raw::c_int,
    #[doc = " Disassembly string (allocated)"]
    pub string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_disasm_instr_t() {
    const UNINIT: ::std::mem::MaybeUninit<disasm_instr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<disasm_instr_t>(),
        16usize,
        concat!("Size of: ", stringify!(disasm_instr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<disasm_instr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(disasm_instr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disasm_instr_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(disasm_instr_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(disasm_instr_t),
            "::",
            stringify!(string)
        )
    );
}
impl Default for disasm_instr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type disassemble_interface_t = disassemble_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct disassemble_interface {
    #[doc = " Set up new block to disassemble"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            buff: *mut uint8,
            buff_len: ::std::os::raw::c_int,
            address: uint64,
        ),
    >,
    #[doc = " Disassemble the next instruction"]
    pub next:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> disasm_instr_t>,
}
#[test]
fn bindgen_test_layout_disassemble_interface() {
    const UNINIT: ::std::mem::MaybeUninit<disassemble_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<disassemble_interface>(),
        16usize,
        concat!("Size of: ", stringify!(disassemble_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<disassemble_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(disassemble_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_interface),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_interface),
            "::",
            stringify!(next)
        )
    );
}
pub type scalar_time_interface_t = scalar_time_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct scalar_time_interface {
    pub add_consumer: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub remove_consumer: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, consumer: ::std::os::raw::c_int),
    >,
    pub poll: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            consumer: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_scalar_time_interface() {
    const UNINIT: ::std::mem::MaybeUninit<scalar_time_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<scalar_time_interface>(),
        24usize,
        concat!("Size of: ", stringify!(scalar_time_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<scalar_time_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(scalar_time_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_consumer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scalar_time_interface),
            "::",
            stringify!(add_consumer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_consumer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scalar_time_interface),
            "::",
            stringify!(remove_consumer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scalar_time_interface),
            "::",
            stringify!(poll)
        )
    );
}
pub type osa_component_interface_t = osa_component_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_component_interface {
    pub get_admin:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut conf_object_t>,
    pub get_root_node:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> maybe_node_id_t>,
    pub notify_tracker: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cb: ::std::option::Option<unsafe extern "C" fn(data: cbdata_call_t)>,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub cancel_notify: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cancel_id: cancel_id_t),
    >,
    pub has_tracker: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub get_processors:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_osa_component_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_component_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_component_interface>(),
        48usize,
        concat!("Size of: ", stringify!(osa_component_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_component_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_component_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_admin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_component_interface),
            "::",
            stringify!(get_admin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_root_node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_component_interface),
            "::",
            stringify!(get_root_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_tracker) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_component_interface),
            "::",
            stringify!(notify_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_notify) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_component_interface),
            "::",
            stringify!(cancel_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_tracker) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_component_interface),
            "::",
            stringify!(has_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_processors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_component_interface),
            "::",
            stringify!(get_processors)
        )
    );
}
pub type preference_interface_t = preference_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct preference_interface {
    pub get_preference_for_module_key: ::std::option::Option<
        unsafe extern "C" fn(
            prefs: *mut conf_object_t,
            module: *const ::std::os::raw::c_char,
            key: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub set_preference_for_module_key: ::std::option::Option<
        unsafe extern "C" fn(
            prefs: *mut conf_object_t,
            value: attr_value_t,
            module: *const ::std::os::raw::c_char,
            key: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_preference_interface() {
    const UNINIT: ::std::mem::MaybeUninit<preference_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<preference_interface>(),
        16usize,
        concat!("Size of: ", stringify!(preference_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<preference_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(preference_interface))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_preference_for_module_key) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(preference_interface),
            "::",
            stringify!(get_preference_for_module_key)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).set_preference_for_module_key) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(preference_interface),
            "::",
            stringify!(set_preference_for_module_key)
        )
    );
}
pub type osa_node_tree_query_interface_t = osa_node_tree_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_node_tree_query_interface {
    pub get_root_nodes:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_node: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> attr_value_t,
    >,
    pub get_current_nodes: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            base_id: node_id_t,
            cpu: *mut conf_object_t,
        ) -> attr_value_t,
    >,
    pub get_current_processors: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> attr_value_t,
    >,
    pub get_all_processors:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub get_mapper: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> *mut conf_object_t,
    >,
    pub get_parent: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> attr_value_t,
    >,
    pub get_children: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> attr_value_t,
    >,
    pub get_formatted_properties: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: uint64) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_osa_node_tree_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_node_tree_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_node_tree_query_interface>(),
        72usize,
        concat!("Size of: ", stringify!(osa_node_tree_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_node_tree_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_node_tree_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_root_nodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_root_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_current_nodes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_current_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_current_processors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_current_processors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_all_processors) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_all_processors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mapper) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_mapper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_children) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_formatted_properties) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_query_interface),
            "::",
            stringify!(get_formatted_properties)
        )
    );
}
pub type osa_node_tree_notification_interface_t = osa_node_tree_notification_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_node_tree_notification_interface {
    pub notify_create: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            recursive: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    cpu: *mut conf_object_t,
                    node_id: node_id_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_destroy: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            recursive: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    cpu: *mut conf_object_t,
                    node_id: node_id_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_property_change: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            key: *const ::std::os::raw::c_char,
            recursive: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    cpu: *mut conf_object_t,
                    node_id: node_id_t,
                    key: *const ::std::os::raw::c_char,
                    old_val: attr_value_t,
                    new_val: attr_value_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_cpu_move_from: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    cpu: *mut conf_object_t,
                    node_path: attr_value_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_cpu_move_to: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    cpu: *mut conf_object_t,
                    node_path: attr_value_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_event: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: node_id_t,
            event_name: *const ::std::os::raw::c_char,
            recursive: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    cpu: *mut conf_object_t,
                    node_id: node_id_t,
                    event_name: *const ::std::os::raw::c_char,
                    event_data: attr_value_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_enable: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, obj: *mut conf_object_t),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub notify_disable: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, obj: *mut conf_object_t),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
    pub cancel_notify: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cancel_id: cancel_id_t),
    >,
    pub notify_callbacks_done: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            node_id: uint64,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, obj: *mut conf_object_t),
            >,
            data: cbdata_register_t,
        ) -> cancel_id_t,
    >,
}
#[test]
fn bindgen_test_layout_osa_node_tree_notification_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_node_tree_notification_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_node_tree_notification_interface>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(osa_node_tree_notification_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<osa_node_tree_notification_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(osa_node_tree_notification_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_destroy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_property_change) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_property_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_cpu_move_from) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_cpu_move_from)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_cpu_move_to) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_cpu_move_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_event) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_enable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_disable) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_notify) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(cancel_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_callbacks_done) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_tree_notification_interface),
            "::",
            stringify!(notify_callbacks_done)
        )
    );
}
pub type instrumentation_tool_interface_t = instrumentation_tool_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instrumentation_tool_interface {
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            provider: *mut conf_object_t,
            args: attr_value_t,
        ) -> *mut conf_object_t,
    >,
    pub disconnect: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, conn_obj: *mut conf_object_t),
    >,
}
#[test]
fn bindgen_test_layout_instrumentation_tool_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instrumentation_tool_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instrumentation_tool_interface>(),
        16usize,
        concat!("Size of: ", stringify!(instrumentation_tool_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<instrumentation_tool_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(instrumentation_tool_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_tool_interface),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_tool_interface),
            "::",
            stringify!(disconnect)
        )
    );
}
pub type instrumentation_connection_interface_t = instrumentation_connection_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct instrumentation_connection_interface {
    pub enable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub disable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_instrumentation_connection_interface() {
    const UNINIT: ::std::mem::MaybeUninit<instrumentation_connection_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<instrumentation_connection_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(instrumentation_connection_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<instrumentation_connection_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(instrumentation_connection_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_connection_interface),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(instrumentation_connection_interface),
            "::",
            stringify!(disable)
        )
    );
}
pub type osa_node_path_interface_t = osa_node_path_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_node_path_interface {
    pub matching_nodes: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            root_id: node_id_t,
            node_path_pattern: attr_value_t,
        ) -> attr_value_t,
    >,
    pub node_path: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, node_id: node_id_t) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_osa_node_path_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_node_path_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_node_path_interface>(),
        16usize,
        concat!("Size of: ", stringify!(osa_node_path_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_node_path_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_node_path_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matching_nodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_path_interface),
            "::",
            stringify!(matching_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_node_path_interface),
            "::",
            stringify!(node_path)
        )
    );
}
pub type address_profiler_interface_t = address_profiler_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct address_profiler_interface {
    pub iter: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
            start: generic_address_t,
            stop: generic_address_t,
        ) -> *mut addr_prof_iter_t,
    >,
    pub sum: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
            start: generic_address_t,
            end: generic_address_t,
        ) -> uint64,
    >,
    pub max: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
            start: generic_address_t,
            end: generic_address_t,
        ) -> uint64,
    >,
    pub granularity_log2: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub address_bits: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub physical_addresses: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub description: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            view: ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub num_views: ::std::option::Option<
        unsafe extern "C" fn(prof_obj: *mut conf_object_t) -> ::std::os::raw::c_uint,
    >,
}
#[test]
fn bindgen_test_layout_address_profiler_interface() {
    const UNINIT: ::std::mem::MaybeUninit<address_profiler_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<address_profiler_interface>(),
        64usize,
        concat!("Size of: ", stringify!(address_profiler_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<address_profiler_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(address_profiler_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(sum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granularity_log2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(granularity_log2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_bits) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(address_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physical_addresses) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(physical_addresses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_views) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(address_profiler_interface),
            "::",
            stringify!(num_views)
        )
    );
}
pub type branch_arc_interface_t = branch_arc_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct branch_arc_interface {
    pub iter: ::std::option::Option<
        unsafe extern "C" fn(
            prof_obj: *mut conf_object_t,
            start: generic_address_t,
            stop: generic_address_t,
            dir: branch_recorder_direction_t,
        ) -> *mut branch_arc_iter_t,
    >,
}
#[test]
fn bindgen_test_layout_branch_arc_interface() {
    const UNINIT: ::std::mem::MaybeUninit<branch_arc_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<branch_arc_interface>(),
        8usize,
        concat!("Size of: ", stringify!(branch_arc_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<branch_arc_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(branch_arc_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(branch_arc_interface),
            "::",
            stringify!(iter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct recorder {
    _unused: [u8; 0],
}
pub type recorder_t = recorder;
#[doc = " <add id=\"recorder_interface_t\">\nThis interface is <b>deprecated</b>; please use the\n<iface>recorder_v2</iface> instead.\n\nTo initiate recording, the object should call the <fun>attach</fun> method\nwith the recorder, the object itself, and an input handler as parameters.\nThis is done once, typically when the object instance is created.\n\nWhen the object receives data from outside the simulator, it should call\nthe <fun>input</fun> method with a <type>dbuffer_t</type> containing the\nraw data in unspecified form, along with an extra word of user data.\nThe <param>data</param> parameter can be <pp>NULL</pp> if not needed.\n\nThe <fun>input_from_recorder</fun> function is called with input data to the\nobject. When using live input, it is called with data given to\n<fun>input</fun>; when playing back, it is called with recorded data.\nAn object should never use its input directly but only what it receives\nfrom <fun>input_from_recorder</fun>.\n\nThe <fun>playback</fun> function returns true if the recorder is currently\nplaying back recorded data and false if not.\n\nThe <type>dbuffer_t</type> parameters retain their respective ownership.\nThe <fun>input_from_recorder</fun> function must not modify the contents\nwithout cloning it first.\n\n<insert-until text=\"// ADD INTERFACE recorder_interface\"/>\n</add>\n<add id=\"recorder_interface_exec_context\">\nCell Context for all methods.\n</add>"]
pub type recorder_input_handler_t = ::std::option::Option<
    unsafe extern "C" fn(obj: *mut conf_object_t, data: *mut dbuffer_t, uint_data: uint32),
>;
pub type recorder_interface_t = recorder_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct recorder_interface {
    pub attach: ::std::option::Option<
        unsafe extern "C" fn(
            rec: *mut conf_object_t,
            obj: *mut conf_object_t,
            input_from_recorder: recorder_input_handler_t,
        ) -> *mut recorder_t,
    >,
    pub detach:
        ::std::option::Option<unsafe extern "C" fn(rec: *mut conf_object_t, r: *mut recorder_t)>,
    pub input: ::std::option::Option<
        unsafe extern "C" fn(
            rec: *mut conf_object_t,
            r: *mut recorder_t,
            data: *mut dbuffer_t,
            uint_data: uint32,
        ),
    >,
    pub playback: ::std::option::Option<unsafe extern "C" fn(rec: *mut conf_object_t) -> bool>,
}
#[test]
fn bindgen_test_layout_recorder_interface() {
    const UNINIT: ::std::mem::MaybeUninit<recorder_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<recorder_interface>(),
        32usize,
        concat!("Size of: ", stringify!(recorder_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<recorder_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(recorder_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(recorder_interface),
            "::",
            stringify!(attach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detach) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(recorder_interface),
            "::",
            stringify!(detach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(recorder_interface),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(recorder_interface),
            "::",
            stringify!(playback)
        )
    );
}
pub type recorder_v2_interface_t = recorder_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct recorder_v2_interface {
    pub record: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, sender: *mut conf_object_t, data: bytes_t),
    >,
    pub playback: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
}
#[test]
fn bindgen_test_layout_recorder_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<recorder_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<recorder_v2_interface>(),
        16usize,
        concat!("Size of: ", stringify!(recorder_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<recorder_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(recorder_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(recorder_v2_interface),
            "::",
            stringify!(record)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(recorder_v2_interface),
            "::",
            stringify!(playback)
        )
    );
}
pub type recorded_interface_t = recorded_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct recorded_interface {
    pub input: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, data: bytes_t, playback: bool),
    >,
}
#[test]
fn bindgen_test_layout_recorded_interface() {
    const UNINIT: ::std::mem::MaybeUninit<recorded_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<recorded_interface>(),
        8usize,
        concat!("Size of: ", stringify!(recorded_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<recorded_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(recorded_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(recorded_interface),
            "::",
            stringify!(input)
        )
    );
}
pub type register_breakpoint_interface_t = register_breakpoint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct register_breakpoint_interface {
    pub add_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            reg_name: *const ::std::os::raw::c_char,
            value: uint64,
            mask: uint64,
            break_upon_change: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub remove_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: ::std::os::raw::c_int) -> bool,
    >,
    pub get_breakpoints:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_register_breakpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<register_breakpoint_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<register_breakpoint_interface>(),
        24usize,
        concat!("Size of: ", stringify!(register_breakpoint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<register_breakpoint_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(register_breakpoint_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_breakpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(register_breakpoint_interface),
            "::",
            stringify!(add_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_breakpoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(register_breakpoint_interface),
            "::",
            stringify!(remove_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_breakpoints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(register_breakpoint_interface),
            "::",
            stringify!(get_breakpoints)
        )
    );
}
pub type debug_cancel_id_t = uint64;
pub const debugger_error_t_Debugger_No_Error: debugger_error_t = 0;
pub const debugger_error_t_Debugger_Not_Allowed_In_Execution_Context: debugger_error_t = 1;
pub const debugger_error_t_Debugger_Unknown_Context: debugger_error_t = 2;
pub const debugger_error_t_Debugger_Not_Supported_For_Context: debugger_error_t = 3;
pub const debugger_error_t_Debugger_Context_Does_Not_Have_State: debugger_error_t = 4;
pub const debugger_error_t_Debugger_Context_Is_Not_Active: debugger_error_t = 5;
pub const debugger_error_t_Debugger_Lookup_Failure: debugger_error_t = 6;
pub const debugger_error_t_Debugger_Failed_To_Get_Stack_Frame: debugger_error_t = 7;
pub const debugger_error_t_Debugger_Failed_To_Get_PC: debugger_error_t = 8;
pub const debugger_error_t_Debugger_Failed_To_Read: debugger_error_t = 9;
pub const debugger_error_t_Debugger_Failed_To_Write: debugger_error_t = 10;
pub const debugger_error_t_Debugger_Frame_Outside_Of_Known_Stack: debugger_error_t = 11;
pub const debugger_error_t_Debugger_Failed_To_Evaluate_Expression: debugger_error_t = 12;
pub const debugger_error_t_Debugger_Incorrect_Type: debugger_error_t = 13;
pub const debugger_error_t_Debugger_Incorrect_Size: debugger_error_t = 14;
pub const debugger_error_t_Debugger_Incorrect_Context_Query: debugger_error_t = 15;
pub const debugger_error_t_Debugger_Unknown_Id: debugger_error_t = 16;
pub const debugger_error_t_Debugger_Source_Not_Found: debugger_error_t = 17;
pub const debugger_error_t_Debugger_File_Not_Found: debugger_error_t = 18;
pub const debugger_error_t_Debugger_Unrecognized_File_Format: debugger_error_t = 19;
pub const debugger_error_t_Debugger_Unsupported_For_File_Format: debugger_error_t = 20;
pub const debugger_error_t_Debugger_Failed_To_Open_File: debugger_error_t = 21;
pub const debugger_error_t_Debugger_Not_Relocatable: debugger_error_t = 22;
pub const debugger_error_t_Debugger_Segment_Info_Missing: debugger_error_t = 23;
pub const debugger_error_t_Debugger_Section_Info_Missing: debugger_error_t = 24;
pub const debugger_error_t_Debugger_Segment_Not_Found: debugger_error_t = 25;
pub const debugger_error_t_Debugger_Section_Not_Found: debugger_error_t = 26;
pub const debugger_error_t_Debugger_Already_Running: debugger_error_t = 27;
pub const debugger_error_t_Debugger_Failed_To_Continue: debugger_error_t = 28;
pub const debugger_error_t_Debugger_No_Context_For_Object: debugger_error_t = 29;
pub const debugger_error_t_Debugger_Invalid_Path: debugger_error_t = 30;
pub const debugger_error_t_Debugger_Missing_Object: debugger_error_t = 31;
pub const debugger_error_t_Debugger_Unexpected_Error: debugger_error_t = 32;
pub const debugger_error_t_Debugger_Step_Interrupted: debugger_error_t = 33;
#[doc = " <add id=\"debugger_error_t\">\n<insert-until text=\"// END debugger_error_t\"/>\n</add>"]
pub type debugger_error_t = ::std::os::raw::c_uint;
pub type debug_notification_interface_t = debug_notification_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct debug_notification_interface {
    pub notify_context_creation: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                    updated: bool,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_context_destruction: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_location: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            location: *const ::std::os::raw::c_char,
            size: ::std::os::raw::c_uint,
            access: access_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                    cpu: *mut conf_object_t,
                    instruction_address: uint64,
                    data_address: uint64,
                    size: ::std::os::raw::c_uint,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_address: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            address: uint64,
            size: ::std::os::raw::c_uint,
            access: access_t,
            physical: bool,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                    cpu: *mut conf_object_t,
                    instruction_address: uint64,
                    data_address: uint64,
                    size: ::std::os::raw::c_uint,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_line: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_uint,
            column: ::std::os::raw::c_uint,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                    cpu: *mut conf_object_t,
                    instruction_address: uint64,
                    data_address: uint64,
                    size: ::std::os::raw::c_uint,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_activated: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                    cpu: *mut conf_object_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_deactivated: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    data: cbdata_call_t,
                    obj: *mut conf_object_t,
                    ctx_id: *const ::std::os::raw::c_char,
                    cpu: *mut conf_object_t,
                ),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub notify_callbacks_done: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, obj: *mut conf_object_t),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, cid: debug_cancel_id_t) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_debug_notification_interface() {
    const UNINIT: ::std::mem::MaybeUninit<debug_notification_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_notification_interface>(),
        72usize,
        concat!("Size of: ", stringify!(debug_notification_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_notification_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_notification_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_context_creation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_context_creation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_context_destruction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_context_destruction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_location) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_line) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_activated) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_activated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_deactivated) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_deactivated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify_callbacks_done) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(notify_callbacks_done)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_notification_interface),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = " <add id=\"debug_setup_interface_t\">\n<name>debug_setup_interface_t</name>\n<ndx>debug_setup_interface_t</ndx>\n\nFunctions in the <iface>debug_setup</iface> interfaces are used to provide\nthe debugger with symbol files and paths. There are also functions for\nlisting what symbol files and paths have been added.\n\n<insert id=\"debug_attr_value_return_type\"/>\n\nUpon success, all functions for adding symbols will return an <tt>id</tt>\nthat can be used with <fun>remove_symbol_file</fun>.\n\n<ndx>add_symbol_file!debug_setup interface method</ndx>\n<fun>add_symbol_file</fun> adds a symbol file, <arg>symbol_file</arg>, used\nfor debugging contexts that match the context-query <arg>query</arg>. The\n<arg>address</arg> argument specifies the address that the file should be\nmapped to. If <arg>absolute_address</arg> is set then the given\n<arg>address</arg> will be the absolute address of the first relocatable\nsegment and other segments will be added with their given offsets to that\nsegment.\n\nErrors specific to this function:\n\n<ul>\n\n<li><em>Debugger_Failed_To_Open_File</em> - File cannot be opened.</li>\n\n<li><em>Debugger_Unrecognized_File_Format</em> - The file format is not\nrecognized.</li>\n\n<li><em>Debugger_Segment_Info_Missing</em> - If an ELF file is being added,\nbut no valid segments can be found.</li>\n\n</ul>\n\n<ndx>add_symbol_segment!debug_setup interface method</ndx>\n<fun>add_symbol_segment</fun> adds symbols from the specified\n<arg>segment</arg> of an ELF symbol file. Other arguments are the same as\nfor <fun>add_symbol_file</fun>. The address of the segment is specified with\nthe <arg>address</arg> argument. If <arg>absolute_address</arg> is set this\n<arg>address</arg> will be an absolute address otherwise it will be an\noffset to the address found in the symbol file for that segment.\n\nErrors specific to this function: <ul>\n\n<li><em>Debugger_Segment_Not_Found</em> - Segment not found when adding a\nsegment.</li>\n\n<li><em>Debugger_Segment_Info_Missing</em> - Segment information is missing\nor incomplete.</li>\n\n<li><em>Debugger_Not_Relocatable</em> - The segment is not relocatable.</li>\n\n<li><em>Debugger_Unsupported_For_File_Format</em> - File format is not\nELF.</li>\n\n</ul>\n\n<ndx>add_symbol_section!debug_setup interface method</ndx>\n<fun>add_symbol_section</fun> adds symbols from the specified\n<arg>section</arg> of an ELF symbol file. Other arguments are the same as\nfor <fun>add_symbol_file</fun>. The address of the section is specified with\nthe <arg>address</arg> argument. If <arg>absolute_address</arg> is set this\n<arg>address</arg> will be an absolute address otherwise it will be an\noffset to the address found in the symbol file for that section.\n\nErrors specific to this function: <ul>\n\n<li><em>Debugger_Section_Not_Found</em> - Section not found when adding a\nsection.</li>\n\n<li><em>Debugger_Section_Info_Missing</em> - Section information is missing\nor incomplete.</li>\n\n<li><em>Debugger_Not_Relocatable</em> - The section is not relocatable.</li>\n\n<li><em>Debugger_Unsupported_For_File_Format</em> - File format is not\nELF.</li>\n\n</ul>\n\n<note>Adding the same symbol file, section or segment more than once might\nresult in unexpected behavior and is not supported.</note>\n\n<ndx>remove_symbol_file!debug_setup interface method</ndx>\n<fun>remove_symbol_file</fun> removes the debugger's knowledge of symbols\nthat was added with any of the functions for adding symbols. The\n<arg>id</arg> argument is the id returned from the add function.\n\nErrors specific to this function: <ul>\n\n<li><em>Debugger_Unknown_Id</em> - The <arg>id</arg> is unknown.</li>\n\n</ul>\n\n<ndx>clear_symbol_files!debug_setup interface method</ndx>\n<fun>clear_symbol_files</fun> removes the debugger's knowledge about all\nsymbol files added by <arg>add_symbol_file</arg>.\n\n<ndx>symbol_files!debug_setup interface method</ndx> <fun>symbol_files</fun>\nlists all added symbol files. A dictionary, with <tt>id</tt> as key will be\nreturned. An id is always bound to one query and one symbol file, but it can\ncontain several memory maps. The listed <arg>id</arg> is the argument passed\nto <fun>remove_symbol_file</fun>. The dictionary values have the following\nformat:\n\n<ul>\n\n<li><arg>query</arg> <type>(string)</type> - The context query the symbol is\nvalid for.</li>\n\n<li><arg>relocation</arg> <type>(uint64)</type> - The relocation address\nprovided when the symbol file was added.</li>\n\n<li><arg>symbol-file</arg> <type>(string)</type> - The file containing the\nsymbol information.</li>\n\n<li><arg>memory-maps</arg> <type>([&lt;dict&gt;, ...])</type> - A list of\nmemory maps that are added togheter as the same <tt>id</tt>, see format\nbelow:</li>\n\n</ul>\n\nThe dictionary describing a memory map has the following format:\n<ul>\n\n<li><arg>address</arg> <type>(uint64)</type> - The address of the section in\nmemory.</li>\n\n<li><arg>size</arg> <type>(uint64)</type> - The section size in memory.</li>\n\n<li><arg>flags</arg> <type>(uint64)</type> - Format specific flags describing\nthe section.</li>\n\n<li><arg>section</arg> <type>(string)</type> - The name of the section.</li>\n\n<li><arg>file-offset</arg> <type>(uint64)</type> - Offset in symbol file for\nthe section.</li>\n\n<li><arg>file-size</arg> <type>(uint64)</type> - Size of the section in the\nsymbol file.</li>\n\n</ul>\n\n<ndx>symbol_files_for_ctx!debug_setup interface method</ndx>\n<fun>symbol_files_for_ctx</fun> is the same as <fun>symbol_files</fun>\nexcept that it only returns symbol files that are valid for the given\ncontext id, <arg>ctx_id</arg>.\n\n<ndx>list_all_mappings!debug_setup interface method</ndx>\n<fun>list_all_mappings</fun> lists all symbol mappings for a certain context\n<arg>ctx_id</arg>. This will be all mappings from symbol files added by\nusers plus any symbol mappings added elsewhere, from trackers for example.\nThe returned value is a dictionary on the following format:\n\n<ul>\n\n<li><arg>filename</arg> <type>(string)</type> - The file backing the memory\nmap.</li>\n\n<li><arg>query</arg> <type>(string)</type> - The query the map is valid\nfor.</li>\n\n<li><arg>address</arg> <type>(uint64)</type> - The map's address in context\nmemory.</li>\n\n<li><arg>size</arg> <type>(uint64)</type> - The size of the map in\nmemory.</li>\n\n<li><arg>flags</arg> <type>(uint64)</type> - Read, write, and execute flags,\nbit 0 is set if readable, bit 1 if writeable and bit 2 if executable. If this\nvalue is 0 this is the same as if all flags are set.</li>\n\n<li><arg>section-name</arg> <type>(string)</type> - The section name, or\nNIL.</li>\n\n<li><arg>file-offset</arg> <type>(int64)</type> - Offset into the backing\nfile.</li>\n\n<li><arg>file-size</arg> <type>(uint64)</type> - Size of the map in the\nbacking file.</li>\n\n<li><arg>relocation</arg> <type>(uint64)</type> - The offset from the address\nin the symbol file to where the mappings is actually loaded in memory. This\nis not always present in the dictionary.</li>\n\n</ul>\n\nSome other internal entries could possibly also be present in the\ndictionary.\n\n\n<ndx>add_path_map_entry!debug_setup interface method</ndx>\n<fun>add_path_map_entry</fun> adds a path math entry that maps a source\nfile from the <arg>source</arg> in the symbol file to the actual\ndestination, <arg>dest</arg>, where it is located on disk. The\n<arg>query</arg> argument specifies for which context-queries the mapping\nshould apply. The returned id can be used with\n<fun>remove_path_map_entry</fun> to remove the added path map. The source\npath may not be empty or be just \".\" or \"./\".\n\nErrors specific to this function: <ul>\n\n<li><em>Debugger_Invalid_Path</em> - The source path is not valid.</li>\n\n</ul>\n\n<ndx>remove_path_map_entry!debug_setup interface method</ndx>\n<fun>remove_path_map_entry</fun> removes an entry that was added with\n<fun>add_path_map_entry</fun>. The <arg>id</arg> is the value returned from\nthe add function.\n\nErrors specific to this function: <ul>\n\n<li><em>Debugger_Unknown_Id</em> - The provided <arg>id</arg> is\nunknown.</li>\n\n</ul>\n\n<ndx>clear_path_map_entries!debug_setup interface method</ndx>\n<fun>clear_path_map_entries</fun> removes all knowledge about all path map\nentries added with <fun>add_path_map_entry</fun>.\n\n<ndx>path_map_entries!debug_setup interface method</ndx>\n<fun>path_map_entries</fun> lists all path map entries that have been added\nwith <fun>add_path_map_entry</fun>, that matches the given context id. If\nthe context id is nil, then all path maps will be listed. The format of the\nentries in the returned list are dictionaries, with an <tt>id</tt> of type\ndebug_setup_id_t as key:\n\n<ul>\n\n<li><arg>query</arg> <type>(string)</type> - The context query the path map\nis valid for.</li>\n\n<li><arg>source</arg> <type>(string)</type> - The source to translate\nfrom.</li>\n\n<li><arg>destination</arg> <type>(string)</type> - The destination to\ntranslate to.</li>\n\n</ul>\n\n<ndx>path_map_entries_for_ctx!debug_setup interface method</ndx>\n<fun>path_map_entries_for_ctx</fun> is the same as\n<fun>path_map_entries</fun> except that it only lists path maps that are\nvalid for the given context id, <arg>ctx_id</arg>.\n\n\n<ndx>apply_path_map!debug_setup interface method</ndx>\n<fun>apply_path_map</fun> applies any added path map to a file path,\n<arg>filename</arg>, for a given context with ID <arg>ctx_id</arg>. The path\nwith the path map applied will be returned. The path map will only apply if\nthe destination file exists and if the path given in <arg>filename</arg>\ndoes not, otherwise the provided file will be returned. The returned path\nwill always contain forward slashes as path separator, regardless of what\nthe host system uses, or if any path map was applied or not.\n\n<note>For functions that take <arg>query</arg> as argument, having this set\nto nil will work the same way as for <tt>\"*\"</tt>. A bad context query will\nresult in a <type>Debugger_Incorrect_Context_Query</type> error.</note>\n\n<insert-until text=\"// ADD INTERFACE debug_setup_interface\"/>\n</add>\n\n<add id=\"debug_setup_interface_exec_context\">\nGlobal Context for all methods.\n</add>"]
pub type debug_setup_id_t = int64;
pub type debug_setup_interface_t = debug_setup_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct debug_setup_interface {
    pub add_symbol_file: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            symbol_file: *const ::std::os::raw::c_char,
            address: uint64,
            absolute_address: bool,
        ) -> attr_value_t,
    >,
    pub add_symbol_segment: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            symbol_file: *const ::std::os::raw::c_char,
            segment: ::std::os::raw::c_uint,
            address: uint64,
            absolute_address: bool,
        ) -> attr_value_t,
    >,
    pub add_symbol_section: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            symbol_file: *const ::std::os::raw::c_char,
            section: *const ::std::os::raw::c_char,
            address: uint64,
            absolute_address: bool,
        ) -> attr_value_t,
    >,
    pub remove_symbol_file: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: debug_setup_id_t) -> attr_value_t,
    >,
    pub clear_symbol_files: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub symbol_files:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub symbol_files_for_ctx: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub list_all_mappings: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub add_path_map_entry: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
            source: *const ::std::os::raw::c_char,
            dest: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub remove_path_map_entry: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, id: debug_setup_id_t) -> attr_value_t,
    >,
    pub clear_path_map_entries:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub path_map_entries:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub path_map_entries_for_ctx: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub apply_path_map: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            filename: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_debug_setup_interface() {
    const UNINIT: ::std::mem::MaybeUninit<debug_setup_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_setup_interface>(),
        112usize,
        concat!("Size of: ", stringify!(debug_setup_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_setup_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_setup_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_symbol_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(add_symbol_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_symbol_segment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(add_symbol_segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_symbol_section) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(add_symbol_section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_symbol_file) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(remove_symbol_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_symbol_files) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(clear_symbol_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_files) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(symbol_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_files_for_ctx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(symbol_files_for_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_all_mappings) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(list_all_mappings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_path_map_entry) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(add_path_map_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_path_map_entry) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(remove_path_map_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear_path_map_entries) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(clear_path_map_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_map_entries) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(path_map_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_map_entries_for_ctx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(path_map_entries_for_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apply_path_map) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_setup_interface),
            "::",
            stringify!(apply_path_map)
        )
    );
}
pub type debug_query_interface_t = debug_query_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct debug_query_interface {
    pub matching_contexts: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            query: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub get_context_group: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub get_context_parent: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub get_context_children: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub query_for_context_group: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub query_for_context_id: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub query_for_context_tree: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub context_name: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub context_id_for_object: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, ctx_obj: *mut conf_object_t) -> attr_value_t,
    >,
    pub object_for_context: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub context_has_state: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub get_active_processor: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_debug_query_interface() {
    const UNINIT: ::std::mem::MaybeUninit<debug_query_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_query_interface>(),
        96usize,
        concat!("Size of: ", stringify!(debug_query_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_query_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_query_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matching_contexts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(matching_contexts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_context_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(get_context_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_context_parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(get_context_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_context_children) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(get_context_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_for_context_group) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(query_for_context_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_for_context_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(query_for_context_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_for_context_tree) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(query_for_context_tree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(context_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_id_for_object) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(context_id_for_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_for_context) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(object_for_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_has_state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(context_has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_active_processor) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_query_interface),
            "::",
            stringify!(get_active_processor)
        )
    );
}
pub type debug_step_interface_t = debug_step_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct debug_step_interface {
    pub instruction_into: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub into: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub instruction_over: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub over: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub out: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub reverse_instruction_into: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub reverse_into: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub reverse_instruction_over: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub reverse_over: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub reverse_out: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_debug_step_interface() {
    const UNINIT: ::std::mem::MaybeUninit<debug_step_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_step_interface>(),
        80usize,
        concat!("Size of: ", stringify!(debug_step_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_step_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_step_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_into) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(instruction_into)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).into) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(into)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_over) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(instruction_over)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).over) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(over)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_instruction_into) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(reverse_instruction_into)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_into) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(reverse_into)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_instruction_over) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(reverse_instruction_over)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_over) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(reverse_over)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_out) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_step_interface),
            "::",
            stringify!(reverse_out)
        )
    );
}
pub type debug_symbol_interface_t = debug_symbol_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct debug_symbol_interface {
    pub address_source: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address: uint64,
            size: uint64,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, code_area: attr_value_t),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub source_address: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            filename: *const ::std::os::raw::c_char,
            line: uint32,
            column: uint32,
            cb: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, code_area: attr_value_t),
            >,
            data: cbdata_register_t,
        ) -> attr_value_t,
    >,
    pub address_symbol: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address: uint64,
        ) -> attr_value_t,
    >,
    pub stack_depth: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub stack_frames: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            min: ::std::os::raw::c_int,
            max: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
    pub local_variables: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            frame: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
    pub local_arguments: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            frame: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
    pub expression_value: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            frame: int32,
            address_scope: uint64,
            expr: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub expression_type: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            frame: int32,
            address_scope: uint64,
            expr: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub type_info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address_scope: uint64,
            type_: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub type_to_string: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, type_: attr_value_t) -> attr_value_t,
    >,
    pub symbol_address: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            frame: int32,
            symbol: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub address_string: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address: uint64,
            maxlen: ::std::os::raw::c_int,
        ) -> attr_value_t,
    >,
    pub lvalue_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            frame: int32,
            symbol: *const ::std::os::raw::c_char,
            value: attr_value_t,
        ) -> attr_value_t,
    >,
    pub address_write: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address: uint64,
            value: attr_value_t,
        ) -> attr_value_t,
    >,
    pub address_read: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address: uint64,
            size: ::std::os::raw::c_uint,
        ) -> attr_value_t,
    >,
    pub struct_members: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address_scope: uint64,
            struct_name: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub struct_field: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
            address_scope: uint64,
            struct_name: *const ::std::os::raw::c_char,
            field: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub list_functions: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub list_global_variables: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub list_source_files: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_debug_symbol_interface() {
    const UNINIT: ::std::mem::MaybeUninit<debug_symbol_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_symbol_interface>(),
        168usize,
        concat!("Size of: ", stringify!(debug_symbol_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_symbol_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_symbol_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(address_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_symbol) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(address_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(stack_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_frames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(stack_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_variables) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(local_variables)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_arguments) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(local_arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expression_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(expression_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expression_type) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(expression_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(type_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_to_string) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(type_to_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_address) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(symbol_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_string) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(address_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lvalue_write) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(lvalue_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_write) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(address_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_read) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(address_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_members) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(struct_members)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_field) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(struct_field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_functions) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(list_functions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_global_variables) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(list_global_variables)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_source_files) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_interface),
            "::",
            stringify!(list_source_files)
        )
    );
}
pub type debug_symbol_file_interface_t = debug_symbol_file_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct debug_symbol_file_interface {
    pub open_symbol_file: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            filename: *const ::std::os::raw::c_char,
            address: uint64,
            absolute_address: bool,
        ) -> attr_value_t,
    >,
    pub close_symbol_file: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub symbol_file_info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub sections_info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub segments_info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            ctx_id: *const ::std::os::raw::c_char,
        ) -> attr_value_t,
    >,
    pub open_symbol_section: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            filename: *const ::std::os::raw::c_char,
            section: *const ::std::os::raw::c_char,
            address: uint64,
            absolute_address: bool,
        ) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_debug_symbol_file_interface() {
    const UNINIT: ::std::mem::MaybeUninit<debug_symbol_file_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_symbol_file_interface>(),
        48usize,
        concat!("Size of: ", stringify!(debug_symbol_file_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_symbol_file_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_symbol_file_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_symbol_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_file_interface),
            "::",
            stringify!(open_symbol_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_symbol_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_file_interface),
            "::",
            stringify!(close_symbol_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_file_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_file_interface),
            "::",
            stringify!(symbol_file_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sections_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_file_interface),
            "::",
            stringify!(sections_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segments_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_file_interface),
            "::",
            stringify!(segments_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_symbol_section) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_symbol_file_interface),
            "::",
            stringify!(open_symbol_section)
        )
    );
}
pub const request_id_error_t_OSA_Request_Error_ID: request_id_error_t = 0;
pub type request_id_error_t = ::std::os::raw::c_uint;
pub type osa_control_interface_t = osa_control_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct osa_control_interface {
    pub request: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            initiator: *const ::std::os::raw::c_char,
        ) -> request_id_t,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, id: request_id_t)>,
}
#[test]
fn bindgen_test_layout_osa_control_interface() {
    const UNINIT: ::std::mem::MaybeUninit<osa_control_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osa_control_interface>(),
        16usize,
        concat!("Size of: ", stringify!(osa_control_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<osa_control_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(osa_control_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_control_interface),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(osa_control_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " Table property keys"]
pub const table_key_t_Table_Key_Name: table_key_t = 1;
#[doc = " Table property keys"]
pub const table_key_t_Table_Key_Description: table_key_t = 2;
#[doc = " Table property keys"]
pub const table_key_t_Table_Key_Default_Sort_Column: table_key_t = 3;
#[doc = " Table property keys"]
pub const table_key_t_Table_Key_Columns: table_key_t = 4;
#[doc = " Table property keys"]
pub const table_key_t_Table_Key_Extra_Headers: table_key_t = 5;
#[doc = " Table property keys"]
pub const table_key_t_Table_Key_Stream_Header_Repeat: table_key_t = 6;
#[doc = " <add-type id=\"table_key_t def\"></add-type>"]
pub type table_key_t = ::std::os::raw::c_uint;
#[doc = " Other number series than table-keys"]
pub const column_key_t_Column_Key_Name: column_key_t = 1000;
pub const column_key_t_Column_Key_Description: column_key_t = 1001;
pub const column_key_t_Column_Key_Alignment: column_key_t = 1002;
pub const column_key_t_Column_Key_Int_Radix: column_key_t = 1003;
pub const column_key_t_Column_Key_Float_Percent: column_key_t = 1004;
pub const column_key_t_Column_Key_Float_Decimals: column_key_t = 1005;
pub const column_key_t_Column_Key_Sort_Descending: column_key_t = 1006;
pub const column_key_t_Column_Key_Hide_Homogeneous: column_key_t = 1007;
pub const column_key_t_Column_Key_Generate_Percent_Column: column_key_t = 1008;
pub const column_key_t_Column_Key_Generate_Acc_Percent_Column: column_key_t = 1009;
pub const column_key_t_Column_Key_Footer_Sum: column_key_t = 1010;
pub const column_key_t_Column_Key_Footer_Mean: column_key_t = 1011;
pub const column_key_t_Column_Key_Int_Grouping: column_key_t = 1012;
pub const column_key_t_Column_Key_Int_Pad_Width: column_key_t = 1013;
pub const column_key_t_Column_Key_Metric_Prefix: column_key_t = 1014;
pub const column_key_t_Column_Key_Binary_Prefix: column_key_t = 1015;
pub const column_key_t_Column_Key_Time_Format: column_key_t = 1016;
pub const column_key_t_Column_Key_Unique_Id: column_key_t = 1017;
pub const column_key_t_Column_Key_Width: column_key_t = 1018;
pub const column_key_t_Column_Key_Word_Delimiters: column_key_t = 1019;
#[doc = " <add-type id=\"column_key_t def\"></add-type>"]
pub type column_key_t = ::std::os::raw::c_uint;
#[doc = " Header property keys"]
pub const extra_header_key_t_Extra_Header_Key_Row: extra_header_key_t = 2000;
#[doc = " Header property keys"]
pub const extra_header_key_t_Extra_Header_Key_Name: extra_header_key_t = 2001;
#[doc = " Header property keys"]
pub const extra_header_key_t_Extra_Header_Key_Description: extra_header_key_t = 2002;
#[doc = " Header property keys"]
pub const extra_header_key_t_Extra_Header_Key_First_Column: extra_header_key_t = 2003;
#[doc = " Header property keys"]
pub const extra_header_key_t_Extra_Header_Key_Last_Column: extra_header_key_t = 2004;
#[doc = " <add-type id=\"extra_header_key_t def\"></add-type>"]
pub type extra_header_key_t = ::std::os::raw::c_uint;
pub type table_interface_t = table_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct table_interface {
    #[doc = " Returns all rows and columns in the following format:\n[[[i|f|s|o|n*]*]] where the outer list is the row\nand the inner list is the data for each column."]
    pub data: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    #[doc = " Defines the table structure and meta-data for the table\nusing a list of key/value pairs.\n[[[ia]*]*] where the integer is the key taken from the\ntable_properties_t. The value is key-specific."]
    pub properties:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_table_interface() {
    const UNINIT: ::std::mem::MaybeUninit<table_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<table_interface>(),
        16usize,
        concat!("Size of: ", stringify!(table_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<table_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(table_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(table_interface),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(table_interface),
            "::",
            stringify!(properties)
        )
    );
}
pub type breakpoint_registration_interface_t = breakpoint_registration_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_registration_interface {
    pub register_breakpoint: ::std::option::Option<
        unsafe extern "C" fn(
            mgr: *mut conf_object_t,
            delete_breakpoint: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, id: uint64),
            >,
            delete_data: cbdata_register_t,
            get_properties: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, id: uint64) -> attr_value_t,
            >,
            get_properties_data: cbdata_register_t,
            set_enabled: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, id: uint64, enabled: bool),
            >,
            set_enabled_data: cbdata_register_t,
            set_temporary: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, id: uint64, temporary: bool),
            >,
            set_temporary_data: cbdata_register_t,
            set_ignore_count: ::std::option::Option<
                unsafe extern "C" fn(data: cbdata_call_t, id: uint64, ignore_count: uint64),
            >,
            set_ignore_count_data: cbdata_register_t,
        ) -> uint64,
    >,
    pub deleted: ::std::option::Option<unsafe extern "C" fn(mgr: *mut conf_object_t, id: uint64)>,
}
#[test]
fn bindgen_test_layout_breakpoint_registration_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_registration_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_registration_interface>(),
        16usize,
        concat!("Size of: ", stringify!(breakpoint_registration_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_registration_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(breakpoint_registration_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_breakpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_registration_interface),
            "::",
            stringify!(register_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deleted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_registration_interface),
            "::",
            stringify!(deleted)
        )
    );
}
pub type breakpoint_type_interface_t = breakpoint_type_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_type_interface {
    #[doc = " Returns false if type is already registered."]
    pub register_type: ::std::option::Option<
        unsafe extern "C" fn(
            mgr: *mut conf_object_t,
            name: *const ::std::os::raw::c_char,
            provider: *mut conf_object_t,
            args: attr_value_t,
            cls: *const ::std::os::raw::c_char,
            iface: *const ::std::os::raw::c_char,
            docs: attr_value_t,
            object_required: bool,
            temporary_default: bool,
            recursive: bool,
        ) -> bool,
    >,
    #[doc = " Notify manager that breakpoint has triggered, given ID returned by\nadd_bp. Returns true if simulation was stopped or otherwise the\nbreakpoint action happened. Optionally provide trigger object and\nmessage, used if the simulation is stopped."]
    pub trigger: ::std::option::Option<
        unsafe extern "C" fn(
            mgr: *mut conf_object_t,
            provider: *mut conf_object_t,
            bp_id: uint64,
            trigger: *mut conf_object_t,
            msg: *const ::std::os::raw::c_char,
        ) -> bool,
    >,
    #[doc = " Return provider ID from breakpoint manager ID."]
    pub get_break_id: ::std::option::Option<
        unsafe extern "C" fn(mgr: *mut conf_object_t, bm_id: uint64) -> uint64,
    >,
    pub get_manager_id: ::std::option::Option<
        unsafe extern "C" fn(
            mgr: *mut conf_object_t,
            provider: *mut conf_object_t,
            bp_id: uint64,
        ) -> uint64,
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_type_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_type_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_type_interface>(),
        32usize,
        concat!("Size of: ", stringify!(breakpoint_type_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_type_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_type_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_interface),
            "::",
            stringify!(register_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_interface),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_break_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_interface),
            "::",
            stringify!(get_break_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_manager_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_interface),
            "::",
            stringify!(get_manager_id)
        )
    );
}
pub const sim_bp_type_t_Breakpoint_Type_Default: sim_bp_type_t = 0;
pub const sim_bp_type_t_Breakpoint_Type_Break: sim_bp_type_t = 1;
pub const sim_bp_type_t_Breakpoint_Type_Run_Until: sim_bp_type_t = 2;
pub const sim_bp_type_t_Breakpoint_Type_Wait_For: sim_bp_type_t = 3;
pub const sim_bp_type_t_Breakpoint_Type_Trace: sim_bp_type_t = 4;
#[doc = " Sent as flags to breakpoint_type_provider.add_bp, for providers that need\nto know from which command the breakpoint comes."]
pub type sim_bp_type_t = ::std::os::raw::c_uint;
pub type breakpoint_type_provider_interface_t = breakpoint_type_provider_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_type_provider_interface {
    #[doc = " Register breakpoint in manager.\nReturn breakpoint manager ID, or 0 on error."]
    pub register_bp: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bp_id: uint64) -> uint64,
    >,
    #[doc = " Add breakpoint and return provider specific ID, or 0 on error."]
    pub add_bp: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            flags: ::std::os::raw::c_int,
            data: attr_value_t,
        ) -> uint64,
    >,
    #[doc = " Remove breakpoint, given ID returned by add_bp."]
    pub remove_bp:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, bp_id: uint64)>,
    #[doc = " Return trace message, given ID returned by add_bp."]
    pub trace_msg: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bp_id: uint64,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Message returned by break command, given ID returned by add_bp."]
    pub break_msg: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bp_id: uint64,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Script branch wait message, given ID returned by add_bp."]
    pub wait_msg: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            bp_id: uint64,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Optional return value from wait-for and run-until commands,\ngiven ID returned by add_bp."]
    pub break_data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, bp_id: uint64) -> attr_value_t,
    >,
    #[doc = " Return possible values for command argument.\nOptional unless expanders used."]
    pub values: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            arg: *const ::std::os::raw::c_char,
            prev_args: attr_value_t,
        ) -> attr_value_t,
    >,
    #[doc = " Optional trace output function. The default is to log on the\nprovider with level 1 and group 0."]
    pub trace: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, msg: *const ::std::os::raw::c_char),
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_type_provider_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_type_provider_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_type_provider_interface>(),
        72usize,
        concat!("Size of: ", stringify!(breakpoint_type_provider_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_type_provider_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(breakpoint_type_provider_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_bp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(register_bp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_bp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(add_bp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_bp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(remove_bp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_msg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(trace_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).break_msg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(break_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait_msg) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(wait_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).break_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(break_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_type_provider_interface),
            "::",
            stringify!(trace)
        )
    );
}
pub type breakpoint_manager_interface_t = breakpoint_manager_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct breakpoint_manager_interface {
    #[doc = " Return a list of the breakpoint ids of all breakpoints."]
    pub list_breakpoints:
        ::std::option::Option<unsafe extern "C" fn(mgr: *mut conf_object_t) -> attr_value_t>,
    pub delete_breakpoint:
        ::std::option::Option<unsafe extern "C" fn(mgr: *mut conf_object_t, id: uint64)>,
    #[doc = " Return a dictionary with the properties for a specific breakpoint"]
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(mgr: *mut conf_object_t, id: uint64) -> attr_value_t,
    >,
    pub set_enabled: ::std::option::Option<
        unsafe extern "C" fn(mgr: *mut conf_object_t, id: uint64, enabled: bool) -> bool,
    >,
    pub set_temporary: ::std::option::Option<
        unsafe extern "C" fn(mgr: *mut conf_object_t, id: uint64, temporary: bool) -> bool,
    >,
    pub set_ignore_count: ::std::option::Option<
        unsafe extern "C" fn(mgr: *mut conf_object_t, id: uint64, ignore_count: uint64) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_breakpoint_manager_interface() {
    const UNINIT: ::std::mem::MaybeUninit<breakpoint_manager_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<breakpoint_manager_interface>(),
        48usize,
        concat!("Size of: ", stringify!(breakpoint_manager_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<breakpoint_manager_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(breakpoint_manager_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_breakpoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_manager_interface),
            "::",
            stringify!(list_breakpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_breakpoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_manager_interface),
            "::",
            stringify!(delete_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_manager_interface),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_enabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_manager_interface),
            "::",
            stringify!(set_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_temporary) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_manager_interface),
            "::",
            stringify!(set_temporary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_ignore_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(breakpoint_manager_interface),
            "::",
            stringify!(set_ignore_count)
        )
    );
}
#[doc = " Identifier of the probe"]
pub const probe_key_t_Probe_Key_Name: probe_key_t = 0;
#[doc = " string, any of: {\n\"int\", \"float, \"fraction\",\n\"histogram\", \"int128\", \"string\"\n}"]
pub const probe_key_t_Probe_Key_Type: probe_key_t = 1;
#[doc = " list of strings"]
pub const probe_key_t_Probe_Key_Categories: probe_key_t = 2;
#[doc = " bool"]
pub const probe_key_t_Probe_Key_Cause_Slowdown: probe_key_t = 3;
#[doc = " object: owner object"]
pub const probe_key_t_Probe_Key_Owner_Object: probe_key_t = 4;
#[doc = " string: short narrow name"]
pub const probe_key_t_Probe_Key_Display_Name: probe_key_t = 5;
#[doc = " string"]
pub const probe_key_t_Probe_Key_Description: probe_key_t = 6;
pub const probe_key_t_Probe_Key_Float_Percent: probe_key_t = 7;
pub const probe_key_t_Probe_Key_Float_Decimals: probe_key_t = 8;
pub const probe_key_t_Probe_Key_Metric_Prefix: probe_key_t = 9;
pub const probe_key_t_Probe_Key_Unit: probe_key_t = 10;
pub const probe_key_t_Probe_Key_Binary_Prefix: probe_key_t = 11;
pub const probe_key_t_Probe_Key_Time_Format: probe_key_t = 12;
pub const probe_key_t_Probe_Key_Width: probe_key_t = 13;
pub const probe_key_t_Probe_Key_Value_Notifier: probe_key_t = 14;
#[doc = " [list of properties] OBSOLETE"]
pub const probe_key_t_Probe_Key_Global_Sum: probe_key_t = 15;
#[doc = " [list of properties] OBSOLETE"]
pub const probe_key_t_Probe_Key_Cell_Sum: probe_key_t = 16;
#[doc = " Defines new probes which aggregate\nover this probe:\n[list of [list properties]]\nInvalid for Type: \"string\""]
pub const probe_key_t_Probe_Key_Aggregates: probe_key_t = 17;
#[doc = " Aggregate over all probes in the cells\nor all probes in the system.\nString and of [\"global\", \"cell\"]"]
pub const probe_key_t_Probe_Key_Aggregate_Scope: probe_key_t = 18;
#[doc = " How the aggregation should be done:\n\"sum\",\n\"weighted-arith-mean\", - only fractions"]
pub const probe_key_t_Probe_Key_Aggregate_Function: probe_key_t = 19;
#[doc = " string: how the probe is\ncalculated"]
pub const probe_key_t_Probe_Key_Definition: probe_key_t = 20;
#[doc = " <add-type id=\"probe_key_t def\"></add-type>"]
pub type probe_key_t = ::std::os::raw::c_uint;
pub type probe_interface_t = probe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct probe_interface {
    pub value: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
    pub properties:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> attr_value_t>,
}
#[test]
fn bindgen_test_layout_probe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<probe_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<probe_interface>(),
        16usize,
        concat!("Size of: ", stringify!(probe_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<probe_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(probe_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_interface),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_interface),
            "::",
            stringify!(properties)
        )
    );
}
pub type probe_index_interface_t = probe_index_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct probe_index_interface {
    pub num_indices: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub value: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, idx: ::std::os::raw::c_int) -> attr_value_t,
    >,
    pub properties: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, idx: ::std::os::raw::c_int) -> attr_value_t,
    >,
}
#[test]
fn bindgen_test_layout_probe_index_interface() {
    const UNINIT: ::std::mem::MaybeUninit<probe_index_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<probe_index_interface>(),
        24usize,
        concat!("Size of: ", stringify!(probe_index_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<probe_index_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(probe_index_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_indices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_index_interface),
            "::",
            stringify!(num_indices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_index_interface),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_index_interface),
            "::",
            stringify!(properties)
        )
    );
}
pub type probe_subscribe_interface_t = probe_subscribe_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct probe_subscribe_interface {
    pub subscribe: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub unsubscribe: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub num_subscribers: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_probe_subscribe_interface() {
    const UNINIT: ::std::mem::MaybeUninit<probe_subscribe_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<probe_subscribe_interface>(),
        24usize,
        concat!("Size of: ", stringify!(probe_subscribe_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<probe_subscribe_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(probe_subscribe_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_subscribe_interface),
            "::",
            stringify!(subscribe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsubscribe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_subscribe_interface),
            "::",
            stringify!(unsubscribe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_subscribers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_subscribe_interface),
            "::",
            stringify!(num_subscribers)
        )
    );
}
pub type probe_cache_interface_t = probe_cache_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct probe_cache_interface {
    pub start: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_probe_cache_interface() {
    const UNINIT: ::std::mem::MaybeUninit<probe_cache_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<probe_cache_interface>(),
        16usize,
        concat!("Size of: ", stringify!(probe_cache_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<probe_cache_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(probe_cache_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_cache_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_cache_interface),
            "::",
            stringify!(stop)
        )
    );
}
pub type probe_sampler_cache_interface_t = probe_sampler_cache_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct probe_sampler_cache_interface {
    pub enable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub disable: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub get_generation:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint64>,
}
#[test]
fn bindgen_test_layout_probe_sampler_cache_interface() {
    const UNINIT: ::std::mem::MaybeUninit<probe_sampler_cache_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<probe_sampler_cache_interface>(),
        24usize,
        concat!("Size of: ", stringify!(probe_sampler_cache_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<probe_sampler_cache_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(probe_sampler_cache_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_sampler_cache_interface),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_sampler_cache_interface),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_generation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_sampler_cache_interface),
            "::",
            stringify!(get_generation)
        )
    );
}
pub type probe_notification_context_interface_t = probe_notification_context_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct probe_notification_context_interface {
    pub get: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> *mut lang_void>,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, context: *mut lang_void),
    >,
}
#[test]
fn bindgen_test_layout_probe_notification_context_interface() {
    const UNINIT: ::std::mem::MaybeUninit<probe_notification_context_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<probe_notification_context_interface>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(probe_notification_context_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<probe_notification_context_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(probe_notification_context_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_notification_context_interface),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(probe_notification_context_interface),
            "::",
            stringify!(set)
        )
    );
}
pub type serial_console_frontend_interface_t = serial_console_frontend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct serial_console_frontend_interface {
    pub write: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, value: uint8)>,
}
#[test]
fn bindgen_test_layout_serial_console_frontend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<serial_console_frontend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<serial_console_frontend_interface>(),
        8usize,
        concat!("Size of: ", stringify!(serial_console_frontend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<serial_console_frontend_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(serial_console_frontend_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_console_frontend_interface),
            "::",
            stringify!(write)
        )
    );
}
pub type con_input_interface_t = con_input_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct con_input_interface {
    pub input_str: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, str_: *const ::std::os::raw::c_char),
    >,
    pub input_data:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, data: bytes_t)>,
}
#[test]
fn bindgen_test_layout_con_input_interface() {
    const UNINIT: ::std::mem::MaybeUninit<con_input_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<con_input_interface>(),
        16usize,
        concat!("Size of: ", stringify!(con_input_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<con_input_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(con_input_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(con_input_interface),
            "::",
            stringify!(input_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(con_input_interface),
            "::",
            stringify!(input_data)
        )
    );
}
pub type con_input_code_interface_t = con_input_code_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct con_input_code_interface {
    pub input: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, code: sim_key_t, down: bool),
    >,
}
#[test]
fn bindgen_test_layout_con_input_code_interface() {
    const UNINIT: ::std::mem::MaybeUninit<con_input_code_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<con_input_code_interface>(),
        8usize,
        concat!("Size of: ", stringify!(con_input_code_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<con_input_code_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(con_input_code_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(con_input_code_interface),
            "::",
            stringify!(input)
        )
    );
}
#[doc = " <add id=\"break_string_cb_t DOC\">\n<ndx>break_string_cb_t</ndx>\n<name index=\"true\">break_string_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">break_string_cb_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> Callback function used by the string\nbreakpoint system, called when the associated string breakpoint has\nmatched. The <arg>obj</arg> parameter is the console where the breakpoint\nmatched, <arg>str</arg> is the break string that matched,\n<arg>break_id</arg> is the associated breakpoint id, returned by the\n<fun>add</fun> or <fun>add_single</fun> method in the\n<iface>break_strings</iface> interface, and <arg>arg</arg> is the callback\ndata passed to that method. The return value is ignored.\n</doc-item>\n</doc></add>"]
pub type break_string_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        str_: *const ::std::os::raw::c_char,
        break_id: int64,
        arg: *mut lang_void,
    ) -> ::std::os::raw::c_int,
>;
pub type break_strings_interface_t = break_strings_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct break_strings_interface {
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            str_: *const ::std::os::raw::c_char,
            cb: break_string_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
    pub add_single: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            str_: *const ::std::os::raw::c_char,
            cb: break_string_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
    pub remove: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, bp_id: int64)>,
}
#[test]
fn bindgen_test_layout_break_strings_interface() {
    const UNINIT: ::std::mem::MaybeUninit<break_strings_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<break_strings_interface>(),
        24usize,
        concat!("Size of: ", stringify!(break_strings_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<break_strings_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(break_strings_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_single) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_interface),
            "::",
            stringify!(add_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_interface),
            "::",
            stringify!(remove)
        )
    );
}
pub type break_strings_v2_interface_t = break_strings_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct break_strings_v2_interface {
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            str_: *const ::std::os::raw::c_char,
            cb: break_string_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
    pub add_single: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            str_: *const ::std::os::raw::c_char,
            cb: break_string_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
    pub add_regexp: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            str_: *const ::std::os::raw::c_char,
            cb: break_string_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
    pub remove: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, bp_id: int64)>,
}
#[test]
fn bindgen_test_layout_break_strings_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<break_strings_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<break_strings_v2_interface>(),
        32usize,
        concat!("Size of: ", stringify!(break_strings_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<break_strings_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(break_strings_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_v2_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_single) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_v2_interface),
            "::",
            stringify!(add_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_regexp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_v2_interface),
            "::",
            stringify!(add_regexp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(break_strings_v2_interface),
            "::",
            stringify!(remove)
        )
    );
}
#[doc = " <add id=\"gfx_break_cb_t DOC\">\n<ndx>gfx_break_cb_t</ndx>\n<name index=\"true\">gfx_break_cb_t</name>\n<doc>\n<doc-item name=\"NAME\">gfx_break_cb_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> Callback function used by the graphics\nbreakpoint system, called when the associated graphical breakpoint has\nmatched. The <arg>obj</arg> parameter is the graphics console where the\nbreakpoint matched, <arg>break_id</arg> is the associated breakpoint id,\nreturned by the <fun>add</fun> method in the <iface>gfx_break</iface>\ninterface, and <arg>arg</arg> is the callback data passed to that method.\n</doc-item>\n</doc></add>"]
pub type gfx_break_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut conf_object_t,
        break_id: int64,
        arg: *mut lang_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <add id=\"gbp_header_t DOC\">\n<ndx>gbp_header_t</ndx>\n<name index=\"true\">gbp_header_t</name>\n<doc>\n<doc-item name=\"NAME\">gbp_header_t</doc-item>\n\n<doc-item name=\"DESCRIPTION\"> Header for graphical breakpoint files, also\nreturned by the <fun>info</fun> method of the <iface>gfx_break</iface>\ninterface.\n\nThe fields <var>magic</var> and <var>format</var> are always\n<tt>GBP_MAGIC</tt> and <tt>GBP_FMT_V3_32</tt>, respectively.\n\nThe field <var>bytes</var> is the size of the image data in the file, not\nincluding the header.\n\nThe other fields specify the breakpoint image patch location on the screen.\n</doc-item>\n</doc></add>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gbp_header_t {
    pub magic: uint32,
    pub format: uint32,
    pub bytes: uint64,
    pub minx: uint32,
    pub miny: uint32,
    pub maxx: uint32,
    pub maxy: uint32,
}
#[test]
fn bindgen_test_layout_gbp_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<gbp_header_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gbp_header_t>(),
        32usize,
        concat!("Size of: ", stringify!(gbp_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gbp_header_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gbp_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miny) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gbp_header_t),
            "::",
            stringify!(maxy)
        )
    );
}
pub type gfx_break_interface_t = gfx_break_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gfx_break_interface {
    pub store: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            file: *const ::std::os::raw::c_char,
            minx: ::std::os::raw::c_int,
            miny: ::std::os::raw::c_int,
            maxx: ::std::os::raw::c_int,
            maxy: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            file: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
            oneshot: bool,
            interval: f64,
            cb: gfx_break_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, break_id: int64) -> bool,
    >,
    pub match_: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            file: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub info: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            file: *const ::std::os::raw::c_char,
        ) -> gbp_header_t,
    >,
    pub export_png: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            file: *const ::std::os::raw::c_char,
            png_file: *const ::std::os::raw::c_char,
        ) -> bool,
    >,
    pub add_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            data: bytes_t,
            name: *const ::std::os::raw::c_char,
            oneshot: bool,
            interval: f64,
            cb: gfx_break_cb_t,
            arg: *mut lang_void,
        ) -> int64,
    >,
}
#[test]
fn bindgen_test_layout_gfx_break_interface() {
    const UNINIT: ::std::mem::MaybeUninit<gfx_break_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gfx_break_interface>(),
        56usize,
        concat!("Size of: ", stringify!(gfx_break_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<gfx_break_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(gfx_break_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).store) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(store)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).export_png) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(export_png)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_bytes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_break_interface),
            "::",
            stringify!(add_bytes)
        )
    );
}
pub type telnet_connection_interface_t = telnet_connection_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct telnet_connection_interface {
    pub setup:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, port: uint16) -> bool>,
    pub listening: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub connected: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub remote_port: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint16>,
    pub remote_ip: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bytes_t>,
    pub local_port: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint16>,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_telnet_connection_interface() {
    const UNINIT: ::std::mem::MaybeUninit<telnet_connection_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<telnet_connection_interface>(),
        64usize,
        concat!("Size of: ", stringify!(telnet_connection_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_connection_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_connection_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listening) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(listening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_interface),
            "::",
            stringify!(shutdown)
        )
    );
}
pub type telnet_connection_v2_interface_t = telnet_connection_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct telnet_connection_v2_interface {
    pub listening: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub connected: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_telnet_connection_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<telnet_connection_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<telnet_connection_v2_interface>(),
        24usize,
        concat!("Size of: ", stringify!(telnet_connection_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_connection_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_connection_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listening) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_v2_interface),
            "::",
            stringify!(listening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_v2_interface),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_connection_v2_interface),
            "::",
            stringify!(disconnect)
        )
    );
}
pub type vnc_server_interface_t = vnc_server_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vnc_server_interface {
    pub setup:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, port: uint16) -> bool>,
    pub listening: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub num_clients: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub local_port: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> uint16>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_vnc_server_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vnc_server_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vnc_server_interface>(),
        40usize,
        concat!("Size of: ", stringify!(vnc_server_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_server_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_server_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_interface),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listening) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_interface),
            "::",
            stringify!(listening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_clients) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_interface),
            "::",
            stringify!(num_clients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_interface),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_interface),
            "::",
            stringify!(shutdown)
        )
    );
}
pub type vnc_server_v2_interface_t = vnc_server_v2_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct vnc_server_v2_interface {
    pub listening: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t) -> bool>,
    pub num_clients: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_vnc_server_v2_interface() {
    const UNINIT: ::std::mem::MaybeUninit<vnc_server_v2_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vnc_server_v2_interface>(),
        24usize,
        concat!("Size of: ", stringify!(vnc_server_v2_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_server_v2_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_server_v2_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listening) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_v2_interface),
            "::",
            stringify!(listening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_clients) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_v2_interface),
            "::",
            stringify!(num_clients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_server_v2_interface),
            "::",
            stringify!(disconnect)
        )
    );
}
pub type host_serial_interface_t = host_serial_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct host_serial_interface {
    pub setup: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, name: *const ::std::os::raw::c_char) -> bool,
    >,
    pub name: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> *const ::std::os::raw::c_char,
    >,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_host_serial_interface() {
    const UNINIT: ::std::mem::MaybeUninit<host_serial_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<host_serial_interface>(),
        24usize,
        concat!("Size of: ", stringify!(host_serial_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<host_serial_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(host_serial_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_serial_interface),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(host_serial_interface),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(host_serial_interface),
            "::",
            stringify!(shutdown)
        )
    );
}
pub type screenshot_interface_t = screenshot_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct screenshot_interface {
    pub save_png: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            filename: *const ::std::os::raw::c_char,
        ) -> bool,
    >,
    pub save_bmp: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            filename: *const ::std::os::raw::c_char,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_screenshot_interface() {
    const UNINIT: ::std::mem::MaybeUninit<screenshot_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<screenshot_interface>(),
        16usize,
        concat!("Size of: ", stringify!(screenshot_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<screenshot_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(screenshot_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_png) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(screenshot_interface),
            "::",
            stringify!(save_png)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_bmp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(screenshot_interface),
            "::",
            stringify!(save_bmp)
        )
    );
}
pub const text_console_text_attrib_t_Text_Console_Attrib_Bold: text_console_text_attrib_t = 1;
pub const text_console_text_attrib_t_Text_Console_Attrib_Underline: text_console_text_attrib_t = 2;
#[doc = " Text console character attributes.\nInverse video is represented by swapping the foreground and background\ncolours, so there is no bit for it here."]
pub type text_console_text_attrib_t = ::std::os::raw::c_uint;
pub const text_console_colour_t_Text_Console_Colour_Black: text_console_colour_t = 0;
pub const text_console_colour_t_Text_Console_Colour_Red: text_console_colour_t = 1;
pub const text_console_colour_t_Text_Console_Colour_Green: text_console_colour_t = 2;
pub const text_console_colour_t_Text_Console_Colour_Yellow: text_console_colour_t = 3;
pub const text_console_colour_t_Text_Console_Colour_Blue: text_console_colour_t = 4;
pub const text_console_colour_t_Text_Console_Colour_Magenta: text_console_colour_t = 5;
pub const text_console_colour_t_Text_Console_Colour_Cyan: text_console_colour_t = 6;
pub const text_console_colour_t_Text_Console_Colour_White: text_console_colour_t = 7;
pub const text_console_colour_t_Text_Console_Colour_Black_Bright: text_console_colour_t = 8;
pub const text_console_colour_t_Text_Console_Colour_Red_Bright: text_console_colour_t = 9;
pub const text_console_colour_t_Text_Console_Colour_Green_Bright: text_console_colour_t = 10;
pub const text_console_colour_t_Text_Console_Colour_Yellow_Bright: text_console_colour_t = 11;
pub const text_console_colour_t_Text_Console_Colour_Blue_Bright: text_console_colour_t = 12;
pub const text_console_colour_t_Text_Console_Colour_Magenta_Bright: text_console_colour_t = 13;
pub const text_console_colour_t_Text_Console_Colour_Cyan_Bright: text_console_colour_t = 14;
pub const text_console_colour_t_Text_Console_Colour_White_Bright: text_console_colour_t = 15;
pub const text_console_colour_t_Text_Console_Colour_Cube_16: text_console_colour_t = 16;
pub const text_console_colour_t_Text_Console_Colour_Cube_17: text_console_colour_t = 17;
pub const text_console_colour_t_Text_Console_Colour_Cube_18: text_console_colour_t = 18;
pub const text_console_colour_t_Text_Console_Colour_Cube_19: text_console_colour_t = 19;
pub const text_console_colour_t_Text_Console_Colour_Cube_20: text_console_colour_t = 20;
pub const text_console_colour_t_Text_Console_Colour_Cube_21: text_console_colour_t = 21;
pub const text_console_colour_t_Text_Console_Colour_Cube_22: text_console_colour_t = 22;
pub const text_console_colour_t_Text_Console_Colour_Cube_23: text_console_colour_t = 23;
pub const text_console_colour_t_Text_Console_Colour_Cube_24: text_console_colour_t = 24;
pub const text_console_colour_t_Text_Console_Colour_Cube_25: text_console_colour_t = 25;
pub const text_console_colour_t_Text_Console_Colour_Cube_26: text_console_colour_t = 26;
pub const text_console_colour_t_Text_Console_Colour_Cube_27: text_console_colour_t = 27;
pub const text_console_colour_t_Text_Console_Colour_Cube_28: text_console_colour_t = 28;
pub const text_console_colour_t_Text_Console_Colour_Cube_29: text_console_colour_t = 29;
pub const text_console_colour_t_Text_Console_Colour_Cube_30: text_console_colour_t = 30;
pub const text_console_colour_t_Text_Console_Colour_Cube_31: text_console_colour_t = 31;
pub const text_console_colour_t_Text_Console_Colour_Cube_32: text_console_colour_t = 32;
pub const text_console_colour_t_Text_Console_Colour_Cube_33: text_console_colour_t = 33;
pub const text_console_colour_t_Text_Console_Colour_Cube_34: text_console_colour_t = 34;
pub const text_console_colour_t_Text_Console_Colour_Cube_35: text_console_colour_t = 35;
pub const text_console_colour_t_Text_Console_Colour_Cube_36: text_console_colour_t = 36;
pub const text_console_colour_t_Text_Console_Colour_Cube_37: text_console_colour_t = 37;
pub const text_console_colour_t_Text_Console_Colour_Cube_38: text_console_colour_t = 38;
pub const text_console_colour_t_Text_Console_Colour_Cube_39: text_console_colour_t = 39;
pub const text_console_colour_t_Text_Console_Colour_Cube_40: text_console_colour_t = 40;
pub const text_console_colour_t_Text_Console_Colour_Cube_41: text_console_colour_t = 41;
pub const text_console_colour_t_Text_Console_Colour_Cube_42: text_console_colour_t = 42;
pub const text_console_colour_t_Text_Console_Colour_Cube_43: text_console_colour_t = 43;
pub const text_console_colour_t_Text_Console_Colour_Cube_44: text_console_colour_t = 44;
pub const text_console_colour_t_Text_Console_Colour_Cube_45: text_console_colour_t = 45;
pub const text_console_colour_t_Text_Console_Colour_Cube_46: text_console_colour_t = 46;
pub const text_console_colour_t_Text_Console_Colour_Cube_47: text_console_colour_t = 47;
pub const text_console_colour_t_Text_Console_Colour_Cube_48: text_console_colour_t = 48;
pub const text_console_colour_t_Text_Console_Colour_Cube_49: text_console_colour_t = 49;
pub const text_console_colour_t_Text_Console_Colour_Cube_50: text_console_colour_t = 50;
pub const text_console_colour_t_Text_Console_Colour_Cube_51: text_console_colour_t = 51;
pub const text_console_colour_t_Text_Console_Colour_Cube_52: text_console_colour_t = 52;
pub const text_console_colour_t_Text_Console_Colour_Cube_53: text_console_colour_t = 53;
pub const text_console_colour_t_Text_Console_Colour_Cube_54: text_console_colour_t = 54;
pub const text_console_colour_t_Text_Console_Colour_Cube_55: text_console_colour_t = 55;
pub const text_console_colour_t_Text_Console_Colour_Cube_56: text_console_colour_t = 56;
pub const text_console_colour_t_Text_Console_Colour_Cube_57: text_console_colour_t = 57;
pub const text_console_colour_t_Text_Console_Colour_Cube_58: text_console_colour_t = 58;
pub const text_console_colour_t_Text_Console_Colour_Cube_59: text_console_colour_t = 59;
pub const text_console_colour_t_Text_Console_Colour_Cube_60: text_console_colour_t = 60;
pub const text_console_colour_t_Text_Console_Colour_Cube_61: text_console_colour_t = 61;
pub const text_console_colour_t_Text_Console_Colour_Cube_62: text_console_colour_t = 62;
pub const text_console_colour_t_Text_Console_Colour_Cube_63: text_console_colour_t = 63;
pub const text_console_colour_t_Text_Console_Colour_Cube_64: text_console_colour_t = 64;
pub const text_console_colour_t_Text_Console_Colour_Cube_65: text_console_colour_t = 65;
pub const text_console_colour_t_Text_Console_Colour_Cube_66: text_console_colour_t = 66;
pub const text_console_colour_t_Text_Console_Colour_Cube_67: text_console_colour_t = 67;
pub const text_console_colour_t_Text_Console_Colour_Cube_68: text_console_colour_t = 68;
pub const text_console_colour_t_Text_Console_Colour_Cube_69: text_console_colour_t = 69;
pub const text_console_colour_t_Text_Console_Colour_Cube_70: text_console_colour_t = 70;
pub const text_console_colour_t_Text_Console_Colour_Cube_71: text_console_colour_t = 71;
pub const text_console_colour_t_Text_Console_Colour_Cube_72: text_console_colour_t = 72;
pub const text_console_colour_t_Text_Console_Colour_Cube_73: text_console_colour_t = 73;
pub const text_console_colour_t_Text_Console_Colour_Cube_74: text_console_colour_t = 74;
pub const text_console_colour_t_Text_Console_Colour_Cube_75: text_console_colour_t = 75;
pub const text_console_colour_t_Text_Console_Colour_Cube_76: text_console_colour_t = 76;
pub const text_console_colour_t_Text_Console_Colour_Cube_77: text_console_colour_t = 77;
pub const text_console_colour_t_Text_Console_Colour_Cube_78: text_console_colour_t = 78;
pub const text_console_colour_t_Text_Console_Colour_Cube_79: text_console_colour_t = 79;
pub const text_console_colour_t_Text_Console_Colour_Cube_80: text_console_colour_t = 80;
pub const text_console_colour_t_Text_Console_Colour_Cube_81: text_console_colour_t = 81;
pub const text_console_colour_t_Text_Console_Colour_Cube_82: text_console_colour_t = 82;
pub const text_console_colour_t_Text_Console_Colour_Cube_83: text_console_colour_t = 83;
pub const text_console_colour_t_Text_Console_Colour_Cube_84: text_console_colour_t = 84;
pub const text_console_colour_t_Text_Console_Colour_Cube_85: text_console_colour_t = 85;
pub const text_console_colour_t_Text_Console_Colour_Cube_86: text_console_colour_t = 86;
pub const text_console_colour_t_Text_Console_Colour_Cube_87: text_console_colour_t = 87;
pub const text_console_colour_t_Text_Console_Colour_Cube_88: text_console_colour_t = 88;
pub const text_console_colour_t_Text_Console_Colour_Cube_89: text_console_colour_t = 89;
pub const text_console_colour_t_Text_Console_Colour_Cube_90: text_console_colour_t = 90;
pub const text_console_colour_t_Text_Console_Colour_Cube_91: text_console_colour_t = 91;
pub const text_console_colour_t_Text_Console_Colour_Cube_92: text_console_colour_t = 92;
pub const text_console_colour_t_Text_Console_Colour_Cube_93: text_console_colour_t = 93;
pub const text_console_colour_t_Text_Console_Colour_Cube_94: text_console_colour_t = 94;
pub const text_console_colour_t_Text_Console_Colour_Cube_95: text_console_colour_t = 95;
pub const text_console_colour_t_Text_Console_Colour_Cube_96: text_console_colour_t = 96;
pub const text_console_colour_t_Text_Console_Colour_Cube_97: text_console_colour_t = 97;
pub const text_console_colour_t_Text_Console_Colour_Cube_98: text_console_colour_t = 98;
pub const text_console_colour_t_Text_Console_Colour_Cube_99: text_console_colour_t = 99;
pub const text_console_colour_t_Text_Console_Colour_Cube_100: text_console_colour_t = 100;
pub const text_console_colour_t_Text_Console_Colour_Cube_101: text_console_colour_t = 101;
pub const text_console_colour_t_Text_Console_Colour_Cube_102: text_console_colour_t = 102;
pub const text_console_colour_t_Text_Console_Colour_Cube_103: text_console_colour_t = 103;
pub const text_console_colour_t_Text_Console_Colour_Cube_104: text_console_colour_t = 104;
pub const text_console_colour_t_Text_Console_Colour_Cube_105: text_console_colour_t = 105;
pub const text_console_colour_t_Text_Console_Colour_Cube_106: text_console_colour_t = 106;
pub const text_console_colour_t_Text_Console_Colour_Cube_107: text_console_colour_t = 107;
pub const text_console_colour_t_Text_Console_Colour_Cube_108: text_console_colour_t = 108;
pub const text_console_colour_t_Text_Console_Colour_Cube_109: text_console_colour_t = 109;
pub const text_console_colour_t_Text_Console_Colour_Cube_110: text_console_colour_t = 110;
pub const text_console_colour_t_Text_Console_Colour_Cube_111: text_console_colour_t = 111;
pub const text_console_colour_t_Text_Console_Colour_Cube_112: text_console_colour_t = 112;
pub const text_console_colour_t_Text_Console_Colour_Cube_113: text_console_colour_t = 113;
pub const text_console_colour_t_Text_Console_Colour_Cube_114: text_console_colour_t = 114;
pub const text_console_colour_t_Text_Console_Colour_Cube_115: text_console_colour_t = 115;
pub const text_console_colour_t_Text_Console_Colour_Cube_116: text_console_colour_t = 116;
pub const text_console_colour_t_Text_Console_Colour_Cube_117: text_console_colour_t = 117;
pub const text_console_colour_t_Text_Console_Colour_Cube_118: text_console_colour_t = 118;
pub const text_console_colour_t_Text_Console_Colour_Cube_119: text_console_colour_t = 119;
pub const text_console_colour_t_Text_Console_Colour_Cube_120: text_console_colour_t = 120;
pub const text_console_colour_t_Text_Console_Colour_Cube_121: text_console_colour_t = 121;
pub const text_console_colour_t_Text_Console_Colour_Cube_122: text_console_colour_t = 122;
pub const text_console_colour_t_Text_Console_Colour_Cube_123: text_console_colour_t = 123;
pub const text_console_colour_t_Text_Console_Colour_Cube_124: text_console_colour_t = 124;
pub const text_console_colour_t_Text_Console_Colour_Cube_125: text_console_colour_t = 125;
pub const text_console_colour_t_Text_Console_Colour_Cube_126: text_console_colour_t = 126;
pub const text_console_colour_t_Text_Console_Colour_Cube_127: text_console_colour_t = 127;
pub const text_console_colour_t_Text_Console_Colour_Cube_128: text_console_colour_t = 128;
pub const text_console_colour_t_Text_Console_Colour_Cube_129: text_console_colour_t = 129;
pub const text_console_colour_t_Text_Console_Colour_Cube_130: text_console_colour_t = 130;
pub const text_console_colour_t_Text_Console_Colour_Cube_131: text_console_colour_t = 131;
pub const text_console_colour_t_Text_Console_Colour_Cube_132: text_console_colour_t = 132;
pub const text_console_colour_t_Text_Console_Colour_Cube_133: text_console_colour_t = 133;
pub const text_console_colour_t_Text_Console_Colour_Cube_134: text_console_colour_t = 134;
pub const text_console_colour_t_Text_Console_Colour_Cube_135: text_console_colour_t = 135;
pub const text_console_colour_t_Text_Console_Colour_Cube_136: text_console_colour_t = 136;
pub const text_console_colour_t_Text_Console_Colour_Cube_137: text_console_colour_t = 137;
pub const text_console_colour_t_Text_Console_Colour_Cube_138: text_console_colour_t = 138;
pub const text_console_colour_t_Text_Console_Colour_Cube_139: text_console_colour_t = 139;
pub const text_console_colour_t_Text_Console_Colour_Cube_140: text_console_colour_t = 140;
pub const text_console_colour_t_Text_Console_Colour_Cube_141: text_console_colour_t = 141;
pub const text_console_colour_t_Text_Console_Colour_Cube_142: text_console_colour_t = 142;
pub const text_console_colour_t_Text_Console_Colour_Cube_143: text_console_colour_t = 143;
pub const text_console_colour_t_Text_Console_Colour_Cube_144: text_console_colour_t = 144;
pub const text_console_colour_t_Text_Console_Colour_Cube_145: text_console_colour_t = 145;
pub const text_console_colour_t_Text_Console_Colour_Cube_146: text_console_colour_t = 146;
pub const text_console_colour_t_Text_Console_Colour_Cube_147: text_console_colour_t = 147;
pub const text_console_colour_t_Text_Console_Colour_Cube_148: text_console_colour_t = 148;
pub const text_console_colour_t_Text_Console_Colour_Cube_149: text_console_colour_t = 149;
pub const text_console_colour_t_Text_Console_Colour_Cube_150: text_console_colour_t = 150;
pub const text_console_colour_t_Text_Console_Colour_Cube_151: text_console_colour_t = 151;
pub const text_console_colour_t_Text_Console_Colour_Cube_152: text_console_colour_t = 152;
pub const text_console_colour_t_Text_Console_Colour_Cube_153: text_console_colour_t = 153;
pub const text_console_colour_t_Text_Console_Colour_Cube_154: text_console_colour_t = 154;
pub const text_console_colour_t_Text_Console_Colour_Cube_155: text_console_colour_t = 155;
pub const text_console_colour_t_Text_Console_Colour_Cube_156: text_console_colour_t = 156;
pub const text_console_colour_t_Text_Console_Colour_Cube_157: text_console_colour_t = 157;
pub const text_console_colour_t_Text_Console_Colour_Cube_158: text_console_colour_t = 158;
pub const text_console_colour_t_Text_Console_Colour_Cube_159: text_console_colour_t = 159;
pub const text_console_colour_t_Text_Console_Colour_Cube_160: text_console_colour_t = 160;
pub const text_console_colour_t_Text_Console_Colour_Cube_161: text_console_colour_t = 161;
pub const text_console_colour_t_Text_Console_Colour_Cube_162: text_console_colour_t = 162;
pub const text_console_colour_t_Text_Console_Colour_Cube_163: text_console_colour_t = 163;
pub const text_console_colour_t_Text_Console_Colour_Cube_164: text_console_colour_t = 164;
pub const text_console_colour_t_Text_Console_Colour_Cube_165: text_console_colour_t = 165;
pub const text_console_colour_t_Text_Console_Colour_Cube_166: text_console_colour_t = 166;
pub const text_console_colour_t_Text_Console_Colour_Cube_167: text_console_colour_t = 167;
pub const text_console_colour_t_Text_Console_Colour_Cube_168: text_console_colour_t = 168;
pub const text_console_colour_t_Text_Console_Colour_Cube_169: text_console_colour_t = 169;
pub const text_console_colour_t_Text_Console_Colour_Cube_170: text_console_colour_t = 170;
pub const text_console_colour_t_Text_Console_Colour_Cube_171: text_console_colour_t = 171;
pub const text_console_colour_t_Text_Console_Colour_Cube_172: text_console_colour_t = 172;
pub const text_console_colour_t_Text_Console_Colour_Cube_173: text_console_colour_t = 173;
pub const text_console_colour_t_Text_Console_Colour_Cube_174: text_console_colour_t = 174;
pub const text_console_colour_t_Text_Console_Colour_Cube_175: text_console_colour_t = 175;
pub const text_console_colour_t_Text_Console_Colour_Cube_176: text_console_colour_t = 176;
pub const text_console_colour_t_Text_Console_Colour_Cube_177: text_console_colour_t = 177;
pub const text_console_colour_t_Text_Console_Colour_Cube_178: text_console_colour_t = 178;
pub const text_console_colour_t_Text_Console_Colour_Cube_179: text_console_colour_t = 179;
pub const text_console_colour_t_Text_Console_Colour_Cube_180: text_console_colour_t = 180;
pub const text_console_colour_t_Text_Console_Colour_Cube_181: text_console_colour_t = 181;
pub const text_console_colour_t_Text_Console_Colour_Cube_182: text_console_colour_t = 182;
pub const text_console_colour_t_Text_Console_Colour_Cube_183: text_console_colour_t = 183;
pub const text_console_colour_t_Text_Console_Colour_Cube_184: text_console_colour_t = 184;
pub const text_console_colour_t_Text_Console_Colour_Cube_185: text_console_colour_t = 185;
pub const text_console_colour_t_Text_Console_Colour_Cube_186: text_console_colour_t = 186;
pub const text_console_colour_t_Text_Console_Colour_Cube_187: text_console_colour_t = 187;
pub const text_console_colour_t_Text_Console_Colour_Cube_188: text_console_colour_t = 188;
pub const text_console_colour_t_Text_Console_Colour_Cube_189: text_console_colour_t = 189;
pub const text_console_colour_t_Text_Console_Colour_Cube_190: text_console_colour_t = 190;
pub const text_console_colour_t_Text_Console_Colour_Cube_191: text_console_colour_t = 191;
pub const text_console_colour_t_Text_Console_Colour_Cube_192: text_console_colour_t = 192;
pub const text_console_colour_t_Text_Console_Colour_Cube_193: text_console_colour_t = 193;
pub const text_console_colour_t_Text_Console_Colour_Cube_194: text_console_colour_t = 194;
pub const text_console_colour_t_Text_Console_Colour_Cube_195: text_console_colour_t = 195;
pub const text_console_colour_t_Text_Console_Colour_Cube_196: text_console_colour_t = 196;
pub const text_console_colour_t_Text_Console_Colour_Cube_197: text_console_colour_t = 197;
pub const text_console_colour_t_Text_Console_Colour_Cube_198: text_console_colour_t = 198;
pub const text_console_colour_t_Text_Console_Colour_Cube_199: text_console_colour_t = 199;
pub const text_console_colour_t_Text_Console_Colour_Cube_200: text_console_colour_t = 200;
pub const text_console_colour_t_Text_Console_Colour_Cube_201: text_console_colour_t = 201;
pub const text_console_colour_t_Text_Console_Colour_Cube_202: text_console_colour_t = 202;
pub const text_console_colour_t_Text_Console_Colour_Cube_203: text_console_colour_t = 203;
pub const text_console_colour_t_Text_Console_Colour_Cube_204: text_console_colour_t = 204;
pub const text_console_colour_t_Text_Console_Colour_Cube_205: text_console_colour_t = 205;
pub const text_console_colour_t_Text_Console_Colour_Cube_206: text_console_colour_t = 206;
pub const text_console_colour_t_Text_Console_Colour_Cube_207: text_console_colour_t = 207;
pub const text_console_colour_t_Text_Console_Colour_Cube_208: text_console_colour_t = 208;
pub const text_console_colour_t_Text_Console_Colour_Cube_209: text_console_colour_t = 209;
pub const text_console_colour_t_Text_Console_Colour_Cube_210: text_console_colour_t = 210;
pub const text_console_colour_t_Text_Console_Colour_Cube_211: text_console_colour_t = 211;
pub const text_console_colour_t_Text_Console_Colour_Cube_212: text_console_colour_t = 212;
pub const text_console_colour_t_Text_Console_Colour_Cube_213: text_console_colour_t = 213;
pub const text_console_colour_t_Text_Console_Colour_Cube_214: text_console_colour_t = 214;
pub const text_console_colour_t_Text_Console_Colour_Cube_215: text_console_colour_t = 215;
pub const text_console_colour_t_Text_Console_Colour_Cube_216: text_console_colour_t = 216;
pub const text_console_colour_t_Text_Console_Colour_Cube_217: text_console_colour_t = 217;
pub const text_console_colour_t_Text_Console_Colour_Cube_218: text_console_colour_t = 218;
pub const text_console_colour_t_Text_Console_Colour_Cube_219: text_console_colour_t = 219;
pub const text_console_colour_t_Text_Console_Colour_Cube_220: text_console_colour_t = 220;
pub const text_console_colour_t_Text_Console_Colour_Cube_221: text_console_colour_t = 221;
pub const text_console_colour_t_Text_Console_Colour_Cube_222: text_console_colour_t = 222;
pub const text_console_colour_t_Text_Console_Colour_Cube_223: text_console_colour_t = 223;
pub const text_console_colour_t_Text_Console_Colour_Cube_224: text_console_colour_t = 224;
pub const text_console_colour_t_Text_Console_Colour_Cube_225: text_console_colour_t = 225;
pub const text_console_colour_t_Text_Console_Colour_Cube_226: text_console_colour_t = 226;
pub const text_console_colour_t_Text_Console_Colour_Cube_227: text_console_colour_t = 227;
pub const text_console_colour_t_Text_Console_Colour_Cube_228: text_console_colour_t = 228;
pub const text_console_colour_t_Text_Console_Colour_Cube_229: text_console_colour_t = 229;
pub const text_console_colour_t_Text_Console_Colour_Cube_230: text_console_colour_t = 230;
pub const text_console_colour_t_Text_Console_Colour_Cube_231: text_console_colour_t = 231;
pub const text_console_colour_t_Text_Console_Colour_Grey_232: text_console_colour_t = 232;
pub const text_console_colour_t_Text_Console_Colour_Grey_233: text_console_colour_t = 233;
pub const text_console_colour_t_Text_Console_Colour_Grey_234: text_console_colour_t = 234;
pub const text_console_colour_t_Text_Console_Colour_Grey_235: text_console_colour_t = 235;
pub const text_console_colour_t_Text_Console_Colour_Grey_236: text_console_colour_t = 236;
pub const text_console_colour_t_Text_Console_Colour_Grey_237: text_console_colour_t = 237;
pub const text_console_colour_t_Text_Console_Colour_Grey_238: text_console_colour_t = 238;
pub const text_console_colour_t_Text_Console_Colour_Grey_239: text_console_colour_t = 239;
pub const text_console_colour_t_Text_Console_Colour_Grey_240: text_console_colour_t = 240;
pub const text_console_colour_t_Text_Console_Colour_Grey_241: text_console_colour_t = 241;
pub const text_console_colour_t_Text_Console_Colour_Grey_242: text_console_colour_t = 242;
pub const text_console_colour_t_Text_Console_Colour_Grey_243: text_console_colour_t = 243;
pub const text_console_colour_t_Text_Console_Colour_Grey_244: text_console_colour_t = 244;
pub const text_console_colour_t_Text_Console_Colour_Grey_245: text_console_colour_t = 245;
pub const text_console_colour_t_Text_Console_Colour_Grey_246: text_console_colour_t = 246;
pub const text_console_colour_t_Text_Console_Colour_Grey_247: text_console_colour_t = 247;
pub const text_console_colour_t_Text_Console_Colour_Grey_248: text_console_colour_t = 248;
pub const text_console_colour_t_Text_Console_Colour_Grey_249: text_console_colour_t = 249;
pub const text_console_colour_t_Text_Console_Colour_Grey_250: text_console_colour_t = 250;
pub const text_console_colour_t_Text_Console_Colour_Grey_251: text_console_colour_t = 251;
pub const text_console_colour_t_Text_Console_Colour_Grey_252: text_console_colour_t = 252;
pub const text_console_colour_t_Text_Console_Colour_Grey_253: text_console_colour_t = 253;
pub const text_console_colour_t_Text_Console_Colour_Grey_254: text_console_colour_t = 254;
pub const text_console_colour_t_Text_Console_Colour_Grey_255: text_console_colour_t = 255;
#[doc = " These values represent the chosen default colours."]
pub const text_console_colour_t_Text_Console_Colour_Default_Foreground: text_console_colour_t = 256;
#[doc = " These values represent the chosen default colours."]
pub const text_console_colour_t_Text_Console_Colour_Default_Background: text_console_colour_t = 257;
#[doc = " Text console colours.\nhttps://www.wikipedia.org/wiki/ANSI_escape_code#8-bit"]
pub type text_console_colour_t = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct text_console_attrib_t {
    #[doc = " Bitmask of text_console_text_attrib_t"]
    pub attrib: uint8,
    #[doc = " text_console_colour_t specifying fg colour"]
    pub fg: uint16,
    #[doc = " text_console_colour_t specifying bg colour."]
    pub bg: uint16,
}
#[test]
fn bindgen_test_layout_text_console_attrib_t() {
    const UNINIT: ::std::mem::MaybeUninit<text_console_attrib_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<text_console_attrib_t>(),
        5usize,
        concat!("Size of: ", stringify!(text_console_attrib_t))
    );
    assert_eq!(
        ::std::mem::align_of::<text_console_attrib_t>(),
        1usize,
        concat!("Alignment of ", stringify!(text_console_attrib_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_attrib_t),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fg) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_attrib_t),
            "::",
            stringify!(fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bg) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_attrib_t),
            "::",
            stringify!(bg)
        )
    );
}
pub type text_console_frontend_interface_t = text_console_frontend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct text_console_frontend_interface {
    #[doc = " Called when the console is finalised.\n'backend' is the calling text console."]
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            backend: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called when the console is being destroyed."]
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int),
    >,
    #[doc = " Set the window title.\nTwo title strings are given, where the long title is\nmeant for a window title bar and the short for a window list.\nThe long title string is at least as long as the short."]
    pub set_title: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            short_title: *const ::std::os::raw::c_char,
            long_title: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Called when the screen size of the console changes.\nThe width (columns) and height (rows) are given in characters."]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Specify the maximum scrollback size (in lines)."]
    pub set_max_scrollback_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            num_lines: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Specify new default text colours for the console.\nThese are used for characters whose colours were set to\nText_Console_Colour_Default_Background or\nText_Console_Colour_Default_Foreground."]
    pub set_default_colours: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            default_fg_col: uint32,
            default_bg_col: uint32,
        ),
    >,
    #[doc = " Show/hide the console window."]
    pub set_visible: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int, visible: bool),
    >,
    #[doc = " Update characters and attributes in a rectangle in the console.\n(top, left) is the line and column of the upper left corner;\n(bottom, right) is the line and column of the lower right corner\n(inclusive).\nLines and columns are 0-based. Lines are counted from the top of\nthe visible screen.\n\n'text' and 'attrib' are the text and attribute arrays, respectively,\ninto which the lines and columns are used as indices.\nFor example, the start of the rectangle in the text array is\n&text[width * top + left], where width was set by set_size."]
    pub set_contents: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            top: ::std::os::raw::c_int,
            left: ::std::os::raw::c_int,
            bottom: ::std::os::raw::c_int,
            right: ::std::os::raw::c_int,
            text: *const ::std::os::raw::c_char,
            attrib: *const text_console_attrib_t,
        ),
    >,
    #[doc = " Move the cursor to a new position.\nrow is the new cursor row (0-based), within the visible screen.\ncol is the new cursor column (0-based)."]
    pub set_cursor_pos: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            row: ::std::os::raw::c_int,
            col: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Append text at the bottom of the screen of the console,\nimplicitly scrolling the text upwards.\nnum_lines is the number of lines to append_scroll.\n'text' and 'attrib' are the start of the newly scrolled-in data,\nrepresenting the num_lines bottommost lines of the screen after\nscrolling."]
    pub append_text: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            num_lines: ::std::os::raw::c_int,
            text: *const ::std::os::raw::c_char,
            attrib: *const text_console_attrib_t,
        ),
    >,
    #[doc = " Replace the screen and scrollback data with new information.\n'text' and 'attrib' each contain\nwidth * height elements,\nwhere width and height were set by set_size.\n'sb_text' and 'sb_attrib' each contain\nwidth * scrollback_size elements."]
    pub refresh_screen: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            text: *const ::std::os::raw::c_char,
            attrib: *const text_console_attrib_t,
            sb_text: *const ::std::os::raw::c_char,
            sb_attrib: *const text_console_attrib_t,
            scrollback_size: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_text_console_frontend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<text_console_frontend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<text_console_frontend_interface>(),
        88usize,
        concat!("Size of: ", stringify!(text_console_frontend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<text_console_frontend_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(text_console_frontend_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_title) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_max_scrollback_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_max_scrollback_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_default_colours) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_default_colours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_visible) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_contents) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_contents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cursor_pos) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(set_cursor_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_text) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(append_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh_screen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_frontend_interface),
            "::",
            stringify!(refresh_screen)
        )
    );
}
pub const text_console_key_t_Text_Console_Key_Tab: text_console_key_t = 9;
pub const text_console_key_t_Text_Console_Key_Return: text_console_key_t = 13;
pub const text_console_key_t_Text_Console_Key_Escape: text_console_key_t = 27;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Backspace: text_console_key_t = 128;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Left: text_console_key_t = 129;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Up: text_console_key_t = 130;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Right: text_console_key_t = 131;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Down: text_console_key_t = 132;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Home: text_console_key_t = 133;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_End: text_console_key_t = 134;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Ins: text_console_key_t = 135;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Del: text_console_key_t = 136;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Pgup: text_console_key_t = 137;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_Pgdn: text_console_key_t = 138;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F1: text_console_key_t = 139;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F2: text_console_key_t = 140;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F3: text_console_key_t = 141;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F4: text_console_key_t = 142;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F5: text_console_key_t = 143;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F6: text_console_key_t = 144;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F7: text_console_key_t = 145;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F8: text_console_key_t = 146;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F9: text_console_key_t = 147;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F10: text_console_key_t = 148;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F11: text_console_key_t = 149;
#[doc = " Backspace has a special code (not 8) to distinguish it from ^H."]
pub const text_console_key_t_Text_Console_Key_F12: text_console_key_t = 150;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_0: text_console_key_t = 151;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_1: text_console_key_t = 152;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_2: text_console_key_t = 153;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_3: text_console_key_t = 154;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_4: text_console_key_t = 155;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_5: text_console_key_t = 156;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_6: text_console_key_t = 157;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_7: text_console_key_t = 158;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_8: text_console_key_t = 159;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_9: text_console_key_t = 160;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_Plus: text_console_key_t = 161;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_Minus: text_console_key_t = 162;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_Mul: text_console_key_t = 163;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_Div: text_console_key_t = 164;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_Dot: text_console_key_t = 165;
#[doc = " Numeric keypad keys."]
pub const text_console_key_t_Text_Console_Key_KP_Enter: text_console_key_t = 166;
#[doc = " Text console keys sent from the GUI to the console."]
pub type text_console_key_t = ::std::os::raw::c_uint;
pub const text_console_modifier_t_Text_Console_Modifier_Alt: text_console_modifier_t = 1;
pub const text_console_modifier_t_Text_Console_Modifier_Ctrl: text_console_modifier_t = 2;
pub const text_console_modifier_t_Text_Console_Modifier_Shift: text_console_modifier_t = 4;
#[doc = " Text console input key modifiers."]
pub type text_console_modifier_t = ::std::os::raw::c_uint;
pub type text_console_backend_interface_t = text_console_backend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct text_console_backend_interface {
    #[doc = " Send a key press to the backend."]
    pub input: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            key: text_console_key_t,
            modifiers: text_console_modifier_t,
        ),
    >,
    #[doc = " Request that the backend should refresh the whole console screen.\nShortly after this call, the frontend can expect a call to\ntext_console_frontend.refresh_screen."]
    pub request_refresh: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " Indicate to the backend whether the frontend is visible, e.g. if\nthe console window is hidden by other windows or minimised.\nThe backend may then choose not to call any text or cursor update\nfunctions in the text_console_frontend interface."]
    pub set_visible:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, visible: bool)>,
    #[doc = " Returns 1 + the maximum column on the given line\nwith a printable character. The frontend may use this information\nfor e.g. user marking and copying text.\nline_num is 0-based and indexes over the screen for positive values\nand negative values to indicate scrollback lines."]
    pub line_length: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            line_num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Indicate whether the specified line was not finished with an explicit\ncarriage return by the user, and hence wraps to the next line.\nThe frontend may use this information for e.g. user marking\nand copying text.\nline_num is 0-based and indexes over the screen for positive values\nand negative values to indicate scrollback lines."]
    pub line_wrap: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, line_num: ::std::os::raw::c_int) -> bool,
    >,
    #[doc = " Tell the console to change the screen size. Note that this is\nvisible to the target software this call therefore impacts the\nsimulation. An immediate call to text_console_frontend.set_size\nwill follow a call to this function."]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Tell the console to change the default text colours. An immediate\ncall to text_console_frontend.set_default_colours will follow a\ncall to this function."]
    pub set_default_colours: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            default_fg_col: uint32,
            default_bg_col: uint32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_text_console_backend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<text_console_backend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<text_console_backend_interface>(),
        56usize,
        concat!("Size of: ", stringify!(text_console_backend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<text_console_backend_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(text_console_backend_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_refresh) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(request_refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_visible) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(set_visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(line_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_wrap) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(line_wrap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_default_colours) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(text_console_backend_interface),
            "::",
            stringify!(set_default_colours)
        )
    );
}
pub const gfx_console_led_t_Gfx_Console_Led_None: gfx_console_led_t = 0;
pub const gfx_console_led_t_Gfx_Console_Led_Caps: gfx_console_led_t = 1;
pub const gfx_console_led_t_Gfx_Console_Led_Num: gfx_console_led_t = 2;
pub const gfx_console_led_t_Gfx_Console_Led_Scroll: gfx_console_led_t = 4;
#[doc = " Keyboard LED status bitmask."]
pub type gfx_console_led_t = ::std::os::raw::c_uint;
pub const gfx_console_mouse_button_t_Gfx_Console_Mouse_Button_Left: gfx_console_mouse_button_t = 1;
pub const gfx_console_mouse_button_t_Gfx_Console_Mouse_Button_Right: gfx_console_mouse_button_t = 2;
pub const gfx_console_mouse_button_t_Gfx_Console_Mouse_Button_Middle: gfx_console_mouse_button_t =
    4;
#[doc = " Identifiers for graphics console mouse input."]
pub type gfx_console_mouse_button_t = ::std::os::raw::c_uint;
pub type gfx_console_frontend_interface_t = gfx_console_frontend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gfx_console_frontend_interface {
    #[doc = " Called when the backend is finalised. Should return a unique handle\n identifying the given backend object to the frontend."]
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            backend: *mut conf_object_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called when the backend is being destroyed."]
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int),
    >,
    #[doc = " Set window title of the frontend associated to the specified backend.\n Two title strings are given, where the long title is\n meant for a window title bar and the short for a window list.\n The long title string is at least as long as the short."]
    pub set_title: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            short_title: *const ::std::os::raw::c_char,
            long_title: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Called when the screen size of the specified backend changes."]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Tell the frontend to show/hide its GUI window."]
    pub set_visible: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int, visible: bool),
    >,
    #[doc = " Update the screen contents in the rectangle between (left, top)\nand (right, bottom), inclusive.\n'data' is the start of the screen pixel array, so the first\npixel of the rectangle is at &data[width * top + left],\nwhere width was set by set_size."]
    pub set_contents: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            left: ::std::os::raw::c_int,
            top: ::std::os::raw::c_int,
            right: ::std::os::raw::c_int,
            bottom: ::std::os::raw::c_int,
            data: *const uint32,
        ),
    >,
    #[doc = " Tell the frontend that the data argument passed to set_contents\n is no longer valid.\n This must be called upon a screen size change, before set_size."]
    pub invalidate_contents: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int),
    >,
    #[doc = " Inform the frontend whether or not we are currently in VGA text mode."]
    pub set_text_mode: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            text_mode: bool,
        ),
    >,
    #[doc = " Tell the frontend that text arrived to the backend from the attached\n device, using vga_text_update."]
    pub signal_text_update: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int),
    >,
    #[doc = " Inform the frontend that the grab mode of the specified backend\n has changed."]
    pub set_grab_mode: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, handle: ::std::os::raw::c_int, active: bool),
    >,
    #[doc = " Tell the frontend to set the host mouse cursor to (x, y),\nwith ranges [0, width - 1] and [0, height - 1], where\nwidth and height were set by set_size."]
    pub set_mouse_pos: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Inform frontend that the keyboard LED state have been updated.\nThe new state of the LEDs is given as a bitmask."]
    pub set_keyboard_leds: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            led_state: gfx_console_led_t,
        ),
    >,
    #[doc = " Inform frontend that the grab modifier has changed."]
    pub set_grab_modifier: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            modifier: sim_key_t,
        ),
    >,
    #[doc = " Inform frontend that the grab button has changed."]
    pub set_grab_button: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            handle: ::std::os::raw::c_int,
            button: gfx_console_mouse_button_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_gfx_console_frontend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<gfx_console_frontend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gfx_console_frontend_interface>(),
        112usize,
        concat!("Size of: ", stringify!(gfx_console_frontend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<gfx_console_frontend_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(gfx_console_frontend_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_title) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_visible) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_contents) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_contents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate_contents) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(invalidate_contents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_text_mode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_text_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_text_update) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(signal_text_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_grab_mode) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_grab_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_mouse_pos) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_mouse_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_keyboard_leds) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_keyboard_leds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_grab_modifier) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_grab_modifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_grab_button) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_frontend_interface),
            "::",
            stringify!(set_grab_button)
        )
    );
}
#[doc = " VGA text mode data.\n Stored in this file since we have the VGA device pointer here."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gfx_console_screen_text_t {
    #[doc = " Screen text (text_width × text_height), in some 8-bit ASCII\nsuperset (we assume CP437)."]
    pub text: bytes_t,
    #[doc = " Text screen size in character cells."]
    pub rows: ::std::os::raw::c_int,
    #[doc = " Text screen size in character cells."]
    pub columns: ::std::os::raw::c_int,
    #[doc = " Text cell size in pixels."]
    pub font_width: ::std::os::raw::c_int,
    #[doc = " Text cell size in pixels."]
    pub font_height: ::std::os::raw::c_int,
    #[doc = " Length of each line (text_height elements), beyond which there\nis only empty space. Each element is in [0, columns]."]
    pub line_lengths: bytes_t,
}
#[test]
fn bindgen_test_layout_gfx_console_screen_text_t() {
    const UNINIT: ::std::mem::MaybeUninit<gfx_console_screen_text_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gfx_console_screen_text_t>(),
        48usize,
        concat!("Size of: ", stringify!(gfx_console_screen_text_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gfx_console_screen_text_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gfx_console_screen_text_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_screen_text_t),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_screen_text_t),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_screen_text_t),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_screen_text_t),
            "::",
            stringify!(font_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_screen_text_t),
            "::",
            stringify!(font_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_lengths) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_screen_text_t),
            "::",
            stringify!(line_lengths)
        )
    );
}
impl Default for gfx_console_screen_text_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gfx_console_backend_interface_t = gfx_console_backend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gfx_console_backend_interface {
    #[doc = " Indicate to the backend that a key has been pressed or released."]
    pub kbd_event: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, code: sim_key_t, down: bool),
    >,
    #[doc = " Indicate to the backend that the mouse state has changed.\n(x, y) are in screen coordinates (pixels).\nz is the mouse wheel: 1 if the wheel has rolled upwards, -1 for\ndownwards, 0 for no change.\n'buttons' is the current button state."]
    pub mouse_event: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            z: ::std::os::raw::c_int,
            buttons: gfx_console_mouse_button_t,
        ),
    >,
    #[doc = " Request that the backend should refresh the whole console screen.\n Shortly after this call, the frontend can expect a call to\n gfx_console_frontend.set_contents, updating the whole screen."]
    pub request_refresh: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
    #[doc = " Indicate to the backend whether the frontend is visible, e.g. if\n the console window is hidden by other windows or minimised.\n If the frontend is invisible, the backend may choose not to call\n gfx_console_frontend.set_contents."]
    pub set_visible:
        ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t, visible: bool)>,
    #[doc = " Obtain VGA text data from console backend. If the console is not in\n VGA text mode, the result is undefined."]
    pub text_data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> gfx_console_screen_text_t,
    >,
    #[doc = " Inform the backed that the grab mode keys were pressed."]
    pub got_grab_keys: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_gfx_console_backend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<gfx_console_backend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gfx_console_backend_interface>(),
        48usize,
        concat!("Size of: ", stringify!(gfx_console_backend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<gfx_console_backend_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(gfx_console_backend_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kbd_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_backend_interface),
            "::",
            stringify!(kbd_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouse_event) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_backend_interface),
            "::",
            stringify!(mouse_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_refresh) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_backend_interface),
            "::",
            stringify!(request_refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_visible) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_backend_interface),
            "::",
            stringify!(set_visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_backend_interface),
            "::",
            stringify!(text_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).got_grab_keys) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gfx_console_backend_interface),
            "::",
            stringify!(got_grab_keys)
        )
    );
}
pub const winsome_update_type_t_Winsome_Update_Nothing: winsome_update_type_t = 0;
pub const winsome_update_type_t_Winsome_Update_Text_Cursor: winsome_update_type_t = 1;
pub const winsome_update_type_t_Winsome_Update_Append: winsome_update_type_t = 2;
pub const winsome_update_type_t_Winsome_Update_Refresh: winsome_update_type_t = 3;
pub const winsome_update_type_t_Winsome_Update_Gfx: winsome_update_type_t = 4;
pub const winsome_update_type_t_Winsome_Update_Resize: winsome_update_type_t = 5;
pub const winsome_update_type_t_Winsome_Update_Activity: winsome_update_type_t = 6;
#[doc = " Possible update messages that can be sent to Winsome in a winsome_update_t."]
pub type winsome_update_type_t = ::std::os::raw::c_uint;
#[doc = " Main structure for sending console updates to the Winsome GUI.\nThis is converted to a Python tuple with data corresponding to the\ndifferent parts of the union. Data buffers such as screen and attribute data\nare converted to Python strings."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct winsome_update_t {
    #[doc = " Indicates which part of the union is used."]
    pub type_: winsome_update_type_t,
    pub u: winsome_update_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union winsome_update_t__bindgen_ty_1 {
    pub text: winsome_update_t__bindgen_ty_1__bindgen_ty_1,
    pub sb: winsome_update_t__bindgen_ty_1__bindgen_ty_2,
    pub refresh: winsome_update_t__bindgen_ty_1__bindgen_ty_3,
    pub resize: winsome_update_t__bindgen_ty_1__bindgen_ty_4,
    pub gfx: winsome_update_t__bindgen_ty_1__bindgen_ty_5,
}
#[doc = " Data for a message containing text console screen update\nand cursor movement. This corresponds to calls to\nset_contents and set_cursor_pos in text_console_frontend,\naccumulated in the obvious way: take the bounding box of\nthe updated rectangles and the last cursor position."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct winsome_update_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Heap-allocated contents of new screen rectangle.\n Each array has\n (right - left + 1) * (bottom - top + 1)\n elements."]
    pub text: *mut ::std::os::raw::c_char,
    pub attrib: *mut text_console_attrib_t,
    #[doc = " Coordinates on screen of new data."]
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    #[doc = " New cursor position."]
    pub cursor_x: ::std::os::raw::c_int,
    pub cursor_y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_winsome_update_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cursor_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_y) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cursor_y)
        )
    );
}
impl Default for winsome_update_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data for a message containing text console append and cursor\nmovement. This corresponds to calls to append_text and\nset_cursor_pos in text_console_frontend, accumulated in the\nobvious way: append the text lines and take the last cursor\nposition."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct winsome_update_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Number of lines to append."]
    pub num_lines: uint64,
    #[doc = " Pointers to start of text at new lines."]
    pub text: *mut ::std::os::raw::c_char,
    pub attrib: *mut text_console_attrib_t,
    #[doc = " Length of buffers in characters."]
    pub text_len: uint64,
    #[doc = " New cursor position."]
    pub cursor_x: ::std::os::raw::c_int,
    pub cursor_y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_winsome_update_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_2>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_lines) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(num_lines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(text_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(cursor_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_y) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(cursor_y)
        )
    );
}
impl Default for winsome_update_t__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data for a message containing text console screen refresh.\nThis corresponds to calls to refresh_screen\nin text_console_frontend."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct winsome_update_t__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Heap-allocated contents of visible screen rectangle.\n Each array has width * height elements."]
    pub text: *mut ::std::os::raw::c_char,
    pub attrib: *mut text_console_attrib_t,
    #[doc = " Heap-allocated contents of scrollback.\n Each array has width * sb_size elements."]
    pub sb_text: *mut ::std::os::raw::c_char,
    pub sb_attrib: *mut text_console_attrib_t,
    #[doc = " Screen size."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " Number of scrollback lines."]
    pub sb_size: ::std::os::raw::c_int,
    #[doc = " New cursor position."]
    pub cursor_x: ::std::os::raw::c_int,
    pub cursor_y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_winsome_update_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_3>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sb_text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sb_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sb_attrib) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sb_attrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sb_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sb_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_x) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(cursor_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(cursor_y)
        )
    );
}
impl Default for winsome_update_t__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data for a message containing text console screen resize.\nThis corresponds to calls to set_size\nin text_console_frontend."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct winsome_update_t__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " New screen size."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_winsome_update_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Data for a message containing graphics console updates.\nThis corresponds to calls to set_contents in\ngfx_console_frontend, accumulated in the\nobvious way: take the bounding box of the updated\nrectangles."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct winsome_update_t__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " New pixels for the dirty rectangle (owned)."]
    pub data: *mut uint32,
    #[doc = " Dirty rectangle"]
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    #[doc = " Current/new screen size"]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " Are we currently in VGA text mode?"]
    pub text_mode: bool,
}
#[test]
fn bindgen_test_layout_winsome_update_t__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_5>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_mode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(text_mode)
        )
    );
}
impl Default for winsome_update_t__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_winsome_update_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(winsome_update_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(winsome_update_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1),
            "::",
            stringify!(sb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gfx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t__bindgen_ty_1),
            "::",
            stringify!(gfx)
        )
    );
}
impl Default for winsome_update_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_winsome_update_t() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_update_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_update_t>(),
        64usize,
        concat!("Size of: ", stringify!(winsome_update_t))
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_update_t>(),
        8usize,
        concat!("Alignment of ", stringify!(winsome_update_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_update_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for winsome_update_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type winsome_console_interface_t = winsome_console_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct winsome_console_interface {
    pub gfx: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            console: *mut lang_void,
            left: ::std::os::raw::c_int,
            right: ::std::os::raw::c_int,
            top: ::std::os::raw::c_int,
            bottom: ::std::os::raw::c_int,
            data: bytes_t,
            text_mode: bool,
        ),
    >,
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            console: *mut lang_void,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    pub refresh: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            console: *mut lang_void,
            text: bytes_t,
            attrib: bytes_t,
            sb_text: bytes_t,
            sb_attrib: bytes_t,
            sb_size: ::std::os::raw::c_int,
            cursor_x: ::std::os::raw::c_int,
            cursor_y: ::std::os::raw::c_int,
        ),
    >,
    pub append: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            console: *mut lang_void,
            num_lines: uint64,
            text: bytes_t,
            attrib: bytes_t,
            cursor_x: ::std::os::raw::c_int,
            cursor_y: ::std::os::raw::c_int,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut conf_object_t,
            console: *mut lang_void,
            left: ::std::os::raw::c_int,
            right: ::std::os::raw::c_int,
            top: ::std::os::raw::c_int,
            bottom: ::std::os::raw::c_int,
            text: bytes_t,
            attrib: bytes_t,
            cursor_x: ::std::os::raw::c_int,
            cursor_y: ::std::os::raw::c_int,
        ),
    >,
    pub activity: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, console: *mut lang_void),
    >,
}
#[test]
fn bindgen_test_layout_winsome_console_interface() {
    const UNINIT: ::std::mem::MaybeUninit<winsome_console_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<winsome_console_interface>(),
        48usize,
        concat!("Size of: ", stringify!(winsome_console_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<winsome_console_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(winsome_console_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gfx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_console_interface),
            "::",
            stringify!(gfx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_console_interface),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_console_interface),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_console_interface),
            "::",
            stringify!(append)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_console_interface),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activity) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(winsome_console_interface),
            "::",
            stringify!(activity)
        )
    );
}
pub type gui_console_backend_interface_t = gui_console_backend_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gui_console_backend_interface {
    pub start: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, console: *mut lang_void),
    >,
    pub stop: ::std::option::Option<unsafe extern "C" fn(obj: *mut conf_object_t)>,
}
#[test]
fn bindgen_test_layout_gui_console_backend_interface() {
    const UNINIT: ::std::mem::MaybeUninit<gui_console_backend_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gui_console_backend_interface>(),
        16usize,
        concat!("Size of: ", stringify!(gui_console_backend_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<gui_console_backend_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(gui_console_backend_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gui_console_backend_interface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gui_console_backend_interface),
            "::",
            stringify!(stop)
        )
    );
}
extern "C" {
    pub fn VT_get_hide_consoles_flag() -> ::std::os::raw::c_int;
}
pub type checkpoint_interface_t = checkpoint_interface;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct checkpoint_interface {
    pub save: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, path: *const ::std::os::raw::c_char),
    >,
    pub finish: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t, success: ::std::os::raw::c_int),
    >,
    pub has_persistent_data: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut conf_object_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_checkpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<checkpoint_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<checkpoint_interface>(),
        24usize,
        concat!("Size of: ", stringify!(checkpoint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<checkpoint_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(checkpoint_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(checkpoint_interface),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(checkpoint_interface),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_persistent_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(checkpoint_interface),
            "::",
            stringify!(has_persistent_data)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 13 = __LC_LAST."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _dictkeysobject {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct proplist {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct log_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct confdata {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct extension_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct thread_domain {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct transaction_cache {
    pub _address: u8,
}
#[doc = " NULL if no intervals here"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interval_bucket {
    pub _address: u8,
}
#[doc = " Back-pointer to interface."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iface {
    pub _address: u8,
}
