// Copyright (C) 2023 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

//! Defines a Fault that is interpreted by the `FaultDetector` component of the
//! module to determine what faults are "valid" i.e. are faults that we care about for a
//! given run. For example, an x86_64 edk2 UEFI application dereferncing an unmapped
//! pointer will generate a Page Fault (exception #14 on x86).
//!
//! The top-level `Fault` enum is designed to be platform-independent, and encapsulates a
//! platform-specific fault enum. In general, additional sideband faults can be defined
//! as negative numbers, although this may not be supported on all platforms

extern crate num_traits;
use anyhow::{anyhow, Error, Result};
use num_derive::FromPrimitive;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, FromPrimitive, Hash, PartialEq, Eq, Copy, Clone)]
#[repr(i64)]
/// An X86 CPU Fault. Faults are generated by SIMICS' `Core_Exception` HAP and checked
/// against a set of faults that are considered crashes for a given fuzzing campaign. Most
/// of these faults are self-explanatory or documented in the SDM
pub enum X86_64Fault {
    /// Triple Fault
    ///
    /// Triple fault doesn't have a number, so we choose -1 which will never be the exception
    /// number
    Triple = -1,
    Division = 0,
    Debug = 1,
    NonMaskableInterrupt = 2,
    Breakpoint = 3,
    Overflow = 4,
    BoundRangeExceeded = 5,
    InvalidOpcode = 6,
    DeviceNotAvailable = 7,
    Double = 8,
    InvalidTss = 10,
    SegmentNotPresent = 11,
    StackSegment = 12,
    GeneralProtection = 13,
    Page = 14,
    X86Fpe = 16,
    AlignmentCheck = 17,
    MachineCheck = 18,
    SimdFpen = 19,
    Virtualization = 20,
    ControlProtection = 21,
    HypervisorInjection = 28,
    VMMCommunication = 29,
    Security = 30,
}

impl TryFrom<i64> for X86_64Fault {
    type Error = Error;

    /// Try to convert an i64 to a fault and fail if the number is unknown
    fn try_from(value: i64) -> Result<Self> {
        num::FromPrimitive::from_i64(value).ok_or_else(|| anyhow!("Could not convert to Fault"))
    }
}

impl X86_64Fault {
    pub fn all() -> Vec<Fault> {
        vec![
            Fault::X86_64(X86_64Fault::Triple),
            Fault::X86_64(X86_64Fault::Division),
            Fault::X86_64(X86_64Fault::Debug),
            Fault::X86_64(X86_64Fault::NonMaskableInterrupt),
            Fault::X86_64(X86_64Fault::Breakpoint),
            Fault::X86_64(X86_64Fault::Overflow),
            Fault::X86_64(X86_64Fault::BoundRangeExceeded),
            Fault::X86_64(X86_64Fault::InvalidOpcode),
            Fault::X86_64(X86_64Fault::DeviceNotAvailable),
            Fault::X86_64(X86_64Fault::Double),
            Fault::X86_64(X86_64Fault::InvalidTss),
            Fault::X86_64(X86_64Fault::SegmentNotPresent),
            Fault::X86_64(X86_64Fault::StackSegment),
            Fault::X86_64(X86_64Fault::GeneralProtection),
            Fault::X86_64(X86_64Fault::Page),
            Fault::X86_64(X86_64Fault::X86Fpe),
            Fault::X86_64(X86_64Fault::AlignmentCheck),
            Fault::X86_64(X86_64Fault::MachineCheck),
            Fault::X86_64(X86_64Fault::SimdFpen),
            Fault::X86_64(X86_64Fault::Virtualization),
            Fault::X86_64(X86_64Fault::ControlProtection),
            Fault::X86_64(X86_64Fault::HypervisorInjection),
            Fault::X86_64(X86_64Fault::VMMCommunication),
            Fault::X86_64(X86_64Fault::Security),
        ]
    }
}

#[derive(Debug, Serialize, Deserialize, Hash, PartialEq, Eq, Copy, Clone)]
#[repr(i64)]
/// An architecture independent container for faults on various architectures
pub enum Fault {
    X86_64(X86_64Fault),
}
