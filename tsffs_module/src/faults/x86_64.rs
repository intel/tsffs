extern crate num_traits;
use anyhow::{Context, Error, Result};
use num_derive::{FromPrimitive, ToPrimitive};
use num_traits::ToPrimitive;
use serde::{Deserialize, Serialize};

use super::Fault;

#[derive(
    Debug, Serialize, Deserialize, FromPrimitive, Hash, PartialEq, Eq, Copy, Clone, ToPrimitive,
)]
#[repr(i64)]
/// An X86 CPU Fault. Faults are generated by SIMICS' `Core_Exception` HAP and checked
/// against a set of faults that are considered crashes for a given fuzzing campaign. Most
/// of these faults are self-explanatory or documented in the SDM
pub enum X86_64Fault {
    /// Triple Fault
    ///
    /// Triple fault doesn't have a number, so we choose -1 which will never be the exception
    /// number
    Triple = -1,
    Division = 0,
    Debug = 1,
    NonMaskableInterrupt = 2,
    Breakpoint = 3,
    Overflow = 4,
    BoundRangeExceeded = 5,
    InvalidOpcode = 6,
    DeviceNotAvailable = 7,
    Double = 8,
    InvalidTss = 10,
    SegmentNotPresent = 11,
    StackSegment = 12,
    GeneralProtection = 13,
    Page = 14,
    X86Fpe = 16,
    AlignmentCheck = 17,
    MachineCheck = 18,
    SimdFpen = 19,
    Virtualization = 20,
    ControlProtection = 21,
    HypervisorInjection = 28,
    VMMCommunication = 29,
    Security = 30,
}

impl TryFrom<i64> for X86_64Fault {
    type Error = Error;

    /// Try to convert an i64 to a fault and fail if the number is unknown
    fn try_from(value: i64) -> Result<Self> {
        num::FromPrimitive::from_i64(value).context("Could not convert to Fault")
    }
}

impl TryInto<i64> for X86_64Fault {
    type Error = Error;
    fn try_into(self) -> Result<i64> {
        self.to_i64().context("Could not convert self to i64")
    }
}

impl TryInto<i64> for &X86_64Fault {
    type Error = Error;
    fn try_into(self) -> Result<i64> {
        self.to_i64().context("Could not convert self to i64")
    }
}

impl X86_64Fault {
    /// All faults. Using this isn't recommended.
    pub fn all() -> Vec<Fault> {
        vec![
            Fault::X86_64(X86_64Fault::Triple),
            Fault::X86_64(X86_64Fault::Division),
            Fault::X86_64(X86_64Fault::Debug),
            Fault::X86_64(X86_64Fault::NonMaskableInterrupt),
            Fault::X86_64(X86_64Fault::Breakpoint),
            Fault::X86_64(X86_64Fault::Overflow),
            Fault::X86_64(X86_64Fault::BoundRangeExceeded),
            Fault::X86_64(X86_64Fault::InvalidOpcode),
            Fault::X86_64(X86_64Fault::DeviceNotAvailable),
            Fault::X86_64(X86_64Fault::Double),
            Fault::X86_64(X86_64Fault::InvalidTss),
            Fault::X86_64(X86_64Fault::SegmentNotPresent),
            Fault::X86_64(X86_64Fault::StackSegment),
            Fault::X86_64(X86_64Fault::GeneralProtection),
            Fault::X86_64(X86_64Fault::Page),
            Fault::X86_64(X86_64Fault::X86Fpe),
            Fault::X86_64(X86_64Fault::AlignmentCheck),
            Fault::X86_64(X86_64Fault::MachineCheck),
            Fault::X86_64(X86_64Fault::SimdFpen),
            Fault::X86_64(X86_64Fault::Virtualization),
            Fault::X86_64(X86_64Fault::ControlProtection),
            Fault::X86_64(X86_64Fault::HypervisorInjection),
            Fault::X86_64(X86_64Fault::VMMCommunication),
            Fault::X86_64(X86_64Fault::Security),
        ]
    }
}
