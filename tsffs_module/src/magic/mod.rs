// Copyright (C) 2023 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

//! Magic instructions raised by guest software

extern crate num_traits;
use anyhow::{Context, Error, Result};
use num_derive::{FromPrimitive, ToPrimitive};
use num_traits::ToPrimitive as _;
use serde::{Deserialize, Serialize};

// Magic number definitions for harnessing via magic instruction. The lowest `n` value is `12` on
// ARM, so all magic numbers must stay below this number.

// NOTE: 0x00 is reserved
/// MAGIC_START, when passed as the value of `n` in a [Magic
/// Instruction](https://simics-download.pdx.intel.com/simics-6/docs/html/simics-user-guide/breakpoints.html#Magic-Breakpoints)
/// indicates that the register `ARG0` and `ARG1` (as defined per platform) are set to the buffer
/// pointer and a pointer to the buffer size, respectively.
pub const MAGIC_START: u16 = 0x0001;
/// MAGIC_STOP, when passed as the value of `n` in a [Magic
/// Instruction](https://simics-download.pdx.intel.com/simics-6/docs/html/simics-user-guide/breakpoints.html#Magic-Breakpoints)
/// indicates that execution should stop, and the root fuzzing snapshot should be restored
pub const MAGIC_STOP: u16 = 0x0002;
/// MAGIC_START_WININTRIN, when passed as the value of `n` in a magic instruction, indicates a
/// magic start sequence that is supported by X64 windows intrinsic `__cpuidex`. This signals the
/// start of the following sequence of cpuid (as this is only supported on X64) instructions:
/// - cpuid eax=[(MAGIC_START_WININTRIN << 16U) | MAGIC] ecx=(BUFFER_PTR & 0xffffffff)
/// - cpuid eax=[(MAGIC_START_WININTRIN << 16U) | MAGIC] ecx=((BUFFER_PTR >> 32U) & 0xffffffff)
/// - cpuid eax=[(MAGIC_START_WININTRIN << 16U) | MAGIC] ecx=(SIZE & 0xffffffff)
/// - cpuid eax=[(MAGIC_START_WININTRIN << 16U) | MAGIC] ecx=((SIZE >> 32U) & 0xffffffff)
///
/// The first three `__cpuid` calls output no value into the `cpuInfo` buffer. The fourth sets
/// `cpuInfo` to:
///
/// ```c
///  {
///     BUFFER_PTR & 0xffffffff,
///     (BUFFER_PTR >> 32U) & 0xffffffff,
///     SIZE & 0xffffffff,
///     (SIZE >> 32U) & 0xffffffff,
/// }
/// ```
pub const MAGIC_START_WININTRIN: u16 = 0x0003;
// NOTE: 0x0c is reserved

// Defined by the fuzzer, these are the registers we retrieve buffer/size and extended values
// from for each architecture and are used by the include crate to generate C headers and a Rust
// target software interface
pub const MAGIC_ARG0_REG_X86: &str = "esi";
pub const MAGIC_ARG1_REG_X86: &str = "edi";
pub const MAGIC_ARG0_REG_X86_64: &str = "rsi";
pub const MAGIC_ARG1_REG_X86_64: &str = "rdi";

/// Holds the following, in order, over 4 cpuid invocations:
/// - Lower 32 of buffer ptr
/// - upper 32 of buffer ptr
/// - lower 32 of size
/// - upper 32 of size
pub const MAGIC_ARG0_REG_X86_64_WININTRIN: &str = "ecx";

/// Holds the low 32 bits of the buffer pointer during output
pub const MAGIC_OUT0_REG_X86_64_WININTRIN: &str = "eax";
/// Holds the high 32 bits of the buffer pointer during output
pub const MAGIC_OUT1_REG_X86_64_WININTRIN: &str = "ebx";
/// Holds the low 32 bits of the size during output
pub const MAGIC_OUT2_REG_X86_64_WININTRIN: &str = "ecx";
/// Holds the high 32 bits of the size during output
pub const MAGIC_OUT3_REG_X86_64_WININTRIN: &str = "edx";

#[derive(Debug, ToPrimitive, FromPrimitive, Serialize, Deserialize, Clone)]
#[repr(u16)]
/// A Magic value that can be generated by a target as part of a "Magic Instruction" (cpuid with
/// a specific leaf on x86) and passed to SIMICS through the `Core_Magic_Instruction` HAP
pub enum MagicCode {
    /// Magic value that the target has reached its start location
    Start = MAGIC_START,
    /// Magic value that the target has reached its stop location
    Stop = MAGIC_STOP,
    /// Magic value that the target is executing a winintrin `__cpuidex` at its start location
    StartWinIntrin64 = MAGIC_START_WININTRIN,
}

impl TryFrom<i64> for MagicCode {
    type Error = Error;

    /// Try to convert a u16 value to a known `Magic` value
    fn try_from(value: i64) -> Result<Self> {
        num::FromPrimitive::from_u16(value as u16)
            .context(format!("Could not convert value {} to MagicCode", value))
    }
}

impl TryInto<i64> for MagicCode {
    type Error = Error;
    fn try_into(self) -> Result<i64> {
        Ok(self.to_u16().context("Could not convert self to i64")? as i64)
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum Magic {
    /// Start magic instruction
    Start((MagicCode, Option<u64>, Option<u64>)),
    /// Stop magic instruction
    Stop((MagicCode, Option<u64>)),
    /// Start magic instruction, windows intrinsic version
    StartWinIntrin64((MagicCode, Option<u32>)),
}

impl TryFrom<i64> for Magic {
    type Error = Error;

    fn try_from(value: i64) -> Result<Self> {
        let code = MagicCode::try_from(value)?;
        Ok(match code {
            MagicCode::Start => Self::Start((code, None, None)),
            MagicCode::Stop => Self::Stop((code, None)),
            MagicCode::StartWinIntrin64 => Self::StartWinIntrin64((code, None)),
        })
    }
}
